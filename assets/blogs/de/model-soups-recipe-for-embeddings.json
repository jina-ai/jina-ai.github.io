{
  "slug": "model-soups-recipe-for-embeddings",
  "id": "681b63a077c406000104263b",
  "uuid": "e3fc45b3-6cf9-4a0b-863f-bc4a8417c436",
  "title": "Model Soup’s Rezept für Embeddings",
  "html": "<p>In diesen schwierigen Zeiten geht nichts über eine schöne, warme Schüssel Suppe.</p><p>Minestrone ist eine der klassischen italienischen Suppen: dick, herzhaft, schmackhaft, eine Kombination aus Bohnen, herzhaftem Gemüse und Reis oder Nudeln. Ihr Geschmack ist das Ergebnis der Zusammenstellung verschiedener Zutaten. Sie ähnelt ein wenig Borschtsch in Osteuropa, Aufläufen in Amerika oder einem hausgemachten Stir-Fry in der Pazifikregion Asiens, da sie verfügbare, preiswerte Zutaten zu einem beliebten Gericht kombiniert.</p><p>Wir können eine ähnliche Art von Rezept für neuronale Netzwerkmodelle verwenden, wie aus einer Reihe von Arbeiten hervorgeht, die mit <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a> beginnen.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://proceedings.mlr.press/v162/wortsman22a.html\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time</div><div class=\"kg-bookmark-description\">The conventional recipe for maximizing model accuracy is to (1) train multiple models with various hyperparameters and (2) pick the individual model which performs best on a held-out validation set…</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-pmlr.ico\" alt=\"\"><span class=\"kg-bookmark-author\">PMLR</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://proceedings.mlr.press/v162/assets/images/logo-pmlr.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>“Model soups” (leider nicht “Model Casseroles” oder “Model Stir-Fries”) sind eine Klasse von Model-Ensembling-Techniken, die dazu dienen, die Kosten für die Optimierung von Trainingsdaten und Modell-Hyperparametern zu senken. Beim Trainieren eines neuronalen Netzes probieren Sie typischerweise verschiedene Daten und Hyperparameterwerte aus und trainieren mehrmals, um das beste Ergebnis zu erzielen. Das Training ist sehr rechenintensiv, und die Kosten summieren sich schnell.</p><p>Stattdessen beinhaltet Model Soups das Trainieren mehrerer Modelle mit unterschiedlichen Hyperparametern und Trainingsdaten – genau wie Sie es normalerweise tun würden –, aber dann das Kombinieren dieser Modelle. Das Ergebnis ist ein leistungsfähigeres und robusteres Modell als das beste Einzelmodell. Es spart keine Kosten, da Sie immer noch mehrere Modelle trainieren, aber Sie können ein besseres Ergebnis zum gleichen Preis erzielen.</p><p>Der Model-Soup-Ansatz hat sich bereits für multimodale Text-Bild-Einbettungsmodelle <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">(Wortsman et al. 2022)</a> und generative Large Language Models als nützlich erwiesen. (<a href=\"https://doi.org/10.1038/s42256-024-00975-8\">Takuya et al. 2025</a>) Bei Jina AI haben wir begonnen, diese Technik zum Trainieren unserer eigenen Modelle zu verwenden, und <code>jina-embeddings-v3</code> und <code>reader-lm-v2</code> enthalten beide Model Soups.</p><p>In diesem Artikel werden wir uns Model Soups ansehen und die Ergebnisse einiger unserer Arbeiten damit zeigen. Insbesondere:</p><ol><li>Können wir Model Soups verwenden, um die Leistung zu verbessern, indem wir Modelle zu verschiedenen Zeitpunkten ihres Trainings zusammenführen?</li><li>Können wir Modelle zusammenführen, die mit verschiedenen Datensätzen und für verschiedene Aufgaben trainiert wurden, um eine bessere Leistung und eine höhere Trainingseffizienz zu erzielen, als durch das Training eines einzelnen Modells?</li></ol><p>Dies hat wichtige potenzielle Vorteile:</p><ul><li>Model Soups können eine bessere und robustere Leistung haben.</li><li>Mehrsprachige Einbettungsmodelle leiden oft unter Verzerrungen und Leistungseinbußen, die durch ungleiche Mengen an Trainingsdaten verursacht werden. Es wäre ein Segen, in der Lage zu sein, das beste Modell, das wir können, für jede Aufgabe oder jeden Datensatz einzeln zu trainieren und sie dann gleichwertig zu kombinieren.</li><li>Wir können möglicherweise ein besseres kontinuierliches Lernen und Modell-Updating durchführen, indem wir Änderungen an unseren Modellen auf modulare Weise vornehmen, jeweils eine Komponentenmodell aktualisieren und es dann wieder mit den anderen zusammenführen.</li></ul><h2 id=\"how-does-it-work\">Wie funktioniert es?</h2><p>Das Zusammenführen der Ausgaben mehrerer Modelle ist eine alte Technik in der statistischen Entscheidungstheorie. Zum Beispiel ist es in der Wettervorhersage üblich, mehrere Modelle zu erstellen, oft von verschiedenen Personen mit unterschiedlichen Annahmen, und dann eine Vielzahl von Mechanismen zu verwenden, um ihre Vorhersagen zu mitteln. Wenn die Fehler jedes Modells zufällig verteilt sind, führt die Mittelung der Modelle zu Antworten mit weniger Fehlern.</p><p>Wenn Sie zum Beispiel drei verschiedene Modelle haben, die ein binäres “Ja” oder “Nein” ausgeben, und jedes liegt 10 % der Zeit falsch, dann liegen zwei von drei nur 2,8 % der Zeit falsch. Fünf Modelle mit einem Mehrheitsentscheidungskriterium liegen nur 0,856 % der Zeit falsch.</p><p>Die Mittelung von Modellen funktioniert nach dem gleichen Prinzip, aber anstatt die Ausgaben verschiedener Modelle zu kombinieren, kombiniert sie die Modelle selbst.</p><p>Der verwendete Ansatz ist eine Erweiterung der <em>stochastic weight averaging</em> (<a href=\"https://auai.org/uai2018/proceedings/papers/313.pdf\">Izmailov et al. 2018</a>), die auf Erkenntnissen über die Verlustlandschaften neuronaler Netze beruht, um zu zeigen, dass eine einfache Gewichtungsmittelung die Generalisierungsleistung des Modells unter gängigen Bedingungen verbessern kann.</p><p>Die eigentliche Mechanik der Mittelung der Modelle ist erschreckend einfach: Sie mitteln einfach die Gewichte mehrerer Modelle.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/05/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"380\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/05/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/05/image.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2025/05/image.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2025/05/image.png 2400w\" sizes=\"(min-width: 1200px) 1200px\"><figcaption><span style=\"white-space: pre-wrap;\">Wie Modelle zusammengeführt werden, um eine Model Soup herzustellen. Dieses Beispiel ist sehr klein und einfach, zeigt aber dennoch das Verfahren: Summieren Sie die Gewichte und teilen Sie sie durch die Anzahl der zusammengeführten Modelle.</span></figcaption></figure><p>Wenn dies zu einfach erscheint, ist es wichtig zu beachten, dass es Einschränkungen gibt, wenn Modelle auf diese Weise zusammengeführt werden. Sie können nicht einfach die Gewichte von zwei beliebigen neuronalen Netzen zusammenführen und erwarten, dass es funktioniert.</p><p>Die Modellmittelung funktioniert nur bei sehr ähnlichen Modellen, d. h. Modellen, deren Gewichte sich von vornherein nicht sehr voneinander unterscheiden. Um dies sicherzustellen, besteht die Möglichkeit, ein Modell vorzutrainieren und dann mehrere Varianten dieses Modells zu erstellen, indem man sie mit unterschiedlichen Hyperparametern oder unterschiedlichen Daten feinabstimmt. Diese Modelle sind in der Regel ähnlich genug, um sie zu mitteln.</p><p>In technischeren Begriffen führt das Vortraining in der Regel zu einem Modell, dessen Gewichte sich in der Nähe des Bodens eines Verlustbeckens befinden, und die Feinabstimmung führt nicht ohne weiteres dazu, dass dieses Verlustbecken verlassen wird. Wenn alle zu verschmelzenden Modelle Gewichte im gleichen Verlustbecken haben, dann sind ihre Gewichte ziemlich nahe beieinander, und das Mitteln ist wahrscheinlich erfolgreich. Dies ist nicht garantiert, aber empirisch scheint es oft genug wahr zu sein, um nützlich zu sein.</p><h2 id=\"experimental-setup\">Experimenteller Aufbau</h2><p><strong>Basismodell</strong>: Für die hier beschriebenen Experimente verwendeten wir <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code> von FacebookAI</a> (<a href=\"https://aclanthology.org/2020.acl-main.747/\">Conneau et al. 2020</a>) als unser vortrainiertes Basismodell. Dieses Modell hat 280 Millionen Parameter und wurde auf 2,5 TB Common Crawl-Daten vortrainiert, die Texte in etwa 100 Sprachen enthalten.</p><p>Wir haben <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code></a> auf unserem kuratierten Satzpaar-Trainingssatz für das Einbettungstraining feinabgestimmt, bevor wir unsere Experimente durchführten.</p><p><strong>Trainingsdaten</strong>: Jina AI unterhält kundenspezifisch kuratierte Datensätze für das Training. Für das erste Experiment verwendeten wir Satz-Tripletts, die speziell für das kontrastive Training in sechs Sprachen kuratiert wurden: Englisch, Arabisch, Deutsch, Spanisch, Japanisch und Chinesisch. Für das zweite Experiment verwendeten wir aufgabenspezifische Trainingsdatensätze in Englisch.</p><p><strong>Evaluation</strong>: Wir verwendeten relevante Teile des <a href=\"https://github.com/embeddings-benchmark/mteb/tree/main/docs/mmteb\">MMTEB Benchmark Sets</a> (<a href=\"https://arxiv.org/abs/2502.13595\">Enevoldsen et al. 2025</a>) und <a href=\"https://project-miracl.github.io/\">MIRACL Benchmarks</a> (<a href=\"https://direct.mit.edu/tacl/article/doi/10.1162/tacl_a_00595/117438/MIRACL-A-Multilingual-Retrieval-Dataset-Covering\">Zhang et al. 2023</a>), um die von unserem Training und der Zusammenführung erzeugten Modelle zu bewerten.</p><h3 id=\"experiment-1-single-run-averaging\">Experiment 1: Single-Run Averaging</h3><p>Für dieses Experiment verwendeten wir kontrastive Satz-Tripletts in allen sechs Sprachen, gemischt, für insgesamt 6.000 Trainingsschritte mit einer Batch-Größe von 1.024 Elementen. Alle 2.000 Schritte speicherten wir den Modellstatus zur Mittelung, wodurch 3 Modelle entstanden, die jeweils einen anderen Punkt im Trainingsprozess widerspiegeln.</p><p>Wir haben die drei Modelle gemittelt, um ein endgültiges Modell zu erstellen. Anschließend testeten wir das zusammengeführte Modell und die drei gespeicherten Checkpoints anhand der MMTEB-STS- und MIRACL-Benchmark-Sätze.</p><p>Unsere Ergebnisse sind in der folgenden Tabelle zusammengefasst:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>MIRACL<br>(avg 6 languages)</th>\n<th>MMTEB-STS English<br>(avg 8 benchmarks)</th>\n<th>MMTEB-STS Multilingual<br>(avg 6 benchmarks)</th>\n<th>Average of 20 benchmarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>No triplet training</td>\n<td>0.3163</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.6276</td>\n</tr>\n<tr>\n<td>Step 2000</td>\n<td>0.4631</td>\n<td><strong>0.7924</strong></td>\n<td>0.7561</td>\n<td>0.6813</td>\n</tr>\n<tr>\n<td>Step 4000</td>\n<td>0.4639</td>\n<td>0.7902</td>\n<td><strong>0.7583</strong></td>\n<td>0.6812</td>\n</tr>\n<tr>\n<td>Step 6000 (final)</td>\n<td><strong>0.4680</strong></td>\n<td>0.7891</td>\n<td>0.7575</td>\n<td>0.6818</td>\n</tr>\n<tr>\n<td>Merged model<br>(all 3 stored checkpoints)</td>\n<td>0.4669</td>\n<td>0.7910</td>\n<td>0.7579</td>\n<td><strong>0.6823</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Das Zusammenführen mit vorherigen Checkpoints führte im Allgemeinen nicht zu einem besseren Modell als das leistungsstärkste Modell unter den gespeicherten Checkpoints bei einzelnen Benchmarks oder bei einem der drei verwendeten Benchmark-Batterien. Es führte jedoch zum besten Modell bei allen zusammen gemittelten Benchmarks.</p><p>Bei einzelnen Benchmarks beträgt der Unterschied zwischen dem zusammengeführten Modell und dem leistungsstärksten Checkpoint in jedem Fall weniger als 0,01. Dies gilt nicht nur für die Durchschnittswerte in der obigen Tabelle, sondern für jeden einzelnen Test.</p><p>Dies zeigt, dass das Zusammenführen verschiedener Trainings-Checkpoints zu einem robusteren Modell mit sehr geringen Leistungseinbußen führen kann.</p><p>Darüber hinaus können wir durch das Zusammenführen der verschiedenen Checkpoints eine Überanpassung wirksam verhindern. Übertraining ist in letzter Zeit zu einem wichtigen Thema in neuronalen Netzen geworden. (<a href=\"https://arxiv.org/abs/2503.19206v2\">Springer et al., 2025</a>) Ein Netzwerk kann so trainiert werden, dass es nach einer weiteren Feinabstimmung schwieriger und schlechter wird.</p><p>Da der leistungsstärkste Checkpoint in unserem Experiment oft nicht der letzte ist, haben wir unser Modell wahrscheinlich bei 6.000 Trainingsschritten übertrainiert. Das zusammengeführte Modell kommt der Leistung des besten Checkpoints in allen Tests sehr nahe und beseitigt die Defekte des Übertrainings.</p><h3 id=\"experiment-2-averaging-models-trained-for-different-tasks\">Experiment 2: Mittelung von Modellen, die für verschiedene Aufgaben trainiert wurden</h3><p>Für dieses Experiment haben wir drei Modelle trainiert, jedes für eine andere gängige Einbettungsaufgabe:</p><ul><li><strong>Semantische Ähnlichkeit</strong>: Messung der relativen Überschneidung oder Ähnlichkeit in der Bedeutung zwischen zwei Texten, typischerweise von vergleichbarer Länge.</li><li><strong>Dokumentenabruf auf der Grundlage von Textanfragen</strong>: Finden der Dokumente, die eine Anfrage am besten erfüllen. Anfragen sind in der Regel viel kürzere Texte als die Dokumente, mit denen sie übereinstimmen.</li><li><strong>Frage-Antwort-Systeme</strong>: Finden des Dokuments, das eine Frage in natürlicher Sprache am besten beantwortet. Fragen sind im Allgemeinen auch kürzer als die Texte, mit denen sie übereinstimmen.</li></ul><p>Das gleichzeitige Trainieren von Modellen für alle drei Aufgaben ist recht schwierig, da die Ziele sehr unterschiedlich sind, und wir hoffen, dass Model Soups den Prozess verbessern werden.</p><p>Aufgrund früherer Erfahrungen wussten wir, dass jede Aufgabe eine andere Anzahl von Trainingsepochen erfordert. Das Training ist im Folgenden zusammengefasst:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Aufgabe</th>\n<th>Trainingsschritte<br>(Batchgröße = 1.024)</th>\n<th>Größe des Trainingsdatensatzes<br>(in Elementen)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Frage-Antwort-Systeme (QA)</td>\n<td>2.000</td>\n<td>256.000</td>\n</tr>\n<tr>\n<td>Dokumentenabruf</td>\n<td>3.000</td>\n<td>384.000</td>\n</tr>\n<tr>\n<td>Semantische Ähnlichkeit (STS)</td>\n<td>1.000</td>\n<td>128.000</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Dadurch entstanden drei Modelle, die wir dann zu einem einzigen Modell zusammenführten. Wir haben das resultierende Modell anhand der für diese drei Aufgaben relevanten Teile des MMTEB-Benchmark-Sets getestet: <a href=\"https://project-miracl.github.io/\">MIRACL</a>, <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a> und STSEval (englische und mehrsprachige Teile von MMTEB).</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(Durchschnitt aus 6 Sprachen)</th>\n<th>NanoBEIR<br>(Durchschnitt aus 13 Benchmarks)</th>\n<th>MMTEB-STS Englisch<br>(Durchschnitt aus 9 Benchmarks)</th>\n<th>MMTEB-STS Mehrsprachig<br>(Durchschnitt aus 6 Benchmarks)</th>\n<th>Durchschnitt aus 34 Benchmarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Kein Triplet-Training</td>\n<td>0.3163</td>\n<td>0.5089</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.5876</td>\n</tr>\n<tr>\n<td>QA-Training</td>\n<td><strong>0.4489</strong></td>\n<td>0.5332</td>\n<td>0.7843</td>\n<td>0.7535</td>\n<td>0.6237</td>\n</tr>\n<tr>\n<td>Retrieval-Training</td>\n<td>0.4272</td>\n<td><strong>0.5360</strong></td>\n<td>0.7766</td>\n<td>0.7340</td>\n<td>0.6154</td>\n</tr>\n<tr>\n<td>STS-Training</td>\n<td>0.1779</td>\n<td>0.4519</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.5508</td>\n</tr>\n<tr>\n<td>Zusammengeführtes Modell</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td><strong>0.6240</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Wir sehen hier, dass die aufgabenspezifisch trainierten Modelle die beste Leistung bei jeder Aufgabe erzielen. MIRACL ist in erster Linie ein Frage-Antwort-Benchmark, auch wenn es sich um einen Retrieval-Benchmark handelt, und das QA-trainierte Modell übertrifft alle anderen, einschließlich des zusammengeführten Modells. NanoBEIR ist ein konventionelleres Information-Retrieval-Benchmark-Set, und wir sehen, dass das Retrieval-trainierte Modell hier am besten abschneidet. Das semantische Ähnlichkeitsmodell (STS) schneidet bei diesen Benchmarks recht schlecht ab, schlägt aber die anderen bei expliziten STS-Aufgaben. In jeder Kategorie schneidet das zusammengeführte Modell schlechter ab als das einzeln trainierte Modell.</p><p>Aber wiederum, wenn wir alle Benchmarks mitteln, übertrifft das zusammengeführte Modell die anderen, obwohl seine Punktzahl nur eine sehr geringe Verbesserung gegenüber dem QA-trainierten Modell darstellt und es bei STS-Aufgaben sehr schlecht abschneidet.</p><p>Wir haben auch nur die QA- und Retrieval-Modelle zusammengeführt und das resultierende Modell anhand derselben Benchmarks bewertet:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(Durchschnitt aus 6 Sprachen)</th>\n<th>NanoBEIR<br>(Durchschnitt aus 13 Benchmarks)</th>\n<th>MMTEB-STS Englisch<br>(Durchschnitt aus 9 Benchmarks)</th>\n<th>MMTEB-STS Mehrsprachig<br>(Durchschnitt aus 6 Benchmarks)</th>\n<th>Durchschnitt aus 34 Tests</th>\n<th>Durchschnitt<br>QA &amp; IR<br>(19 Tests)</th>\n<th>Durchschnitt STS<br>(15 Tests)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bestes aufgabenspezifisch trainiertes Modell</td>\n<td>0.4489</td>\n<td>0.5360</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.6237</td>\n<td>0.5066</td>\n<td><strong>0.7857</strong></td>\n</tr>\n<tr>\n<td>Zusammengeführtes Modell</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td>0.6240</td>\n<td>0.4973</td>\n<td>0.7845</td>\n</tr>\n<tr>\n<td>QA+Retrieval zusammengeführtes Modell</td>\n<td><strong>0.4610</strong></td>\n<td><strong>0.5404</strong></td>\n<td>0.7878</td>\n<td>0.7498</td>\n<td><strong>0.6288</strong></td>\n<td><strong>0.5153</strong></td>\n<td>0.7726</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Wir sehen hier, dass wir zwar die Leistung sowohl bei Frage-Antwort-Systemen als auch beim Retrieval verbessern können, indem wir trainierte Modelle für die beiden Aufgaben zusammenführen, aber das Hinzufügen von STS-trainierten Modellen die aufgabenspezifische Leistung in allen Kategorien reduziert. Dies deutet darauf hin, dass die semantische Ähnlichkeit in gewisser Hinsicht anders ist als QA und Retrieval, und ein STS-trainiertes Modell ist nicht geeignet, mit den anderen beiden zusammengeführt zu werden.</p><p>Dies liegt wahrscheinlich daran, dass Frage-Antwort-Systeme und Retrieval das Abgleichen von kurzen Texten — Fragen und Anfragen — mit längeren Dokumenten beinhalten, während semantische Ähnlichkeit den Vergleich von Dokumenten ähnlicher Länge beinhaltet.</p><p><a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a> beschreiben einen selektiven Ansatz zur Mittelwertbildung, den sie als „gieriges“ Zusammenführen bezeichnen. Dabei wird ein Modell genommen, in der Regel das leistungsstärkste einer Reihe von Modellen, und dann werden nur die Modelle hinzugefügt, die die Leistung einzeln verbessern. Bei nur drei Modellen war es für dieses Experiment wenig sinnvoll, gieriges Zusammenführen zu verwenden. Wir könnten uns jedoch einen Fall mit mehr Modellen vorstellen und eine solche Technik als Grundlage für die Bestimmung des Ähnlichkeitsgrades zwischen Aufgaben verwenden. Wir haben hier festgestellt, dass die semantische Ähnlichkeit anders ist als die beiden anderen. Wir könnten dann beurteilen, wann ein Modell viele Aufgaben erfüllen kann und wann es kostengünstiger ist, ein anderes Modell zu verwenden.</p><h2 id=\"soup%E2%80%99s-on\">Soup’s on!</h2><p>Model Soups mischen Vielfalt zu etwas, das größer ist als die Summe ihrer Teile. Der Wert dieses Ansatzes liegt in seiner Fähigkeit, mehr Konsistenz und Robustheit zu bieten und als Schutz vor Übertraining ohne zusätzliche Trainingskosten zu dienen. Unsere Experimente zeigen, dass das Zusammenführen von Checkpoints oder aufgabenspezifischen Modellen die Gesamtleistung verbessern kann, auch wenn dies gelegentlich auf Kosten aufgabenspezifischer Spitzen geht.</p><p>Letztendlich bieten Model Soups eine praktische und sehr einfache Möglichkeit, anpassungsfähigere Modelle zu erstellen, obwohl dies mit einigen Einschränkungen verbunden ist. Es ist kein Allheilmittel und nur anwendbar, wenn sich Modelle bereits sehr ähnlich sind.</p><p>Wie man im Internet sagt: <em>Your Mileage May Vary</em>. Aber es ist billig und einfach herauszufinden, ob Model Soups helfen können, wenn Sie Ihre Modelle trainieren.</p>",
  "comment_id": "681b63a077c406000104263b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/05/Heading--6-.jpg",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-05-07T15:44:00.000+02:00",
  "updated_at": "2025-05-07T19:56:02.000+02:00",
  "published_at": "2025-05-07T18:43:10.000+02:00",
  "custom_excerpt": "Boost robustness and performance with model soups: averaging weights. No extra cost, better results.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/model-soups-recipe-for-embeddings/",
  "excerpt": "Verbessern Sie Robustheit und Leistung mit Model Soups: Gewichte mitteln. Keine zusätzlichen Kosten, bessere Ergebnisse.",
  "reading_time": 9,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}