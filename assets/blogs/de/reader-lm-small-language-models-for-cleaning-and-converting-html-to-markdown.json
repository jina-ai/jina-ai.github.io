{
  "slug": "reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown",
  "id": "66dff7eba241f5000155d851",
  "uuid": "49dc11d4-e792-49d6-b778-512add9024bc",
  "title": "Reader-LM: Kleine Sprachmodelle für die Bereinigung und Konvertierung von HTML zu Markdown",
  "html": "<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-0.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-0.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Wir sind auf einer Reise zur Weiterentwicklung und Demokratisierung künstlicher Intelligenz durch Open Source und Open Science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-0.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-1.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-1.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Wir sind auf einer Reise zur Weiterentwicklung und Demokratisierung künstlicher Intelligenz durch Open Source und Open Science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-1.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Im April 2024 haben wir <a href=\"https://jina.ai/reader?ref=jina-ai-gmbh.ghost.io\">Jina Reader</a> veröffentlicht, eine einfache API, die jede URL mit einem simplen Präfix <code>r.jina.ai</code> in LLM-freundliches Markdown umwandelt. Trotz der ausgefeilten Netzwerkprogrammierung im Hintergrund ist der eigentliche \"Lese\"-Teil recht unkompliziert. Zunächst verwenden wir einen Headless Chrome Browser, um die Quelle der Webseite abzurufen. Dann nutzen wir Mozillas <a href=\"https://github.com/mozilla/readability?ref=jina-ai-gmbh.ghost.io\">Readability</a> Paket, um den Hauptinhalt zu extrahieren und Elemente wie Header, Footer, Navigationsleisten und Seitenleisten zu entfernen. Schließlich konvertieren wir das bereinigte HTML in Markdown unter Verwendung von <a href=\"https://x.com/JinaAI_/status/1823756993108304135?ref=jina-ai-gmbh.ghost.io\">Regex</a> und der <a href=\"https://github.com/mixmark-io/turndown?ref=jina-ai-gmbh.ghost.io\">Turndown Library</a>. Das Ergebnis ist eine gut strukturierte Markdown-Datei, die von LLMs für Grounding, Zusammenfassungen und Reasoning genutzt werden kann.</p><p>In den ersten Wochen nach der Veröffentlichung von Jina Reader erhielten wir viel Feedback, besonders zur Qualität des Inhalts. Einige Nutzer fanden es zu detailliert, während andere es nicht detailliert genug empfanden. Es gab auch Berichte, dass der Readability-Filter falsche Inhalte entfernte oder Turndown Probleme hatte, bestimmte HTML-Teile in Markdown umzuwandeln. Glücklicherweise konnten viele dieser Probleme durch das Patchen der bestehenden Pipeline mit neuen Regex-Mustern oder Heuristiken gelöst werden.</p><p>Seitdem beschäftigt uns eine Frage: Können wir dieses Problem statt mit weiteren Heuristiken und Regex (die zunehmend schwerer zu warten und nicht mehrsprachig freundlich sind) _end-to-end_ mit einem Sprachmodell lösen?</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png\" class=\"kg-image\" alt=\"Flussdiagramm zur Illustration der Konvertierung von rohem HTML zu Markdown-Format unter Verwendung von Readability und Turndown Libraries plus Regex/Heu\" loading=\"lazy\" width=\"1800\" height=\"945\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/Heading--48-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/Heading--48-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/Heading--48-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png 1800w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Illustration von </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>reader-lm</span></code><span style=\"white-space: pre-wrap;\">, das die Pipeline aus Readability+Turndown+Regex-Heuristiken durch ein kleines Sprachmodell ersetzt.</span></figcaption></figure><p>Auf den ersten Blick mag die Verwendung von LLMs für Datenbereinigung aufgrund ihrer geringen Kosteneffizienz und langsameren Geschwindigkeit übertrieben erscheinen. Aber was, wenn wir ein <strong>kleines Sprachmodell (SLM)</strong> in Betracht ziehen – eines mit weniger als 1 Milliarde Parametern, das effizient am Edge laufen kann? Das klingt schon attraktiver, oder? Aber ist das wirklich machbar oder nur Wunschdenken? Nach dem Skalierungsgesetz führen weniger Parameter generell zu reduzierten Reasoning- und Zusammenfassungsfähigkeiten. Ein SLM könnte also sogar Schwierigkeiten haben, überhaupt bedeutungsvolle Inhalte zu generieren, wenn seine Parametergröße zu klein ist. Schauen wir uns die HTML-zu-Markdown-Aufgabe genauer an:</p><ul><li>Erstens ist die Aufgabe, die wir betrachten, <strong>nicht so kreativ oder komplex wie typische LLM-Aufgaben</strong>. Bei der Konvertierung von HTML zu Markdown muss das Modell hauptsächlich <strong>selektiv kopieren</strong> vom Input zum Output (d.h. HTML-Markup, Seitenleisten, Header, Footer überspringen), mit minimalem Aufwand für die Generierung neuer Inhalte (hauptsächlich Einfügen von Markdown-Syntax). Dies unterscheidet sich stark von den breiteren Aufgaben, die LLMs bewältigen, wie das Generieren von Gedichten oder das Schreiben von Code, bei denen der Output viel mehr Kreativität erfordert und nicht direkt aus dem Input kopiert wird. Diese Beobachtung deutet darauf hin, dass ein SLM funktionieren könnte, da die Aufgabe _einfacher_ erscheint als allgemeinere Textgenerierung.</li><li>Zweitens müssen wir <strong>die Unterstützung für lange Kontexte priorisieren</strong>. Modernes HTML enthält oft viel mehr Rauschen als einfaches <code>&lt;div&gt;</code> Markup. Inline CSS und Scripts können den Code leicht auf hunderttausende von Tokens aufblähen. Damit ein SLM in diesem Szenario praktikabel ist, muss die Kontextlänge ausreichend groß sein. Token-Längen wie 8K oder 16K sind _überhaupt nicht_ nützlich.</li></ul><p>Es scheint, dass wir ein <strong><em>flaches-aber-breites</em></strong> SLM benötigen. \"Flach\" in dem Sinne, dass die Aufgabe hauptsächlich einfaches \"Kopieren-Einfügen\" ist, daher werden weniger Transformer-Blöcke benötigt; und \"breit\" in dem Sinne, dass es Unterstützung für lange Kontexte erfordert, um praktikabel zu sein, sodass der Aufmerksamkeitsmechanismus sorgfältig gestaltet werden muss. Frühere Forschungen haben gezeigt, dass Kontextlänge und Reasoning-Fähigkeit eng miteinander verwoben sind. Für ein SLM ist es äußerst herausfordernd, beide Dimensionen zu optimieren und dabei die Parametergröße klein zu halten.</p><p>Heute freuen wir uns, die erste Version dieser Lösung mit der Veröffentlichung von <code>reader-lm-0.5b</code> und <code>reader-lm-1.5b</code> anzukündigen, zwei SLMs, die speziell darauf trainiert wurden, <strong>sauberes Markdown direkt aus verrauschtem rohem HTML zu generieren</strong>. Beide Modelle sind mehrsprachig und unterstützen eine Kontextlänge von bis zu <strong>256K Tokens</strong>. Trotz ihrer kompakten Größe erreichen diese Modelle State-of-the-Art-Leistung bei dieser Aufgabe und übertreffen größere LLM-Gegenstücke, während sie nur 1/50 ihrer Größe haben.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Reader-LM-vs-LLMs-on-the-HTML2Markdown-task--1-.svg\" class=\"kg-image\" alt=\"Balkendiagramm zeigt Reader-LMs überlegene HTML2Markdown-Aufgabenleistung mit dem höchsten Score von 0,72 gegenüber verschiedenen LLMs.\" loading=\"lazy\" width=\"805\" height=\"514\"></figure><p>Hier sind die Spezifikationen der beiden Modelle:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">reader-lm-0.5b</th>\n<th style=\"text-align:center\">reader-lm-1.5b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td># Parameter</td>\n<td style=\"text-align:center\">494M</td>\n<td style=\"text-align:center\">1.54B</td>\n</tr>\n<tr>\n<td>Kontextlänge</td>\n<td style=\"text-align:center\">256K</td>\n<td style=\"text-align:center\">256K</td>\n</tr>\n<tr>\n<td>Hidden Size</td>\n<td style=\"text-align:center\">896</td>\n<td style=\"text-align:center\">1536</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">128</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td style=\"text-align:center\">4864</td>\n<td style=\"text-align:center\">8960</td>\n</tr>\n<tr>\n<td>Mehrsprachig</td>\n<td style=\"text-align:center\">Ja</td>\n<td style=\"text-align:center\">Ja</td>\n</tr>\n<tr>\n<td>HuggingFace Repo</td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-0.5b/?ref=jina-ai-gmbh.ghost.io\">Link</a></td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-1.5b/?ref=jina-ai-gmbh.ghost.io\">Link</a></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"get-started-with-reader-lm\">Erste Schritte mit Reader-LM</h2><h3 id=\"on-google-colab\">Auf Google Colab</h3><p>Der einfachste Weg, <code>reader-lm</code> auszuprobieren, ist über unser Colab Notebook, in dem wir demonstrieren, wie man <code>reader-lm-1.5b</code> verwendet, um die Hacker News Website in Markdown zu konvertieren. Das Notebook ist optimiert, um reibungslos auf Google Colabs kostenloser T4 GPU-Tier zu laufen. Sie können auch <code>reader-lm-0.5b</code> laden oder die URL zu einer beliebigen Website ändern und die Ausgabe erkunden. Beachten Sie, dass der Input (d.h. der Prompt) für das Modell das rohe HTML ist – keine Präfix-Anweisung ist erforderlich.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/1wXWyj5hOxEHY6WeHbOwEzYAC0WB1I5uA?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/colab_favicon_256px.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Bitte beachten Sie, dass die kostenlose T4 GPU Einschränkungen hat, die die Verwendung fortgeschrittener Optimierungen während der Modellausführung verhindern könnten. Features wie bfloat16 und Flash Attention sind auf der T4 nicht verfügbar, was zu höherem VRAM-Verbrauch und langsamerer Leistung bei längeren Eingaben führen kann. <strong>Für Produktionsumgebungen empfehlen wir die Verwendung einer High-End-GPU wie der RTX 3090/4090 für deutlich bessere Leistung.</strong></p><h3 id=\"in-production-available-on-azure-aws-soon\">In Produktion: Bald verfügbar auf Azure & AWS</h3><p>Reader-LM ist im Azure Marketplace und AWS SageMaker verfügbar. Wenn Sie diese Modelle über diese Plattformen hinaus oder On-Premises in Ihrem Unternehmen nutzen möchten, beachten Sie, dass beide Modelle unter CC BY-NC 4.0 lizenziert sind. <a href=\"https://jina.ai/contact-sales/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Für kommerzielle Nutzungsanfragen kontaktieren Sie uns gerne.</a></p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-nli7b6dueo424?sr=0-1&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 0.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-ms27ixcwq3wjk?sr=0-2&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 1.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-500m?tab=Overview&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-1500m?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><h2 id=\"benchmark\">Benchmark</h2><p>Zur quantitativen Bewertung der Leistung von Reader-LM haben wir es mit mehreren großen Sprachmodellen verglichen, darunter: GPT-4o, Gemini-1.5-Flash, Gemini-1.5-Pro, LLaMA-3.1-70B, Qwen2-7B-Instruct.</p><p>Die Modelle wurden anhand folgender Metriken bewertet:</p><ul><li><strong>ROUGE-L (höher ist besser)</strong>: Diese Metrik, die häufig für Zusammenfassungs- und Frage-Antwort-Aufgaben verwendet wird, misst die Überlappung zwischen der vorhergesagten Ausgabe und der Referenz auf N-Gram-Ebene.</li><li><strong>Token Error Rate (TER, niedriger ist besser)</strong>: Diese Metrik berechnet die Rate, mit der die generierten Markdown-Token nicht im ursprünglichen HTML-Inhalt erscheinen. Wir haben diese Metrik entwickelt, um die Halluzinationsrate des Modells zu bewerten und Fälle zu identifizieren, in denen das Modell Inhalte produziert, die nicht im HTML begründet sind. Weitere Verbesserungen werden basierend auf Fallstudien vorgenommen.</li><li><strong>Word Error Rate (WER, niedriger ist besser)</strong>: WER wird häufig bei OCR- und ASR-Aufgaben verwendet und berücksichtigt die Wortsequenz und berechnet Fehler wie Einfügungen (ADD), Ersetzungen (SUB) und Löschungen (DEL). Diese Metrik bietet eine detaillierte Bewertung der Unterschiede zwischen dem generierten Markdown und der erwarteten Ausgabe.</li></ul><p>Um LLMs für diese Aufgabe zu nutzen, verwendeten wir die folgende einheitliche Anweisung als Prefix-Prompt:</p><pre><code>Your task is to convert the content of the provided HTML file into the corresponding markdown file. You need to convert the structure, elements, and attributes of the HTML into equivalent representations in markdown format, ensuring that no important information is lost. The output should strictly be in markdown format, without any additional explanations.</code></pre><p>Die Ergebnisse finden Sie in der folgenden Tabelle.</p><!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ROUGE-L</th>\n<th>WER</th>\n<th>TER</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reader-lm-0.5b</td>\n<td>0.56</td>\n<td>3.28</td>\n<td>0.34</td>\n</tr>\n<tr>\n<td>reader-lm-1.5b</td>\n<td><strong>0.72</strong></td>\n<td><strong>1.87</strong></td>\n<td><strong>0.19</strong></td>\n</tr>\n<tr>\n<td>gpt-4o</td>\n<td>0.43</td>\n<td>5.88</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>gemini-1.5-flash</td>\n<td>0.40</td>\n<td>21.70</td>\n<td>0.55</td>\n</tr>\n<tr>\n<td>gemini-1.5-pro</td>\n<td>0.42</td>\n<td>3.16</td>\n<td>0.48</td>\n</tr>\n<tr>\n<td>llama-3.1-70b</td>\n<td>0.40</td>\n<td>9.87</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>Qwen2-7B-Instruct</td>\n<td>0.23</td>\n<td>2.45</td>\n<td>0.70</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"qualitative-study\">Qualitative Studie</h2><p>Wir führten eine qualitative Studie durch, indem wir die Markdown-Ausgabe visuell inspizierten. <a href=\"https://docs.google.com/spreadsheets/d/1Wb2sMdiEoToPaXohcrEznFKStt_4alVOnJD3WKkiM7o/edit?gid=1576339853&ref=jina-ai-gmbh.ghost.io#gid=1576339853\">Wir wählten 22 HTML-Quellen</a> aus, darunter Nachrichtenartikel, Blogbeiträge, Landing Pages, E-Commerce-Seiten und Forenbeiträge in mehreren Sprachen: Englisch, Deutsch, Japanisch und Chinesisch. Wir haben auch die Jina Reader API als Baseline einbezogen, die auf Regex, Heuristiken und vordefinierten Regeln basiert.</p><p>Die Bewertung konzentrierte sich auf vier Schlüsseldimensionen der Ausgabe, wobei jedes Modell auf einer Skala von 1 (niedrigste) bis 5 (höchste) bewertet wurde:</p><ol><li><strong>Header-Extraktion</strong>: Bewertete, wie gut jedes Modell die h1,h2,..., h6 Header des Dokuments identifizierte und mit korrekter Markdown-Syntax formatierte.</li><li><strong>Hauptinhalt-Extraktion</strong>: Bewertete die Fähigkeit der Modelle, Fließtext genau zu konvertieren, Absätze zu erhalten, Listen zu formatieren und die Konsistenz in der Darstellung zu bewahren.</li><li><strong>Erhaltung der reichen Struktur</strong>: Analysierte, wie effektiv jedes Modell die Gesamtstruktur des Dokuments beibehielt, einschließlich Überschriften, Unterüberschriften, Aufzählungszeichen und geordnete Listen.</li><li><strong>Markdown-Syntax-Nutzung</strong>: Bewertete die Fähigkeit jedes Modells, HTML-Elemente wie <code>&lt;a&gt;</code> (Links), <code>&lt;strong&gt;</code> (fetter Text) und <code>&lt;em&gt;</code> (kursiver Text) korrekt in ihre entsprechenden Markdown-Äquivalente zu konvertieren.</li></ol><p>Die Ergebnisse finden Sie unten.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Qualitative-Evaluation-of-Reader-LM-vs-LLMs-and-Jina-Reader-API--1-.svg\" class=\"kg-image\" alt=\"Balkendiagramm, das Reader-LM, LLMs und Jina Reader API bei Metriken wie Header-Extraktion und Inhaltserhaltung vergleicht.\" loading=\"lazy\" width=\"863\" height=\"533\"></figure><p>Reader-LM-1.5B zeigt durchgängig gute Leistungen in allen Dimensionen und überzeugt besonders bei der Strukturerhaltung und Markdown-Syntax-Nutzung. Auch wenn es nicht immer die Jina Reader API übertrifft, ist seine Leistung vergleichbar mit größeren Modellen wie Gemini 1.5 Pro, was es zu einer hocheffizienten Alternative zu größeren LLMs macht. Reader-LM-0.5B bietet, obwohl kleiner, immer noch solide Leistung, besonders bei der Strukturerhaltung.</p><h2 id=\"how-we-trained-reader-lm\">Wie wir Reader-LM trainiert haben</h2><h3 id=\"data-preparation\">Datenvorbereitung</h3><p>Wir nutzten die Jina Reader API, um Trainingspaare aus rohem HTML und entsprechendem Markdown zu generieren. Während des Experiments stellten wir fest, dass SLMs besonders empfindlich auf die Qualität der Trainingsdaten reagieren. Daher haben wir eine Datenpipeline entwickelt, die sicherstellt, dass nur hochwertige Markdown-Einträge in den Trainingsdatensatz aufgenommen werden.</p><p>Zusätzlich fügten wir einige synthetische HTML-Dateien und ihre Markdown-Entsprechungen hinzu, die von <code>GPT-4o</code> generiert wurden. Im Vergleich zu realen HTML-Daten sind synthetische Daten meist viel kürzer, mit einfacheren und vorhersehbareren Strukturen und einem deutlich niedrigeren Rauschpegel.</p><p>Schließlich verknüpften wir das HTML und Markdown mit einer Chat-Vorlage. Die endgültigen Trainingsdaten sind wie folgt formatiert:</p><pre><code>&lt;|im_start|&gt;system\nYou are a helpful assistant.&lt;|im_end|&gt;\n&lt;|im_start|&gt;user\n{{RAW_HTML}}&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n{{MARKDOWN}}&lt;|im_end|&gt;\n</code></pre><p>Die gesamten Trainingsdaten umfassen 2,5 Milliarden Token.</p><h3 id=\"two-stage-training\">Zweistufiges Training</h3><p>Wir führten Experimente mit verschiedenen Modellgrößen durch, von 65M und 135M bis hin zu 3B Parametern. Die Spezifikationen für jedes Modell sind in der nachfolgenden Tabelle aufgeführt.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>reader-lm-65m</th>\n<th>reader-lm-135m</th>\n<th>reader-lm-360m</th>\n<th>reader-lm-0.5b</th>\n<th>reader-lm-1.5b</th>\n<th>reader-lm-1.7b</th>\n<th>reader-lm-3b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hidden Size</td>\n<td>512</td>\n<td>576</td>\n<td>960</td>\n<td>896</td>\n<td>1536</td>\n<td>2048</td>\n<td>3072</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td>8</td>\n<td>30</td>\n<td>32</td>\n<td>24</td>\n<td>28</td>\n<td>24</td>\n<td>32</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td>16</td>\n<td>9</td>\n<td>15</td>\n<td>14</td>\n<td>12</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td>8</td>\n<td>3</td>\n<td>5</td>\n<td>2</td>\n<td>2</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n<td>128</td>\n<td>64</td>\n<td>96</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td>2048</td>\n<td>1536</td>\n<td>2560</td>\n<td>4864</td>\n<td>8960</td>\n<td>8192</td>\n<td>8192</td>\n</tr>\n<tr>\n<td>Attention Bias</td>\n<td>False</td>\n<td>False</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Embedding Tying</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Vocabulary Size</td>\n<td>32768</td>\n<td>49152</td>\n<td>49152</td>\n<td>151646</td>\n<td>151646</td>\n<td>49152</td>\n<td>32064</td>\n</tr>\n<tr>\n<td>Base Model</td>\n<td>Lite-Oute-1-65M-Instruct</td>\n<td>SmolLM-135M</td>\n<td>SmolLM-360M-Instruct</td>\n<td>Qwen2-0.5B-Instruct</td>\n<td>Qwen2-1.5B-Instruct</td>\n<td>SmolLM-1.7B</td>\n<td>Phi-3-mini-128k-instruct</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Das Modelltraining wurde in zwei Phasen durchgeführt:</p><ol><li><strong>Kurzer und einfacher HTML: </strong>In dieser Phase wurde die maximale Sequenzlänge (HTML + Markdown) auf 32K Token festgelegt, mit insgesamt 1,5 Milliarden Trainings-Token.</li><li><strong>Langer und komplexer HTML</strong>: Die Sequenzlänge wurde auf 128K Token erweitert, mit 1,2 Milliarden Trainings-Token. Wir implementierten den Zigzag-Ring-Attention-Mechanismus aus <a href=\"https://github.com/zhuzilin/ring-flash-attention?ref=jina-ai-gmbh.ghost.io\">Zilin Zhus „Ring Flash Attention\" (2024)</a> für diese Phase.</li></ol><p>Da die Trainingsdaten Sequenzen von bis zu 128K Token enthielten, gehen wir davon aus, dass das Modell bis zu 256K Token ohne Probleme verarbeiten kann. Die Verarbeitung von 512K Token könnte jedoch schwierig sein, da die Erweiterung von RoPE-Positionseinbettungen auf das Vierfache der Trainingssequenzlänge zu Leistungseinbußen führen könnte.</p><p>Bei den Modellen mit 65M und 135M Parametern haben wir beobachtet, dass sie ein angemessenes „Kopierverhalten\" erreichen konnten, allerdings nur bei kurzen Sequenzen (weniger als 1K Token). Mit zunehmender Eingabelänge hatten diese Modelle Schwierigkeiten, vernünftige Ausgaben zu produzieren. Da moderner HTML-Quellcode leicht 100K Token überschreiten kann, ist eine Beschränkung auf 1K Token bei weitem nicht ausreichend.</p><h3 id=\"degeneration-and-dull-loops\">Degeneration und monotone Schleifen</h3><p>Eine der größten Herausforderungen war die Degeneration, insbesondere in Form von Wiederholungen und Schleifen. Nach der Generierung einiger Token begann das Modell, dasselbe Token wiederholt zu generieren oder blieb in einer Schleife stecken, wobei es kontinuierlich eine kurze Sequenz von Token wiederholte, bis die maximal erlaubte Ausgabelänge erreicht war.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png\" class=\"kg-image\" alt=\"Dark themed coding script with repeated structural programming comments about data types, functions, and mathematical operati\" loading=\"lazy\" width=\"2000\" height=\"1278\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/image-1.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png 2040w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Ein Beispiel für Degeneration tritt auf, wenn das Modell mit normaler Markdown-Generierung beginnt, aber plötzlich in „monotonen Schleifen\" stecken bleibt, wie durch die roten Pfeile angezeigt.</span></figcaption></figure><p>Um dieses Problem zu lösen:</p><ul><li>Wir verwendeten <a href=\"https://github.com/yxuansu/SimCTG?ref=jina-ai-gmbh.ghost.io\">Contrastive Search</a> als Decodierungsmethode und integrierten kontrastive Verluste während des Trainings. Unseren Experimenten zufolge reduzierte diese Methode repetitive Generierung in der Praxis effektiv.</li><li>Wir implementierten ein einfaches Wiederholungs-Stopp-Kriterium innerhalb der Transformer-Pipeline. Dieses Kriterium erkennt automatisch, wenn das Modell beginnt, Token zu wiederholen, und stoppt die Decodierung frühzeitig, um monotone Schleifen zu vermeiden. Diese Idee wurde von dieser <a href=\"https://github.com/huggingface/transformers/issues/32902?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\">Diskussion</a> inspiriert.</li></ul><h3 id=\"training-efficiency-on-long-inputs\">Trainingseffizienz bei langen Eingaben</h3><p>Um das Risiko von Out-of-Memory (OOM)-Fehlern bei der Verarbeitung langer Eingaben zu minimieren, implementierten wir eine chunk-weise Modellweiterleitung. Dieser Ansatz kodiert die lange Eingabe mit kleineren Chunks und reduziert so den VRAM-Verbrauch.</p><p>Wir verbesserten die Datenpackungs-Implementierung in unserem Trainingsframework, das auf dem Transformers Trainer basiert. Zur Optimierung der Trainingseffizienz werden mehrere kurze Texte (z.B. 2K Token) zu einer einzigen langen Sequenz (z.B. 30K Token) zusammengefügt, was ein padding-freies Training ermöglicht. In der ursprünglichen Implementierung wurden jedoch einige kurze Beispiele in zwei Subtexte aufgeteilt und in verschiedene lange Trainingssequenzen aufgenommen. In solchen Fällen würde der zweite Subtext seinen Kontext verlieren (z.B. den rohen HTML-Inhalt in unserem Fall), was zu korrupten Trainingsdaten führt. Dies zwingt das Modell, sich eher auf seine Parameter als auf den Eingabekontext zu verlassen, was unserer Meinung nach eine Hauptquelle für Halluzinationen ist.</p><p>Letztendlich wählten wir die 0,5B- und 1,5B-Modelle zur Veröffentlichung aus. <strong>Das 0,5B-Modell ist das kleinste Modell, das das gewünschte „selektive Kopierverhalten\" bei Eingaben mit langem Kontext erreichen kann</strong>, während das 1,5B-Modell das kleinste größere Modell ist, das die Leistung deutlich verbessert, ohne in Bezug auf die Parametergröße abnehmende Erträge zu erzielen.</p><h3 id=\"alternative-architecture-encoder-only-model\">Alternative Architektur: Encoder-Only-Modell</h3><p>In der Anfangsphase dieses Projekts erforschten wir auch die Verwendung einer Encoder-Only-Architektur für diese Aufgabe. Wie bereits erwähnt, scheint die HTML-zu-Markdown-Konvertierung hauptsächlich eine „selektive Kopieraufgabe\" zu sein. Bei einem Trainingspaar (rohes HTML und Markdown) können wir Token, die sowohl in der Eingabe als auch in der Ausgabe existieren, als <code>1</code> markieren und den Rest als <code>0</code>. Dies wandelt das Problem in eine Token-Klassifizierungsaufgabe um, ähnlich wie bei der Named Entity Recognition (NER).</p><p>Während dieser Ansatz logisch erschien, stellte er in der Praxis erhebliche Herausforderungen dar. Erstens ist rohes HTML aus realen Quellen extrem verrauscht und lang, was die <code>1</code>-Labels extrem spärlich und damit schwer für das Modell erlernbar macht. Zweitens erwies sich die Kodierung spezieller Markdown-Syntax in einem <code>0-1</code>-Schema als problematisch, da Symbole wie <code>## title</code>, <code>*bold*</code> und <code>| table |</code> nicht im rohen HTML-Input existieren. Drittens folgen die Ausgabe-Token nicht immer strikt der Reihenfolge der Eingabe. Kleinere Umordnungen treten häufig auf, besonders bei Tabellen und Links, was es schwierig macht, solche Umordnungsverhalten in einem einfachen <code>0-1</code>-Schema darzustellen. Kurzstrecken-Umordnungen könnten potenziell mit dynamischer Programmierung oder Alignment-Warping-Algorithmen behandelt werden, indem Labels wie <code>-1, -2, +1, +2</code> eingeführt werden, um Distanz-Offsets darzustellen, wodurch das binäre Klassifizierungsproblem in eine Token-Klassifizierungsaufgabe mit mehreren Klassen umgewandelt wird.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png\" class=\"kg-image\" alt=\"Chart titled &quot;Token-Level DP Alignment (Horizontal)&quot; with tokens on the x-axis and alignment on the y-axis, highlighting best\" loading=\"lazy\" width=\"2000\" height=\"1436\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/output--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/output--2-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/output--2-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png 2179w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Verwendung von dynamischer Programmierung zur Ausrichtung des rohen HTML (X-Achse) und des Markdown (Y-Achse) für die Erstellung von Token-Level-Trainingslabels.</span></figcaption></figure><p>Zusammenfassend lässt sich sagen, dass die Lösung des Problems mit einer Encoder-Only-Architektur und die Behandlung als Token-Klassifizierungsaufgabe ihren Reiz hat, besonders da die Trainingssequenzen im Vergleich zu einem Decoder-Only-Modell viel kürzer sind, was sie VRAM-freundlicher macht. Allerdings <strong>liegt die größte Herausforderung in der Vorbereitung guter Trainingsdaten.</strong> Als wir erkannten, dass der Zeit- und Arbeitsaufwand für die Vorverarbeitung der Daten – mit dynamischer Programmierung und Heuristiken zur Erstellung perfekter Token-Level-Markierungssequenzen – überwältigend war, beschlossen wir, diesen Ansatz einzustellen.</p><h2 id=\"conclusion\">Fazit</h2><p>Reader-LM ist ein neuartiges kleines Sprachmodell (SLM), das für die Datenextraktion und -bereinigung im offenen Web entwickelt wurde. Inspiriert von Jina Reader war unser Ziel, eine End-to-End-Sprachmodelllösung zu schaffen, die rohes, verrauschtes HTML in sauberes Markdown umwandeln kann. Gleichzeitig haben wir uns auf Kosteneffizienz konzentriert und die Modellgröße klein gehalten, um sicherzustellen, dass Reader-LM praktisch und nutzbar bleibt. <strong>Es ist auch das erste Decoder-only Long-Context-Modell, das bei Jina AI trainiert wurde.</strong></p><p>Obwohl die Aufgabe zunächst als einfaches \"selektives Kopieren\" erscheinen mag, ist die Umwandlung und Bereinigung von HTML zu Markdown alles andere als einfach. Konkret muss das Modell bei positions- und kontextbasiertem Reasoning hervorragend sein, was eine größere Parameteranzahl erfordert, insbesondere in den Hidden Layers. Im Vergleich dazu ist das Erlernen der Markdown-Syntax relativ unkompliziert.</p><p>Während unserer Experimente stellten wir auch fest, dass das Training eines SLM von Grund auf besonders herausfordernd ist. Der Start mit einem vortrainierten Modell und die Fortsetzung mit aufgabenspezifischem Training verbesserte die Trainingseffizienz erheblich. Es gibt noch viel Raum für Verbesserungen sowohl bei der Effizienz als auch bei der Qualität: Erweiterung der Kontextlänge, Beschleunigung der Dekodierung und Hinzufügen von Unterstützung für Anweisungen in der Eingabe, was es Reader-LM ermöglichen würde, bestimmte Teile einer Webseite in Markdown zu extrahieren.</p>",
  "comment_id": "66dff7eba241f5000155d851",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/09/reader-lm-banner.jpg",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-09-10T09:40:27.000+02:00",
  "updated_at": "2024-09-20T14:09:30.000+02:00",
  "published_at": "2024-09-11T12:25:03.000+02:00",
  "custom_excerpt": "Reader-LM-0.5B and Reader-LM-1.5B are two novel small language models inspired by Jina Reader, designed to convert raw, noisy HTML from the open web into clean markdown.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "62e3d0ef9cd5ce003d5e49e2",
      "name": "Jina AI",
      "slug": "company",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
      "cover_image": null,
      "bio": "Creator of neural search, contributor to open source.",
      "website": "https://www.jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@JinaAI_",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/company/"
    }
  ],
  "tags": [
    {
      "id": "655b2782bb728c000101bed7",
      "name": "Press",
      "slug": "press",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
    }
  ],
  "primary_author": {
    "id": "62e3d0ef9cd5ce003d5e49e2",
    "name": "Jina AI",
    "slug": "company",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
    "cover_image": null,
    "bio": "Creator of neural search, contributor to open source.",
    "website": "https://www.jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@JinaAI_",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/company/"
  },
  "primary_tag": {
    "id": "655b2782bb728c000101bed7",
    "name": "Press",
    "slug": "press",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown/",
  "excerpt": "Reader-LM-0.5B und Reader-LM-1.5B sind zwei neue, kleine Language Models, die von Jina Reader inspiriert wurden und dafür entwickelt wurden, rohen, unstrukturierten HTML-Code aus dem offenen Web in sauberes Markdown umzuwandeln.",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Technical screenshot displaying \"REAPER-LM-0.5B/1.5B\" with HTML source code for Jina's search grounding feature.",
  "feature_image_caption": null
}