{
  "slug": "reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown",
  "id": "66dff7eba241f5000155d851",
  "uuid": "49dc11d4-e792-49d6-b778-512add9024bc",
  "title": "Reader-LM: Modelos de lenguaje pequeños para limpiar y convertir HTML a Markdown",
  "html": "<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-0.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-0.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Estamos en un viaje para avanzar y democratizar la inteligencia artificial a través del código abierto y la ciencia abierta.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-0.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-1.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-1.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Estamos en un viaje para avanzar y democratizar la inteligencia artificial a través del código abierto y la ciencia abierta.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-1.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>En abril de 2024, lanzamos <a href=\"https://jina.ai/reader?ref=jina-ai-gmbh.ghost.io\">Jina Reader</a>, una API simple que convierte cualquier URL en markdown compatible con LLM con solo un prefijo simple: <code>r.jina.ai</code>. A pesar de la sofisticada programación de red detrás de escena, la parte central de \"lectura\" es bastante directa. Primero, usamos un navegador Chrome sin interfaz para obtener el código fuente de la página web. Luego, aprovechamos el paquete <a href=\"https://github.com/mozilla/readability?ref=jina-ai-gmbh.ghost.io\">Readability</a> de Mozilla para extraer el contenido principal, eliminando elementos como encabezados, pies de página, barras de navegación y barras laterales. Finalmente, convertimos el HTML limpio a markdown usando <a href=\"https://x.com/JinaAI_/status/1823756993108304135?ref=jina-ai-gmbh.ghost.io\">regex</a> y la <a href=\"https://github.com/mixmark-io/turndown?ref=jina-ai-gmbh.ghost.io\">biblioteca Turndown</a>. El resultado es un archivo markdown bien estructurado, listo para ser utilizado por LLMs para fundamentación, resumen y razonamiento.</p><p>En las primeras semanas después del lanzamiento de Jina Reader, recibimos muchos comentarios, particularmente sobre la calidad del contenido. Algunos usuarios lo encontraron demasiado detallado, mientras que otros sintieron que no era lo suficientemente detallado. También hubo reportes de que el filtro Readability eliminaba el contenido equivocado o que Turndown tenía dificultades para convertir ciertas partes del HTML a markdown. Afortunadamente, muchos de estos problemas se resolvieron exitosamente mediante parches en el pipeline existente con nuevos patrones regex o heurísticas.</p><p>Desde entonces, hemos estado reflexionando sobre una pregunta: en lugar de parchearlo con más heurísticas y regex (que se vuelve cada vez más difícil de mantener y no es amigable con múltiples idiomas), ¿podemos resolver este problema de <em>extremo a extremo</em> con un modelo de lenguaje?</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png\" class=\"kg-image\" alt=\"Diagrama de flujo que ilustra la conversión de HTML crudo a formato Markdown usando las bibliotecas readability y turndown, más regex/heu\" loading=\"lazy\" width=\"1800\" height=\"945\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/Heading--48-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/Heading--48-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/Heading--48-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png 1800w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Ilustración de </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>reader-lm</span></code><span style=\"white-space: pre-wrap;\">, reemplazando el pipeline de readability+turndown+regex heurísticos usando un modelo de lenguaje pequeño.</span></figcaption></figure><p>A primera vista, usar LLMs para la limpieza de datos podría parecer excesivo debido a su baja eficiencia en costos y velocidades más lentas. Pero ¿qué tal si consideramos un <strong>modelo de lenguaje pequeño (SLM)</strong> — uno con menos de 1 mil millones de parámetros que puede ejecutarse eficientemente en el borde? Eso suena mucho más atractivo, ¿verdad? Pero ¿es esto realmente factible o solo un pensamiento ilusorio? Según la ley de escalamiento, menos parámetros generalmente conducen a capacidades reducidas de razonamiento y resumen. Entonces un SLM podría incluso tener dificultades para generar contenido significativo si su tamaño de parámetros es demasiado pequeño. Para explorar esto más a fondo, echemos un vistazo más cercano a la tarea de HTML a Markdown:</p><ul><li>Primero, la tarea que estamos considerando <strong>no es tan creativa o compleja como las tareas típicas de LLM</strong>. En el caso de convertir HTML a markdown, el modelo principalmente necesita <strong>copiar selectivamente</strong> de la entrada a la salida (es decir, saltarse el marcado HTML, barras laterales, encabezados, pies de página), con un esfuerzo mínimo dedicado a generar nuevo contenido (principalmente insertando sintaxis markdown). Esto contrasta fuertemente con las tareas más amplias que manejan los LLMs, como generar poemas o escribir código, donde la salida involucra mucha más creatividad y no es una copia directa de la entrada. Esta observación sugiere que un SLM podría funcionar, ya que la tarea <em>parece</em> más simple que la generación de texto más general.</li><li>Segundo, necesitamos <strong>priorizar el soporte de contexto largo</strong>. El HTML moderno a menudo contiene mucho más ruido que el simple marcado <code>&lt;div&gt;</code>. El CSS en línea y los scripts pueden fácilmente inflar el código a cientos de miles de tokens. Para que un SLM sea práctico en este escenario, la longitud del contexto debe ser suficientemente grande. Una longitud de token de 8K o 16K <em>no es</em> útil en absoluto.</li></ul><p>Parece que lo que necesitamos es un SLM <strong><em>superficial pero ancho</em></strong>. \"Superficial\" en el sentido de que la tarea es principalmente \"copiar y pegar\" simple, por lo tanto se necesitan menos bloques de transformador; y \"ancho\" en el sentido de que requiere soporte de contexto largo para ser práctico, por lo que el mecanismo de atención necesita cierto cuidado. Investigaciones previas han demostrado que la longitud del contexto y la capacidad de razonamiento están estrechamente entrelazadas. Para un SLM, es extremadamente desafiante optimizar ambas dimensiones mientras se mantiene pequeño el tamaño del parámetro.</p><p>Hoy, nos complace anunciar la primera versión de esta solución con el lanzamiento de <code>reader-lm-0.5b</code> y <code>reader-lm-1.5b</code>, dos SLMs específicamente entrenados <strong>para generar markdown limpio directamente desde HTML crudo ruidoso</strong>. Ambos modelos son multilingües y soportan una longitud de contexto de hasta <strong>256K tokens</strong>. A pesar de su tamaño compacto, estos modelos logran un rendimiento estado del arte en esta tarea, superando a contrapartes LLM más grandes mientras son solo 1/50 de su tamaño.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Reader-LM-vs-LLMs-on-the-HTML2Markdown-task--1-.svg\" class=\"kg-image\" alt=\"Gráfico de barras que muestra el rendimiento superior de Reader-LM en la tarea HTML2Markdown con la puntuación más alta de 0.72 contra varios LLMs.\" loading=\"lazy\" width=\"805\" height=\"514\"></figure><p>A continuación se muestran las especificaciones de los dos modelos:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">reader-lm-0.5b</th>\n<th style=\"text-align:center\">reader-lm-1.5b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td># Parámetros</td>\n<td style=\"text-align:center\">494M</td>\n<td style=\"text-align:center\">1.54B</td>\n</tr>\n<tr>\n<td>Longitud de contexto</td>\n<td style=\"text-align:center\">256K</td>\n<td style=\"text-align:center\">256K</td>\n</tr>\n<tr>\n<td>Tamaño oculto</td>\n<td style=\"text-align:center\">896</td>\n<td style=\"text-align:center\">1536</td>\n</tr>\n<tr>\n<td># Capas</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n<tr>\n<td># Cabezas de consulta</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td># Cabezas KV</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td>Tamaño de cabeza</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">128</td>\n</tr>\n<tr>\n<td>Tamaño intermedio</td>\n<td style=\"text-align:center\">4864</td>\n<td style=\"text-align:center\">8960</td>\n</tr>\n<tr>\n<td>Multilingüe</td>\n<td style=\"text-align:center\">Sí</td>\n<td style=\"text-align:center\">Sí</td>\n</tr>\n<tr>\n<td>Repositorio HuggingFace</td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-0.5b/?ref=jina-ai-gmbh.ghost.io\">Enlace</a></td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-1.5b/?ref=jina-ai-gmbh.ghost.io\">Enlace</a></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"get-started-with-reader-lm\">Empezar con Reader-LM</h2><h3 id=\"on-google-colab\">En Google Colab</h3><p>La manera más fácil de experimentar con <code>reader-lm</code> es ejecutando nuestro notebook de Colab, donde demostramos cómo usar <code>reader-lm-1.5b</code> para convertir el sitio web de Hacker News a markdown. El notebook está optimizado para ejecutarse sin problemas en el nivel gratuito de GPU T4 de Google Colab. También puedes cargar <code>reader-lm-0.5b</code> o cambiar la URL a cualquier sitio web y explorar la salida. Ten en cuenta que la entrada (es decir, el prompt) al modelo es el HTML crudo—no se requiere instrucción de prefijo.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/1wXWyj5hOxEHY6WeHbOwEzYAC0WB1I5uA?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/colab_favicon_256px.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Tenga en cuenta que la GPU T4 de nivel gratuito tiene limitaciones que podrían impedir el uso de optimizaciones avanzadas durante la ejecución del modelo. Funciones como bfloat16 y flash attention no están disponibles en la T4, lo que podría resultar en un mayor uso de VRAM y un rendimiento más lento para entradas más largas. <strong>Para entornos de producción, recomendamos usar una GPU de gama alta como la RTX 3090/4090 para obtener un rendimiento significativamente mejor.</strong></p><h3 id=\"in-production-available-on-azure-aws-soon\">En Producción: Próximamente Disponible en Azure y AWS</h3><p>Reader-LM está disponible en Azure Marketplace y AWS SageMaker. Si necesita usar estos modelos más allá de estas plataformas o en las instalaciones de su empresa, tenga en cuenta que ambos modelos están licenciados bajo CC BY-NC 4.0. <a href=\"https://jina.ai/contact-sales/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Para consultas sobre uso comercial, no dude en contactarnos.</a></p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-nli7b6dueo424?sr=0-1&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 0.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-ms27ixcwq3wjk?sr=0-2&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 1.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-500m?tab=Overview&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-1500m?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><h2 id=\"benchmark\">Comparativa</h2><p>Para evaluar cuantitativamente el rendimiento de Reader-LM, lo comparamos con varios modelos de lenguaje grandes, incluyendo: GPT-4o, Gemini-1.5-Flash, Gemini-1.5-Pro, LLaMA-3.1-70B, Qwen2-7B-Instruct.</p><p>Los modelos fueron evaluados usando las siguientes métricas:</p><ul><li><strong>ROUGE-L (mayor es mejor)</strong>: Esta métrica, ampliamente utilizada para tareas de resumen y respuesta a preguntas, mide la superposición entre la salida predicha y la referencia a nivel de n-gramas.</li><li><strong>Tasa de Error de Tokens (TER, menor es mejor)</strong>: Esta métrica calcula la tasa a la que los tokens markdown generados no aparecen en el contenido HTML original. Diseñamos esta métrica para evaluar la tasa de alucinación del modelo, ayudándonos a identificar casos donde el modelo produce contenido que no está fundamentado en el HTML. Se realizarán mejoras adicionales basadas en estudios de casos.</li><li><strong>Tasa de Error de Palabras (WER, menor es mejor)</strong>: Comúnmente usada en tareas de OCR y ASR, WER considera la secuencia de palabras y calcula errores como inserciones (ADD), sustituciones (SUB) y eliminaciones (DEL). Esta métrica proporciona una evaluación detallada de los desajustes entre el markdown generado y la salida esperada.</li></ul><p>Para aprovechar los LLMs para esta tarea, usamos la siguiente instrucción uniforme como prompt inicial:</p><pre><code>Your task is to convert the content of the provided HTML file into the corresponding markdown file. You need to convert the structure, elements, and attributes of the HTML into equivalent representations in markdown format, ensuring that no important information is lost. The output should strictly be in markdown format, without any additional explanations.</code></pre><p>Los resultados se pueden encontrar en la tabla siguiente.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ROUGE-L</th>\n<th>WER</th>\n<th>TER</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reader-lm-0.5b</td>\n<td>0.56</td>\n<td>3.28</td>\n<td>0.34</td>\n</tr>\n<tr>\n<td>reader-lm-1.5b</td>\n<td><strong>0.72</strong></td>\n<td><strong>1.87</strong></td>\n<td><strong>0.19</strong></td>\n</tr>\n<tr>\n<td>gpt-4o</td>\n<td>0.43</td>\n<td>5.88</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>gemini-1.5-flash</td>\n<td>0.40</td>\n<td>21.70</td>\n<td>0.55</td>\n</tr>\n<tr>\n<td>gemini-1.5-pro</td>\n<td>0.42</td>\n<td>3.16</td>\n<td>0.48</td>\n</tr>\n<tr>\n<td>llama-3.1-70b</td>\n<td>0.40</td>\n<td>9.87</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>Qwen2-7B-Instruct</td>\n<td>0.23</td>\n<td>2.45</td>\n<td>0.70</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"qualitative-study\">Estudio Cualitativo</h2><p>Realizamos un estudio cualitativo inspeccionando visualmente el markdown de salida. <a href=\"https://docs.google.com/spreadsheets/d/1Wb2sMdiEoToPaXohcrEznFKStt_4alVOnJD3WKkiM7o/edit?gid=1576339853&ref=jina-ai-gmbh.ghost.io#gid=1576339853\">Seleccionamos 22 fuentes HTML</a> incluyendo artículos de noticias, posts de blog, páginas de aterrizaje, páginas de comercio electrónico y posts de foros en múltiples idiomas: inglés, alemán, japonés y chino. También incluimos la API Jina Reader como referencia, que se basa en regex, heurísticas y reglas predefinidas.</p><p>La evaluación se centró en cuatro dimensiones clave de la salida, con cada modelo calificado en una escala del 1 (más bajo) al 5 (más alto):</p><ol><li><strong>Extracción de Encabezados</strong>: Evaluó qué tan bien cada modelo identificó y formateó los encabezados h1,h2,..., h6 del documento usando la sintaxis correcta de markdown.</li><li><strong>Extracción de Contenido Principal</strong>: Evaluó la capacidad de los modelos para convertir con precisión el texto del cuerpo, preservando párrafos, formateando listas y manteniendo la consistencia en la presentación.</li><li><strong>Preservación de Estructura Rica</strong>: Analizó qué tan efectivamente cada modelo mantuvo la estructura general del documento, incluyendo encabezados, subencabezados, viñetas y listas ordenadas.</li><li><strong>Uso de Sintaxis Markdown</strong>: Evaluó la capacidad de cada modelo para convertir correctamente elementos HTML como <code>&lt;a&gt;</code> (enlaces), <code>&lt;strong&gt;</code> (texto en negrita) y <code>&lt;em&gt;</code> (cursivas) a sus equivalentes apropiados en markdown.</li></ol><p>Los resultados se pueden encontrar a continuación.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Qualitative-Evaluation-of-Reader-LM-vs-LLMs-and-Jina-Reader-API--1-.svg\" class=\"kg-image\" alt=\"Gráfico de barras comparando Reader-LM, LLMs y Jina Reader API en métricas como extracción de encabezados y preservación de contenido.\" loading=\"lazy\" width=\"863\" height=\"533\"></figure><p>Reader-LM-1.5B tiene un rendimiento consistentemente bueno en todas las dimensiones, destacando particularmente en preservación de estructura y uso de sintaxis markdown. Si bien no siempre supera a Jina Reader API, su rendimiento es competitivo con modelos más grandes como Gemini 1.5 Pro, lo que lo convierte en una alternativa altamente eficiente a los LLM más grandes. Reader-LM-0.5B, aunque más pequeño, aún ofrece un rendimiento sólido, particularmente en preservación de estructura.</p><h2 id=\"how-we-trained-reader-lm\">Cómo Entrenamos Reader-LM</h2><h3 id=\"data-preparation\">Preparación de Datos</h3><p>Usamos la API Jina Reader para generar pares de entrenamiento de HTML sin procesar y su markdown correspondiente. Durante el experimento, encontramos que los SLM son particularmente sensibles a la calidad de los datos de entrenamiento. Así que construimos un pipeline de datos que asegura que solo se incluyan entradas markdown de alta calidad en el conjunto de entrenamiento.</p><p>Adicionalmente, agregamos algunos HTML sintéticos y sus contrapartes markdown, generados por <code>GPT-4o</code>. En comparación con el HTML del mundo real, los datos sintéticos tienden a ser mucho más cortos, con estructuras más simples y predecibles, y un nivel de ruido significativamente menor.</p><p>Finalmente, concatenamos el HTML y markdown usando una plantilla de chat. Los datos de entrenamiento finales están formateados de la siguiente manera:</p><pre><code>&lt;|im_start|&gt;system\nYou are a helpful assistant.&lt;|im_end|&gt;\n&lt;|im_start|&gt;user\n{{RAW_HTML}}&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n{{MARKDOWN}}&lt;|im_end|&gt;\n</code></pre><p>Los datos de entrenamiento completos suman 2.5 mil millones de tokens.</p><h3 id=\"two-stage-training\">Entrenamiento en Dos Etapas</h3><p>Experimentamos con varios tamaños de modelos, desde 65M y 135M hasta 3B parámetros. Las especificaciones para cada modelo se pueden encontrar en la tabla siguiente.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>reader-lm-65m</th>\n<th>reader-lm-135m</th>\n<th>reader-lm-360m</th>\n<th>reader-lm-0.5b</th>\n<th>reader-lm-1.5b</th>\n<th>reader-lm-1.7b</th>\n<th>reader-lm-3b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hidden Size</td>\n<td>512</td>\n<td>576</td>\n<td>960</td>\n<td>896</td>\n<td>1536</td>\n<td>2048</td>\n<td>3072</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td>8</td>\n<td>30</td>\n<td>32</td>\n<td>24</td>\n<td>28</td>\n<td>24</td>\n<td>32</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td>16</td>\n<td>9</td>\n<td>15</td>\n<td>14</td>\n<td>12</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td>8</td>\n<td>3</td>\n<td>5</td>\n<td>2</td>\n<td>2</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n<td>128</td>\n<td>64</td>\n<td>96</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td>2048</td>\n<td>1536</td>\n<td>2560</td>\n<td>4864</td>\n<td>8960</td>\n<td>8192</td>\n<td>8192</td>\n</tr>\n<tr>\n<td>Attention Bias</td>\n<td>False</td>\n<td>False</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Embedding Tying</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Vocabulary Size</td>\n<td>32768</td>\n<td>49152</td>\n<td>49152</td>\n<td>151646</td>\n<td>151646</td>\n<td>49152</td>\n<td>32064</td>\n</tr>\n<tr>\n<td>Base Model</td>\n<td>Lite-Oute-1-65M-Instruct</td>\n<td>SmolLM-135M</td>\n<td>SmolLM-360M-Instruct</td>\n<td>Qwen2-0.5B-Instruct</td>\n<td>Qwen2-1.5B-Instruct</td>\n<td>SmolLM-1.7B</td>\n<td>Phi-3-mini-128k-instruct</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>El entrenamiento del modelo se realizó en dos etapas:</p><ol><li><strong>HTML corto y simple: </strong>En esta etapa, la longitud máxima de secuencia (HTML + markdown) se estableció en 32K tokens, con un total de 1.5 mil millones de tokens de entrenamiento.</li><li><strong>HTML largo y complejo</strong>: la longitud de secuencia se extendió a 128K tokens, con 1.2 mil millones de tokens de entrenamiento. Implementamos el mecanismo zigzag-ring-attention de <a href=\"https://github.com/zhuzilin/ring-flash-attention?ref=jina-ai-gmbh.ghost.io\">Ring Flash Attention de Zilin Zhu (2024)</a> para esta etapa.</li></ol><p>Dado que los datos de entrenamiento incluían secuencias de hasta 128K tokens, creemos que el modelo puede soportar hasta 256K tokens sin problemas. Sin embargo, manejar 512K tokens puede ser desafiante, ya que extender los embeddings posicionales RoPE a cuatro veces la longitud de la secuencia de entrenamiento podría resultar en una degradación del rendimiento.</p><p>Para los modelos de 65M y 135M parámetros, observamos que podían lograr un comportamiento razonable de \"copia\", pero solo con secuencias cortas (menos de 1K tokens). A medida que aumentaba la longitud de entrada, estos modelos tenían dificultades para producir cualquier salida razonable. Dado que el código fuente HTML moderno puede exceder fácilmente los 100K tokens, un límite de 1K tokens está lejos de ser suficiente.</p><h3 id=\"degeneration-and-dull-loops\">Degeneración y Bucles Monótonos</h3><p>Uno de los principales desafíos que encontramos fue la degeneración, particularmente en forma de repetición y bucles. Después de generar algunos tokens, el modelo comenzaba a generar el mismo token repetidamente o se quedaba atascado en un bucle, repitiendo continuamente una secuencia corta de tokens hasta alcanzar la longitud máxima permitida de salida.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png\" class=\"kg-image\" alt=\"Dark themed coding script with repeated structural programming comments about data types, functions, and mathematical operati\" loading=\"lazy\" width=\"2000\" height=\"1278\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/image-1.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png 2040w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Un ejemplo de degeneración ocurre cuando el modelo comienza con generación normal de markdown pero de repente se queda atascado en \"bucles monótonos\", como indican las flechas rojas.</span></figcaption></figure><p>Para abordar este problema:</p><ul><li>Aplicamos la <a href=\"https://github.com/yxuansu/SimCTG?ref=jina-ai-gmbh.ghost.io\">búsqueda contrastiva</a> como método de decodificación e incorporamos pérdida contrastiva durante el entrenamiento. Según nuestros experimentos, este método redujo efectivamente la generación repetitiva en la práctica.</li><li>Implementamos un criterio simple de detención de repetición dentro del pipeline del transformer. Este criterio detecta automáticamente cuando el modelo comienza a repetir tokens y detiene la decodificación temprano para evitar bucles monótonos. Esta idea se inspiró en esta <a href=\"https://github.com/huggingface/transformers/issues/32902?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\">discusión</a>.</li></ul><h3 id=\"training-efficiency-on-long-inputs\">Eficiencia de Entrenamiento en Entradas Largas</h3><p>Para mitigar el riesgo de errores de memoria insuficiente (OOM) al manejar entradas largas, implementamos el reenvío del modelo por fragmentos. Este enfoque codifica la entrada larga con fragmentos más pequeños, reduciendo el uso de VRAM.</p><p>Mejoramos la implementación del empaquetado de datos en nuestro marco de entrenamiento, que se basa en el Transformers Trainer. Para optimizar la eficiencia del entrenamiento, múltiples textos cortos (por ejemplo, 2K tokens) se concatenan en una única secuencia larga (por ejemplo, 30K tokens), permitiendo el entrenamiento sin relleno. Sin embargo, en la implementación original, algunos ejemplos cortos se dividían en dos subtextos y se incluían en diferentes secuencias de entrenamiento largas. En tales casos, el segundo subtexto perdería su contexto (por ejemplo, el contenido HTML sin procesar en nuestro caso), lo que llevaría a datos de entrenamiento corruptos. Esto obliga al modelo a depender de sus parámetros en lugar del contexto de entrada, lo que creemos que es una fuente importante de alucinación.</p><p>Al final, seleccionamos los modelos de 0.5B y 1.5B para su publicación. <strong>El modelo de 0.5B es el más pequeño capaz de lograr el comportamiento deseado de \"copia selectiva\" en entradas de contexto largo</strong>, mientras que el modelo de 1.5B es el modelo más grande más pequeño que mejora significativamente el rendimiento sin alcanzar rendimientos decrecientes en relación con el tamaño de los parámetros.</p><h3 id=\"alternative-architecture-encoder-only-model\">Arquitectura Alternativa: Modelo Solo-Codificador</h3><p>En los primeros días de este proyecto, también exploramos el uso de una arquitectura solo-codificador para abordar esta tarea. Como se mencionó anteriormente, la tarea de conversión de HTML a Markdown parece ser principalmente una tarea de \"copia selectiva\". Dado un par de entrenamiento (HTML sin procesar y markdown), podemos etiquetar los tokens que existen tanto en la entrada como en la salida como <code>1</code>, y el resto como <code>0</code>. Esto convierte el problema en una tarea de clasificación de tokens, similar a lo que se usa en el Reconocimiento de Entidades Nombradas (NER).</p><p>Si bien este enfoque parecía lógico, presentó desafíos significativos en la práctica. Primero, el HTML sin procesar de fuentes del mundo real es extremadamente ruidoso y largo, haciendo que las etiquetas <code>1</code> sean extremadamente escasas y por lo tanto difíciles de aprender para el modelo. Segundo, codificar sintaxis especial de markdown en un esquema <code>0-1</code> resultó problemático, ya que símbolos como <code>## title</code>, <code>*bold*</code>, y <code>| table |</code> no existen en la entrada HTML sin procesar. Tercero, los tokens de salida no siempre siguen estrictamente el orden de la entrada. A menudo ocurren reordenamientos menores, particularmente con tablas y enlaces, lo que hace difícil representar tales comportamientos de reordenamiento en un esquema simple <code>0-1</code>. El reordenamiento de corta distancia podría potencialmente manejarse con programación dinámica o algoritmos de alineamiento-deformación introduciendo etiquetas como <code>-1, -2, +1, +2</code> para representar desplazamientos de distancia, transformando el problema de clasificación binaria en una tarea de clasificación de tokens multiclase.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png\" class=\"kg-image\" alt=\"Chart titled &quot;Token-Level DP Alignment (Horizontal)&quot; with tokens on the x-axis and alignment on the y-axis, highlighting best\" loading=\"lazy\" width=\"2000\" height=\"1436\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/output--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/output--2-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/output--2-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png 2179w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Uso de programación dinámica para alinear el HTML sin procesar (eje X) y el markdown (eje Y) para crear etiquetas de entrenamiento a nivel de token.</span></figcaption></figure><p>En resumen, resolver el problema con una arquitectura solo-codificador y tratarlo como una tarea de clasificación de tokens tiene su encanto, especialmente porque las secuencias de entrenamiento son mucho más cortas en comparación con un modelo solo-decodificador, haciéndolo más amigable con la VRAM. Sin embargo, <strong>el principal desafío radica en preparar buenos datos de entrenamiento.</strong> Cuando nos dimos cuenta de que el tiempo y esfuerzo dedicados al preprocesamiento de los datos—usando programación dinámica y heurísticas para crear secuencias perfectas de etiquetado a nivel de token—era abrumador, decidimos descontinuar este enfoque.</p><h2 id=\"conclusion\">Conclusión</h2><p>Reader-LM es un novedoso modelo de lenguaje pequeño (SLM) diseñado para la extracción y limpieza de datos en la web abierta. Inspirado en Jina Reader, nuestro objetivo era crear una solución de modelo de lenguaje de extremo a extremo capaz de convertir HTML en bruto y ruidoso a markdown limpio. Al mismo tiempo, nos centramos en la eficiencia de costos, manteniendo el tamaño del modelo pequeño para asegurar que Reader-LM siga siendo práctico y utilizable. <strong>También es el primer modelo decodificador de contexto largo entrenado en Jina AI.</strong></p><p>Aunque inicialmente la tarea pueda parecer un simple problema de \"copia selectiva\", convertir y limpiar HTML a markdown está lejos de ser fácil. Específicamente, requiere que el modelo sobresalga en el razonamiento basado en contexto y consciente de la posición, lo que exige un tamaño de parámetros mayor, particularmente en las capas ocultas. En comparación, aprender la sintaxis de markdown es relativamente sencillo.</p><p>Durante nuestros experimentos, también descubrimos que entrenar un SLM desde cero es particularmente desafiante. Comenzar con un modelo preentrenado y continuar con el entrenamiento específico de la tarea mejoró significativamente la eficiencia del entrenamiento. Todavía hay mucho margen de mejora en términos de eficiencia y calidad: expandir la longitud del contexto, acelerar la decodificación y agregar soporte para instrucciones en la entrada, lo que permitiría a Reader-LM extraer partes específicas de una página web en markdown.</p>",
  "comment_id": "66dff7eba241f5000155d851",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/09/reader-lm-banner.jpg",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-09-10T09:40:27.000+02:00",
  "updated_at": "2024-09-20T14:09:30.000+02:00",
  "published_at": "2024-09-11T12:25:03.000+02:00",
  "custom_excerpt": "Reader-LM-0.5B and Reader-LM-1.5B are two novel small language models inspired by Jina Reader, designed to convert raw, noisy HTML from the open web into clean markdown.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "62e3d0ef9cd5ce003d5e49e2",
      "name": "Jina AI",
      "slug": "company",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
      "cover_image": null,
      "bio": "Creator of neural search, contributor to open source.",
      "website": "https://www.jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@JinaAI_",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/company/"
    }
  ],
  "tags": [
    {
      "id": "655b2782bb728c000101bed7",
      "name": "Press",
      "slug": "press",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
    }
  ],
  "primary_author": {
    "id": "62e3d0ef9cd5ce003d5e49e2",
    "name": "Jina AI",
    "slug": "company",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
    "cover_image": null,
    "bio": "Creator of neural search, contributor to open source.",
    "website": "https://www.jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@JinaAI_",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/company/"
  },
  "primary_tag": {
    "id": "655b2782bb728c000101bed7",
    "name": "Press",
    "slug": "press",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown/",
  "excerpt": "Reader-LM-0.5B y Reader-LM-1.5B son dos nuevos modelos de lenguaje pequeños inspirados en Jina Reader, diseñados para convertir HTML sin procesar y con ruido de la web abierta en markdown limpio.",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Technical screenshot displaying \"REAPER-LM-0.5B/1.5B\" with HTML source code for Jina's search grounding feature.",
  "feature_image_caption": null
}