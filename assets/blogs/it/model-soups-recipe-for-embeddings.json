{
  "slug": "model-soups-recipe-for-embeddings",
  "id": "681b63a077c406000104263b",
  "uuid": "e3fc45b3-6cf9-4a0b-863f-bc4a8417c436",
  "title": "La ricetta di Model Soup per gli Embeddings",
  "html": "<p>In questi tempi difficili, niente batte una bella ciotola di zuppa calda.</p><p>Il minestrone è una delle zuppe classiche italiane: densa, sostanziosa, saporita, che combina fagioli, verdure sostanziose e riso o pasta. Il suo sapore è il risultato dell'assemblaggio di diversi ingredienti. È un po' come il borscht nell'Europa orientale, le casseruole in America o un saltato in padella fatto in casa nell'Asia del Pacifico, in quanto combina ingredienti disponibili ed economici in un piatto amato.</p><p>Possiamo usare più o meno lo stesso tipo di ricetta per i modelli di rete neurale, secondo una serie di articoli a partire da <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a>.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://proceedings.mlr.press/v162/wortsman22a.html\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time</div><div class=\"kg-bookmark-description\">The conventional recipe for maximizing model accuracy is to (1) train multiple models with various hyperparameters and (2) pick the individual model which performs best on a held-out validation set…</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-pmlr.ico\" alt=\"\"><span class=\"kg-bookmark-author\">PMLR</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://proceedings.mlr.press/v162/assets/images/logo-pmlr.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Le \"model soups\" (ahimè, non \"model casseroles\" o \"model stir-fries\") sono una classe di tecniche di model ensembling progettate per mitigare il costo dell'ottimizzazione dei dati di training e degli iperparametri del modello. Quando si addestra una rete neurale, in genere si provano diversi dati e valori di iperparametri e si addestra più volte, cercando il risultato con le prestazioni migliori. L'addestramento è molto costoso dal punto di vista computazionale e i costi si sommano rapidamente.</p><p>Invece, le model soups prevedono l'addestramento di più modelli con diversi iperparametri e scelte di dati di training — lo stesso che si farebbe normalmente — ma poi li si combina. Il risultato è un modello più performante e più robusto del singolo modello con le prestazioni migliori. Non consente di risparmiare sui costi perché si addestrano comunque più modelli, ma si può ottenere un risultato migliore allo stesso prezzo.</p><p>L'approccio model soup si è già dimostrato utile per i modelli di embedding multimodale testo-immagine <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">(Wortsman et al. 2022)</a> e per i modelli generativi di grandi dimensioni del linguaggio. (<a href=\"https://doi.org/10.1038/s42256-024-00975-8\">Takuya et al. 2025</a>) In Jina AI, abbiamo iniziato a utilizzare questa tecnica per addestrare i nostri modelli e sia <code>jina-embeddings-v3</code> che <code>reader-lm-v2</code> incorporano model soups.</p><p>In questo articolo, esamineremo le model soups e mostreremo i risultati di alcuni dei nostri lavori con esse. Nello specifico:</p><ol><li>Possiamo usare le model soups per migliorare le prestazioni unendo modelli in diversi punti del loro addestramento?</li><li>Possiamo unire modelli addestrati con diversi set di dati e per diversi compiti per ottenere prestazioni migliori e una maggiore efficienza di addestramento rispetto all'addestramento di un singolo modello?</li></ol><p>Questo ha importanti potenziali vantaggi:</p><ul><li>Le model soups possono avere prestazioni migliori e più robuste.</li><li>I modelli di embedding multilingue spesso soffrono di bias e cali di prestazioni causati da quantità disuguali di dati di training. Sarebbe un vantaggio poter addestrare individualmente il modello migliore possibile per ogni compito o set di dati e poi combinarli equamente.</li><li>Potremmo essere in grado di fare un apprendimento continuo e un aggiornamento del modello migliori apportando modifiche ai nostri modelli in modo modulare, aggiornando un componente del modello alla volta e poi riunendolo con gli altri.</li></ul><h2 id=\"how-does-it-work\">Come funziona?</h2><p>Unire gli output di più modelli è una vecchia tecnica nella teoria delle decisioni statistiche. Ad esempio, è una pratica comune nelle previsioni del tempo creare più modelli, spesso realizzati da persone diverse con presupposti diversi, e quindi utilizzare una varietà di meccanismi per calcolare la media delle loro previsioni. Se gli errori di ciascun modello sono distribuiti in modo casuale, la media dei modelli porterà a risposte con meno errori.</p><p>Ad esempio, se si hanno tre diversi modelli che restituiscono un \"sì\" o un \"no\" binario e ognuno di essi è sbagliato il 10% delle volte, allora due su tre saranno sbagliati solo il 2,8% delle volte. Cinque modelli, con un criterio di decisione a maggioranza, saranno sbagliati solo lo 0,856% delle volte.</p><p>La media dei modelli funziona sullo stesso principio, ma invece di combinare gli output di modelli diversi, combina i modelli stessi.</p><p>L'approccio utilizzato è un'estensione dello <em>stochastic weight averaging</em> (<a href=\"https://auai.org/uai2018/proceedings/papers/313.pdf\">Izmailov et al. 2018</a>), che si basa su intuizioni sui paesaggi di perdita delle reti neurali per mostrare che la semplice media dei pesi può migliorare le prestazioni di generalizzazione del modello in condizioni comuni.</p><p>La meccanica effettiva della media dei modelli è incredibilmente semplice: basta fare la media dei pesi di più modelli.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/05/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"380\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/05/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/05/image.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2025/05/image.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2025/05/image.png 2400w\" sizes=\"(min-width: 1200px) 1200px\"><figcaption><span style=\"white-space: pre-wrap;\">Come vengono uniti i modelli per creare una model soup. Questo esempio è molto piccolo e semplice, ma mostra comunque la procedura: sommare i pesi e dividere per il numero di modelli da unire.</span></figcaption></figure><p>Se questo sembra troppo facile, è importante notare che ci sono dei limiti quando si uniscono i modelli in questo modo. Non si possono semplicemente unire i pesi di due reti neurali qualsiasi e aspettarsi che funzioni.</p><p>La media dei modelli funziona solo su modelli molto simili, cioè modelli i cui pesi non sono molto diversi l'uno dall'altro per cominciare. Il modo per assicurarsi che sia così è quello di pre-addestrare un modello e poi creare più varianti di quel modello mettendolo a punto con diversi iperparametri o dati diversi. Questi modelli saranno in genere abbastanza simili da poter essere mediati.</p><p>In termini più tecnici, il pre-addestramento di solito produce un modello i cui pesi sono vicini al fondo di un bacino di perdita e la messa a punto non porta facilmente a sfuggire a quel bacino di perdita. Se tutti i modelli da unire hanno pesi nello stesso bacino di perdita, allora i loro pesi saranno abbastanza vicini tra loro ed è probabile che la loro media funzioni. Questo non è garantito, ma empiricamente sembra essere vero abbastanza spesso da essere utile.</p><h2 id=\"experimental-setup\">Configurazione sperimentale</h2><p><strong>Modello di base</strong>: per gli esperimenti qui descritti, abbiamo usato <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code> di FacebookAI</a> (<a href=\"https://aclanthology.org/2020.acl-main.747/\">Conneau et al. 2020</a>) come modello di base pre-addestrato. Questo modello ha 280 milioni di parametri ed è stato pre-addestrato su 2,5 TB di dati Common Crawl contenenti testo in circa 100 lingue.</p><p>Abbiamo messo a punto <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code></a> sul nostro set di training di coppie di frasi curato per l'addestramento di embedding, prima di eseguire i nostri esperimenti.</p><p><strong>Dati di training</strong>: Jina AI mantiene set di dati curati personalizzati per l'addestramento. Per il primo esperimento, abbiamo usato terne di frasi specificamente curate per l'addestramento contrastivo in sei lingue: inglese, arabo, tedesco, spagnolo, giapponese e cinese. Per il secondo esperimento, abbiamo usato set di dati di training specifici per il compito in inglese.</p><p><strong>Valutazione</strong>: abbiamo usato parti rilevanti del <a href=\"https://github.com/embeddings-benchmark/mteb/tree/main/docs/mmteb\">set di benchmark MMTEB</a> (<a href=\"https://arxiv.org/abs/2502.13595\">Enevoldsen et al. 2025</a>) e del <a href=\"https://project-miracl.github.io/\">benchmark MIRACL</a> (<a href=\"https://direct.mit.edu/tacl/article/doi/10.1162/tacl_a_00595/117438/MIRACL-A-Multilingual-Retrieval-Dataset-Covering\">Zhang et al. 2023</a>) per valutare i modelli prodotti dal nostro addestramento e dall'unione.</p><h3 id=\"experiment-1-single-run-averaging\">Esperimento 1: media a esecuzione singola</h3><p>Per questo esperimento, abbiamo usato terne di frasi contrastive in tutte e sei le lingue, mescolate insieme, per un totale di 6.000 passaggi di addestramento con una dimensione del batch di 1.024 elementi. Ogni 2.000 passaggi, abbiamo salvato lo stato del modello per la media, producendo 3 modelli, ognuno dei quali riflette un punto diverso nel processo di addestramento.</p><p>Abbiamo fatto la media dei tre modelli per produrre un modello finale. Abbiamo quindi testato il modello unito e i tre checkpoint salvati rispetto ai set di benchmark MMTEB-STS e MIRACL.</p><p>I nostri risultati sono riassunti nella tabella seguente:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Modello</th>\n<th>MIRACL<br>(media di 6 lingue)</th>\n<th>MMTEB-STS inglese<br>(media di 8 benchmark)</th>\n<th>MMTEB-STS multilingue<br>(media di 6 benchmark)</th>\n<th>Media di 20 benchmark</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nessun training a terne</td>\n<td>0.3163</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.6276</td>\n</tr>\n<tr>\n<td>Passaggio 2000</td>\n<td>0.4631</td>\n<td><strong>0.7924</strong></td>\n<td>0.7561</td>\n<td>0.6813</td>\n</tr>\n<tr>\n<td>Passaggio 4000</td>\n<td>0.4639</td>\n<td>0.7902</td>\n<td><strong>0.7583</strong></td>\n<td>0.6812</td>\n</tr>\n<tr>\n<td>Passaggio 6000 (finale)</td>\n<td><strong>0.4680</strong></td>\n<td>0.7891</td>\n<td>0.7575</td>\n<td>0.6818</td>\n</tr>\n<tr>\n<td>Modello unito<br>(tutti e 3 i checkpoint memorizzati)</td>\n<td>0.4669</td>\n<td>0.7910</td>\n<td>0.7579</td>\n<td><strong>0.6823</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>L'unione con i checkpoint precedenti non ha in genere prodotto un modello con prestazioni migliori rispetto al modello con le prestazioni migliori tra i checkpoint memorizzati sui singoli benchmark o su una qualsiasi delle tre batterie di benchmark utilizzate. Tuttavia, ha prodotto il modello migliore su tutti i benchmark mediati insieme.</p><p>Nei singoli benchmark, la differenza tra il modello unito e il checkpoint con le prestazioni migliori è in ogni caso inferiore a 0,01. Questo è vero non solo per le medie nella tabella sopra, ma per ogni singolo test.</p><p>Questo dimostra che l'unione di diversi checkpoint di addestramento può produrre un modello più robusto a un costo di prestazioni molto basso.</p><p>Inoltre, unendo i diversi checkpoint, possiamo proteggerci efficacemente dall'overtraining. L'overtraining è recentemente diventato un argomento importante nelle reti neurali. (<a href=\"https://arxiv.org/abs/2503.19206v2\">Springer et al., 2025</a>) Una rete può essere addestrata in un modo che la rende più difficile e con prestazioni peggiori dopo un'ulteriore messa a punto.</p><p>Poiché il checkpoint con le prestazioni migliori nel nostro esperimento non è spesso l'ultimo, probabilmente abbiamo sovra-addestrato il nostro modello a 6.000 passaggi di addestramento. Il modello unito si avvicina molto alle prestazioni del checkpoint migliore in tutti i test, rimuovendo i difetti dell'overtraining.</p><h3 id=\"experiment-2-averaging-models-trained-for-different-tasks\">Esperimento 2: media dei modelli addestrati per compiti diversi</h3><p>Per questo esperimento, abbiamo addestrato tre modelli, ognuno per un diverso compito di embedding comune:</p><ul><li><strong>Somiglianza semantica</strong>: misurazione della sovrapposizione relativa o della somiglianza di significato tra due testi, tipicamente di lunghezza comparabile.</li><li><strong>Recupero di documenti basato su query testuali</strong>: trovare i documenti che meglio soddisfano una query. Le query sono generalmente testi molto più brevi rispetto ai documenti a cui corrispondono.</li><li><strong>Risposta a domande</strong>: trovare il documento che meglio risponde a una domanda in linguaggio naturale. Anche le domande sono generalmente più brevi dei testi a cui corrispondono.</li></ul><p>Addestrare modelli per tutte e tre le attività contemporaneamente è piuttosto difficile perché gli obiettivi sono molto dissimili e speriamo che le \"model soup\" migliorino il processo.</p><p>In base all'esperienza precedente, sapevamo che ogni attività richiedeva un numero diverso di epoche di addestramento. L'addestramento è riassunto di seguito:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Task</th>\n<th>Training Steps<br>(batchsize = 1,024)</th>\n<th>Training Dataset Size<br>(in items)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Question Answering (QA)</td>\n<td>2,000</td>\n<td>256,000</td>\n</tr>\n<tr>\n<td>Document Retrieval</td>\n<td>3,000</td>\n<td>384,000</td>\n</tr>\n<tr>\n<td>Semantic Similarity (STS)</td>\n<td>1,000</td>\n<td>128,000</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Questo ha prodotto tre modelli, che abbiamo poi unito in un unico modello. Abbiamo testato il modello risultante rispetto alle parti del benchmark MMTEB rilevanti per quelle tre attività: <a href=\"https://project-miracl.github.io/\">MIRACL</a>, <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a> e STSEval (parti inglese e multilingue di MMTEB).</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(media di 6 lingue)</th>\n<th>NanoBEIR<br>(media di 13 benchmark)</th>\n<th>MMTEB-STS English<br>(media di 9 benchmark)</th>\n<th>MMTEB-STS Multilingual<br>(media di 6 benchmark)</th>\n<th>Media di 34 benchmark</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nessun addestramento tripletto</td>\n<td>0.3163</td>\n<td>0.5089</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.5876</td>\n</tr>\n<tr>\n<td>Addestramento QA</td>\n<td><strong>0.4489</strong></td>\n<td>0.5332</td>\n<td>0.7843</td>\n<td>0.7535</td>\n<td>0.6237</td>\n</tr>\n<tr>\n<td>Addestramento al recupero</td>\n<td>0.4272</td>\n<td><strong>0.5360</strong></td>\n<td>0.7766</td>\n<td>0.7340</td>\n<td>0.6154</td>\n</tr>\n<tr>\n<td>Addestramento STS</td>\n<td>0.1779</td>\n<td>0.4519</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.5508</td>\n</tr>\n<tr>\n<td>Modello unito</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td><strong>0.6240</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Qui vediamo che i modelli addestrati per attività specifiche hanno le migliori prestazioni su ciascuna attività. MIRACL è principalmente un benchmark di risposta a domande, anche se viene chiamato di recupero, e il modello addestrato per QA supera tutti gli altri, incluso il modello unito. NanoBEIR è un insieme di benchmark di information retrieval più convenzionale e vediamo che il modello addestrato per il recupero è il migliore. Il modello di similarità semantica (STS) ottiene punteggi piuttosto bassi su questi benchmark, ma batte gli altri su attività STS esplicite. Per ogni categoria, il modello unito si comporta peggio del modello addestrato per una singola attività.</p><p>Ma ancora una volta, se facciamo la media di tutti i benchmark, il modello unito supera gli altri, anche se il suo punteggio rappresenta solo un piccolissimo miglioramento rispetto al modello addestrato per QA ed è un interprete molto scarso nelle attività STS.</p><p>Abbiamo anche unito solo i modelli QA e di recupero e abbiamo valutato il modello risultante sugli stessi benchmark:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(media di 6 lingue)</th>\n<th>NanoBEIR<br>(media di 13 benchmark)</th>\n<th>MMTEB-STS English<br>(media di 9 benchmark)</th>\n<th>MMTEB-STS Multilingual<br>(media di 6 benchmark)</th>\n<th>Media di 34 test</th>\n<th>Media<br>QA &amp; IR<br>(19 test)</th>\n<th>Media STS<br>(15 test)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Miglior modello addestrato per task</td>\n<td>0.4489</td>\n<td>0.5360</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.6237</td>\n<td>0.5066</td>\n<td><strong>0.7857</strong></td>\n</tr>\n<tr>\n<td>Modello unito</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td>0.6240</td>\n<td>0.4973</td>\n<td>0.7845</td>\n</tr>\n<tr>\n<td>Modello unito QA+Retrieval</td>\n<td><strong>0.4610</strong></td>\n<td><strong>0.5404</strong></td>\n<td>0.7878</td>\n<td>0.7498</td>\n<td><strong>0.6288</strong></td>\n<td><strong>0.5153</strong></td>\n<td>0.7726</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Vediamo qui che, sebbene possiamo migliorare le prestazioni sia nella risposta a domande che nel recupero unendo modelli addestrati per le due attività, l'aggiunta di modelli addestrati per STS riduce le prestazioni specifiche per attività in tutte le categorie. Ciò suggerisce che la similarità semantica è, per alcuni aspetti importanti, diversa da QA e recupero e un modello addestrato per STS non è adatto per essere unito agli altri due.</p><p>Ciò è probabilmente dovuto al fatto che la risposta a domande e il recupero implicano l'abbinamento di testi brevi, ovvero domande e query, a documenti più lunghi, mentre la similarità semantica implica il confronto di documenti di lunghezza più simile.</p><p><a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a> descrivono un approccio selettivo alla media che chiamano fusione \"greedy\". Consiste nel prendere un modello, di solito il migliore di una serie di modelli, e quindi aggiungere solo quei modelli che migliorano individualmente le prestazioni. Con soli tre modelli, non aveva molto senso utilizzare la fusione greedy per questo esperimento. Tuttavia, potremmo immaginare un caso con più modelli e utilizzare una tecnica come questa come base per determinare il grado di similarità tra le attività. Qui abbiamo scoperto che la similarità semantica è diversa dalle altre due. Potremmo quindi valutare quando un modello può eseguire molte attività e quando è più conveniente utilizzare un modello diverso.</p><h2 id=\"soup%E2%80%99s-on\">Soup’s on!</h2><p>Le \"model soup\" fondono la diversità in qualcosa di più grande della somma delle loro parti. Il valore di questo approccio risiede nella sua capacità di offrire maggiore coerenza, robustezza e di agire come salvaguardia contro l'overtraining senza costi di addestramento aggiuntivi. I nostri esperimenti dimostrano che l'unione di checkpoint o modelli specializzati per attività può migliorare le prestazioni complessive, anche se a volte ciò avviene a scapito dei picchi specifici per attività.</p><p>Alla fine, le \"model soup\" offrono un modo pratico e molto semplice per costruire modelli più adattabili, anche se con alcune avvertenze. Non è una panacea ed è applicabile solo quando i modelli sono già molto simili.</p><p>Come si dice su internet, <em>Your Mileage May Vary</em>. Ma è economico e facile scoprire se le \"model soup\" possono aiutarti quando addestri i tuoi modelli.</p>",
  "comment_id": "681b63a077c406000104263b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/05/Heading--6-.jpg",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-05-07T15:44:00.000+02:00",
  "updated_at": "2025-05-07T19:56:02.000+02:00",
  "published_at": "2025-05-07T18:43:10.000+02:00",
  "custom_excerpt": "Boost robustness and performance with model soups: averaging weights. No extra cost, better results.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/model-soups-recipe-for-embeddings/",
  "excerpt": "Aumenta la robustezza e le prestazioni con le model soups: media dei pesi. Nessun costo aggiuntivo, risultati migliori.",
  "reading_time": 9,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}