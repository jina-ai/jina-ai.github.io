{
  "slug": "retrieve-jira-tickets-with-jina-reranker-and-haystack-20",
  "id": "661543ffd6a1020001681e99",
  "uuid": "54231ab9-8258-4020-bd25-3d13ec8f5f04",
  "title": "Recuperare i Ticket Jira con Jina Reranker e Haystack 2.0",
  "html": "<p>Dopo <a href=\"https://haystack.deepset.ai/blog/using-jina-embeddings-haystack?ref=jina-ai-gmbh.ghost.io\">l'integrazione di Jina Embeddings in Deepset's Haystack 2.0</a> e il <a href=\"https://jina.ai/news/maximizing-search-relevancy-and-rag-accuracy-with-jina-reranker?ref=jina-ai-gmbh.ghost.io\">rilascio di Jina Reranker</a>, siamo entusiasti di annunciare che Jina Reranker √® ora disponibile anche attraverso l'<a href=\"https://docs.haystack.deepset.ai/docs/jinaranker?ref=jina-ai-gmbh.ghost.io\">estensione Jina Haystack</a>.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://haystack.deepset.ai/integrations/jina?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Jina AI | Haystack</div><div class=\"kg-bookmark-description\">Use the latest Jina AI embedding models</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://haystack.deepset.ai/favicon.ico\" alt=\"\"><span class=\"kg-bookmark-author\">Haystack</span><span class=\"kg-bookmark-publisher\">Authors deepset</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://haystack.deepset.ai/images/haystack-ogimage.png\" alt=\"\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">Maximize the search relevancy and RAG accuracy at ease</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a></figure><p><a href=\"https://haystack.deepset.ai/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Haystack</a> √® un framework end-to-end che ti accompagna in ogni fase del ciclo di vita del progetto GenAI. Che tu voglia eseguire ricerche di documenti, retrieval-augmented generation (RAG), rispondere a domande o generare risposte, Haystack pu√≤ orchestrare modelli di embedding e LLM all'avanguardia in pipeline per costruire applicazioni NLP end-to-end e risolvere i tuoi casi d'uso.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://haystack.deepset.ai/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Haystack | Haystack</div><div class=\"kg-bookmark-description\">Haystack, the composable open-source AI framework</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://haystack.deepset.ai/favicon.ico\" alt=\"\"><span class=\"kg-bookmark-author\">Haystack</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://haystack.deepset.ai/images/haystack-ogimage.png\" alt=\"\"></div></a></figure><p>In questo post, mostreremo come usarli per creare il tuo motore di ricerca per ticket Jira per ottimizzare le tue operazioni e non perdere mai pi√π tempo creando segnalazioni duplicate.</p><p>Per seguire questo tutorial, avrai bisogno di una chiave API Jina Reranker. Puoi crearne una con una quota di prova gratuita di un milione di token dal <a href=\"https://jina.ai/reranker/?ref=jina-ai-gmbh.ghost.io\">sito web di Jina Reranker</a>.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">üí°</div><div class=\"kg-callout-text\">Puoi seguire il tutorial su <a href=\"https://colab.research.google.com/github/jina-ai/workshops/blob/main/notebooks/embeddings/haystack/Haystack_Reranker.ipynb?ref=jina-ai-gmbh.ghost.io\">Colab</a> o <a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/embeddings/haystack/Haystack_Reranker.ipynb?ref=jina-ai-gmbh.ghost.io\">scaricando il notebook</a>.</div></div><h2 id=\"retrieving-jira-support-tickets\">Recupero dei Ticket di Supporto Jira</h2><p>Qualsiasi team che si occupa di un progetto complesso ha sperimentato la frustrazione di avere un problema da segnalare senza sapere se esiste gi√† un ticket per questo problema.</p><p>Nel seguente tutorial, ti mostreremo come puoi facilmente creare uno strumento utilizzando Jina Reranker e le pipeline Haystack, che suggerisce possibili ticket duplicati quando ne viene creato uno nuovo.</p><ul><li>Inserendo un ticket da verificare rispetto a tutti i ticket esistenti, la pipeline recuperer√† prima dal database tutte le segnalazioni correlate.</li><li>Rimuover√† quindi il ticket iniziale dall'elenco (se gi√† esisteva nel database) e qualsiasi ticket figlio (cio√® i ticket il cui ID padre corrisponde al ticket originale).</li><li>La selezione finale ora comprende solo le segnalazioni che potrebbero coprire lo stesso argomento del ticket originale ma non sono state contrassegnate come tali nel database attraverso i loro ID. Questi ticket vengono riordinati per garantire la massima rilevanza e permetterti di identificare le voci duplicate nel database.</li></ul><h3 id=\"getting-the-dataset\">Ottenere il Dataset</h3><p>Per implementare la nostra soluzione, abbiamo scelto tutti i ticket Jira \"In Progress\" per il progetto <a href=\"https://zookeeper.apache.org/?ref=jina-ai-gmbh.ghost.io\">Apache Zookeeper</a>. Questo √® un servizio open-source per coordinare i processi di applicazioni distribuite.</p><p>Abbiamo inserito i ticket in un <a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/embeddings/haystack/tickets.json?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">file JSON</a> per renderli pi√π convenienti. Per favore <a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/embeddings/haystack/tickets.json?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">scarica il file</a> nel tuo spazio di lavoro.</p><h3 id=\"set-up-the-prerequisites\">Configurare i Prerequisiti</h3><p>Per installare i requisiti, esegui:</p><pre><code class=\"language-Bash\">pip install --q chromadb haystack-ai jina-haystack chroma-haystack</code></pre><p>Per inserire la chiave API, impostala come variabile d'ambiente:</p><pre><code class=\"language-Python\">import os\nimport getpass\n\nos.environ[\"JINA_API_KEY\"] = getpass.getpass()</code></pre><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">üí°</div><div class=\"kg-callout-text\">Se stai eseguendo questo codice attraverso il notebook, <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">getpass.getpass()</code> ti chieder√† di inserire la chiave API sotto il blocco di codice corrispondente. Puoi inserire la chiave l√¨ e premere invio per riprendere il tutorial. Se preferisci, puoi anche sostituire <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">getpass.getpass()</code> con la chiave API stessa.</div></div><h3 id=\"build-the-indexing-pipeline\">Costruire la Pipeline di Indicizzazione</h3><p>La pipeline di indicizzazione preprocesser√† i ticket, li trasformer√† in vettori e li memorizzer√†. Useremo il <a href=\"https://docs.trychroma.com/getting-started?ref=jina-ai-gmbh.ghost.io\">Chroma DocumentStore</a> come nostro database vettoriale per memorizzare gli embedding vettoriali, attraverso l'<a href=\"https://haystack.deepset.ai/integrations/chroma-documentstore?ref=jina-ai-gmbh.ghost.io\">integrazione Chroma Document Store Haystack</a>.</p><pre><code class=\"language-Python\">from haystack_integrations.document_stores.chroma import ChromaDocumentStore\n\ndocument_store = ChromaDocumentStore()</code></pre><p>Inizieremo definendo il nostro preprocessore di dati personalizzato per considerare solo i campi documento rilevanti e eliminare tutte le voci vuote:</p><pre><code class=\"language-Python\">import json\nfrom typing import List\nfrom haystack import Document, component\n\nrelevant_keys = ['Summary', 'Issue key', 'Issue id', 'Parent id', 'Issue type', 'Status', 'Project lead', 'Priority', 'Assignee', 'Reporter', 'Creator', 'Created', 'Updated', 'Last Viewed', 'Due Date', 'Labels',\n                 'Description', 'Comment', 'Comment__1', 'Comment__2', 'Comment__3', 'Comment__4', 'Comment__5', 'Comment__6', 'Comment__7', 'Comment__8', 'Comment__9', 'Comment__10', 'Comment__11', 'Comment__12',\n                 'Comment__13', 'Comment__14', 'Comment__15']\n\n@component\nclass RemoveKeys:\n    @component.output_types(documents=List[Document])\n    def run(self, file_name: str):\n        with open(file_name, 'r') as file:\n            tickets = json.load(file)\n        cleaned_tickets = []\n        for t in tickets:\n            t = {k: v for k, v in t.items() if k in relevant_keys and v}\n            cleaned_tickets.append(t)\n        return {'documents': cleaned_tickets}</code></pre><p>Dobbiamo poi creare un convertitore JSON personalizzato per trasformare i ticket in oggetti Document che Haystack pu√≤ comprendere:</p><pre><code class=\"language-Python\">@component\nclass JsonConverter:\n    @component.output_types(documents=List[Document])\n    def run(self, tickets: List[Document]):\n        tickets_documents = []\n        for t in tickets:\n            if 'Parent id' in t:\n                t = Document(content=json.dumps(t), meta={'Issue key': t['Issue key'], 'Issue id': t['Issue id'], 'Parent id': t['Parent id']})\n            else:\n                t = Document(content=json.dumps(t), meta={'Issue key': t['Issue key'], 'Issue id': t['Issue id'], 'Parent id': ''})\n            tickets_documents.append(t)\n        return {'documents': tickets_documents}</code></pre><p>Infine, incorporiamo i Document e scriviamo questi embedding nel ChromaDocumentStore:</p><pre><code class=\"language-Python\">from haystack import Pipeline\n\nfrom haystack.components.writers import DocumentWriter\nfrom haystack_integrations.components.retrievers.chroma import ChromaEmbeddingRetriever\nfrom haystack.document_stores.types import DuplicatePolicy\n\nfrom haystack_integrations.components.embedders.jina import JinaDocumentEmbedder\n\nretriever = ChromaEmbeddingRetriever(document_store=document_store)\nretriever_reranker = ChromaEmbeddingRetriever(document_store=document_store)\n\nindexing_pipeline = Pipeline()\nindexing_pipeline.add_component('cleaner', RemoveKeys())\nindexing_pipeline.add_component('converter', JsonConverter())\nindexing_pipeline.add_component('embedder', JinaDocumentEmbedder(model='jina-embeddings-v2-base-en'))\nindexing_pipeline.add_component('writer', DocumentWriter(document_store=document_store, policy=DuplicatePolicy.SKIP))\n\nindexing_pipeline.connect('cleaner', 'converter')\nindexing_pipeline.connect('converter', 'embedder')\nindexing_pipeline.connect('embedder', 'writer')\n\nindexing_pipeline.run({'cleaner': {'file_name': 'tickets.json'}})</code></pre><p>Questo dovrebbe creare una barra di progresso e produrre un breve JSON contenente informazioni su ci√≤ che √® stato memorizzato:</p><pre><code class=\"language-Text\">Calculating embeddings: 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1/1 [00:01&lt;00:00,  1.21s/it]\n{'embedder': {'meta': {'model': 'jina-embeddings-v2-base-en',\n   'usage': {'total_tokens': 20067, 'prompt_tokens': 20067}}},\n 'writer': {'documents_written': 31}}</code></pre><h3 id=\"build-the-query-pipeline\">Costruire la Pipeline di Query</h3><p>Creiamo una pipeline di query per poter iniziare a confrontare i ticket. In Haystack 2.0 i retriever sono strettamente accoppiati ai DocumentStore. Se passiamo il document store nel retriever che abbiamo inizializzato in precedenza, questa pipeline pu√≤ accedere ai documenti che abbiamo generato e passarli al reranker. Il reranker confronta quindi questi documenti direttamente con la domanda e li classifica in base alla rilevanza.</p><p>Prima definiamo il cleaner personalizzato per rimuovere i ticket recuperati che contengono lo stesso ID del problema o ID genitore del problema passato come query:</p><pre><code class=\"language-Python\">from typing import Optional\n\n@component\nclass RemoveRelated:\n    @component.output_types(documents=List[Document])\n    def run(self, tickets: List[Document], query_id: Optional[str]):\n        retrieved_tickets = []\n        for t in tickets:\n            if not t.meta['Issue id'] == query_id and not t.meta['Parent id'] == query_id:\n                retrieved_tickets.append(t)\n        return {'documents': retrieved_tickets}\n</code></pre><p>Quindi incorporiamo la query, recuperiamo i documenti rilevanti, puliamo la selezione e infine la riordiniamo:</p><pre><code class=\"language-Python\">from haystack_integrations.components.embedders.jina import JinaTextEmbedder\nfrom haystack_integrations.components.rankers.jina import JinaRanker\n\nquery_pipeline_reranker = Pipeline()\nquery_pipeline_reranker.add_component('query_embedder_reranker', JinaTextEmbedder(model='jina-embeddings-v2-base-en'))\nquery_pipeline_reranker.add_component('query_retriever_reranker', retriever_reranker)\nquery_pipeline_reranker.add_component('query_cleaner_reranker', RemoveRelated())\nquery_pipeline_reranker.add_component('query_ranker_reranker', JinaRanker())\n\nquery_pipeline_reranker.connect('query_embedder_reranker.embedding', 'query_retriever_reranker.query_embedding')\nquery_pipeline_reranker.connect('query_retriever_reranker', 'query_cleaner_reranker')\nquery_pipeline_reranker.connect('query_cleaner_reranker', 'query_ranker_reranker')\n</code></pre><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/04/upload_916b6073b69f880f765730833bcdfbe3.png\" class=\"kg-image\" alt=\"Diagramma di flusso che delinea un flusso di elaborazione delle query con funzioni come 'text', 'query_embedder_reranker', 'meta'.\" loading=\"lazy\" width=\"510\" height=\"972\"></figure><p>Per evidenziare la differenza causata dal reranker, abbiamo analizzato la stessa pipeline senza il passaggio finale di riordinamento (il codice corrispondente √® stato omesso in questo post per motivi di leggibilit√† ma pu√≤ essere trovato nel notebook):</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/04/upload_d16f493c35c403b55f7c420c11c1f998.png\" class=\"kg-image\" alt=\"Diagramma di flusso che dettaglia un processo di ricerca testuale con componenti 'query_embedding', 'query_retriever' e 'query_cleaner'.\" loading=\"lazy\" width=\"572\" height=\"984\"></figure><p>Per confrontare i risultati di queste due pipeline, definiamo ora la nostra query sotto forma di ticket esistente, in questo caso \"ZOOKEEPER-3282\":</p><pre><code class=\"language-Python\">query_ticket_key = 'ZOOKEEPER-3282'\n\nwith open('tickets.json', 'r') as file:\n    tickets = json.load(file)\n\nfor ticket in tickets:\n    if ticket['Issue key'] == query_ticket_key:\n        query = str(ticket)\n        query_ticket_id = ticket['Issue id']\n</code></pre><p>Riguarda \"una grande rielaborazione per la documentazione\" [<a href=\"https://en.wikipedia.org/wiki/Sic?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\"><em>sic</em></a>]. Vedrai che, nonostante l'errore di ortografia, Jina Reranker recuperer√† correttamente ticket simili.</p><pre><code class=\"language-JSON\">{\n    \"Summary\": \"a big refactor for the documetations\"\n    \"Issue key\": \"ZOOKEEPER-3282\"\n    \"Issue id:: 13216608\n    \"Parent id\": \"\"\n    \"Issue Type\": \"Task\"\n    \"Status\": \"In Progress\"\n    \"Project lead\": \"phunt\"\n    \"Priority\": \"Major\"\n    \"Assignee\": \"maoling\"\n    \"Reporter\": \"maoling\"\n    \"Creator\": \"maoling\"\n    \"Created\": \"19/Feb/19 11:50\"\n    \"Updated\": \"04/Aug/19 12:48\"\n    \"Last Viewed\": \"12/Mar/24 11:56\"\n    \"Description\": \"Hi guys: I'am working on doing a big refactor for the documetations.it aims to - 1.make a better reading experiences and help users know more about zookeeper quickly,as good as other projects' doc(e.g redis,hbase). - 2.have less changes to diff with the original docs as far as possible. - 3.solve the problem when we have some new features or improvements,but cannot find a good place to doc it.   The new catalog may looks kile this: * is new one added. ** is the one to keep unchanged as far as possible. *** is the one modified. -------------------------------------------------------------- |---Overview    |---Welcome ** [1.1]    |---Overview ** [1.2]    |---Getting Started ** [1.3]    |---Release Notes ** [1.4] |---Developer    |---API *** [2.1]    |---Programmer's Guide ** [2.2]    |---Recipes *** [2.3]    |---Clients * [2.4]    |---Use Cases * [2.5] |---Admin &amp; Ops    |---Administrator's Guide ** [3.1]    |---Quota Guide ** [3.2]    |---JMX ** [3.3]    |---Observers Guide ** [3.4]    |---Dynamic Reconfiguration ** [3.5]    |---Zookeeper CLI * [3.6]    |---Shell * [3.7]    |---Configuration flags * [3.8]    |---Troubleshooting &amp; Tuning  * [3.9] |---Contributor Guidelines    |---General Guidelines * [4.1]    |---ZooKeeper Internals ** [4.2] |---Miscellaneous    |---Wiki ** [5.1]    |---Mailing Lists ** [5.2] -------------------------------------------------------------- The Roadmap is: 1.(I pick up it : D)  1.1 write API[2.1], which includes theÔºö    1.1.1  original API Docs which is a Auto-generated java doc,just give a link.    1.1.2. Restful-api (the apis under the /zookeeper-contrib-rest/src/main/java/org/apache/zookeeper/server/jersey/resources)  1.2 write Clients[2.4], which includes the:      1.2.1 C client      1.2.2 zk-python, kazoo      1.2.3 Curator etc.......      look at an example from: https://redis.io/clients # write Recipes[2.3], which includes the:  - integrate \"Java Example\" and \"Barrier and Queue Tutorial\"(Since some bugs in the examples and they are obsoleteÔºåwe may delete something) into it.  - suggest users to use the recipes implements of Curator and link to the Curator's recipes doc.   # write Zookeeper CLI[3.6], which includes the:  - about how to use the zk command line interface [./zkCli.sh]    e.g ls /; get ; rmr;create -e -p etc.......  - look at an example from redis: https://redis.io/topics/rediscli   # write shell[3.7], which includes the:   - list all usages of the shells under the zookeeper/bin. (e.g zkTxnLogToolkit.sh,zkCleanup.sh)   # write Configuration flags[3.8], which includes the:   - list all usages of configurations properties(e.g zookeeper.snapCount):   - move the original Advanced Configuration part of zookeeperAdmin.md into it.     look at an example from:https://coreos.com/etcd/docs/latest/op-guide/configuration.html    # write Troubleshooting &amp; Tuning[3.9], which includes the:   - move the original \"Gotchas: Common Problems and Troubleshooting\" part of Administrator's Guide.md into it.   - move the original \"FAQ\" into into it.   - add some new contents Ôºàe.g https://www.yumpu.com/en/document/read/29574266/building-an-impenetrable-zookeeper-pdf-githubÔºâ.   look at an example from:https://redis.io/topics/problems                             https://coreos.com/etcd/docs/latest/tuning.html   # write General Guidelines[4.1], which includes the:  - move the original \"Logging\" part of ZooKeeper Internals into it as the logger specification.  - write specifications about code, git commit messages,github PR  etc ...    look at an example from:    http://hbase.apache.org/book.html#hbase.commit.msg.format   # write Use Cases[2.5], which includes the:  - just move the context from: https://cwiki.apache.org/confluence/display/ZOOKEEPER/PoweredBy into it.  - add some new contents.(e.g Apache Projects:Spark;Companies:twitter,fb)   -------------------------------------------------------------- BTW: - Any insights or suggestions are very welcomed.After the dicussions,I will create a series of tickets(An umbrella) - Since these works can be done parallelly, if you are interested in them, please don't hesitate,just assign to yourself, pick it up. (Notice: give me a ping to avoid the duplicated work).\"\n}\n</code></pre><p>Infine, eseguiamo la pipeline di query. In questo caso, recupera 20 ticket, elimina le voci correlate all'ID, le riordina e produce la selezione finale dei 10 problemi pi√π rilevanti.</p><p>Prima del passaggio di riordino, l'output include 17 ticket:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Issue ID</th>\n<th>Issue Key</th>\n<th>Summary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>13191544</td>\n<td>ZOOKEEPER-3170</td>\n<td>Umbrella for eliminating ZooKeeper flaky tests</td>\n</tr>\n<tr>\n<td>2</td>\n<td>13400622</td>\n<td>ZOOKEEPER-4375</td>\n<td>Quota cannot limit the specify value when multiply clients create/set znodes</td>\n</tr>\n<tr>\n<td>3</td>\n<td>13249579</td>\n<td>ZOOKEEPER-3499</td>\n<td>[admin server way] Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n<tr>\n<td>4</td>\n<td>13295073</td>\n<td>ZOOKEEPER-3775</td>\n<td>Wrong message in IOException</td>\n</tr>\n<tr>\n<td>5</td>\n<td>13268474</td>\n<td>ZOOKEEPER-3617</td>\n<td>ZK digest ACL permissions gets overridden</td>\n</tr>\n<tr>\n<td>6</td>\n<td>13296971</td>\n<td>ZOOKEEPER-3787</td>\n<td>Apply modernizer-maven-plugin to build</td>\n</tr>\n<tr>\n<td>7</td>\n<td>13265507</td>\n<td>ZOOKEEPER-3600</td>\n<td>support the complete linearizable read and multiply read consistency level</td>\n</tr>\n<tr>\n<td>8</td>\n<td>13222060</td>\n<td>ZOOKEEPER-3318</td>\n<td>[CLI way]Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n<tr>\n<td>9</td>\n<td>13262989</td>\n<td>ZOOKEEPER-3587</td>\n<td>Add a documentation about docker</td>\n</tr>\n<tr>\n<td>10</td>\n<td>13262130</td>\n<td>ZOOKEEPER-3578</td>\n<td>Add a new CLI: multi</td>\n</tr>\n<tr>\n<td>11</td>\n<td>13262828</td>\n<td>ZOOKEEPER-3585</td>\n<td>Add a documentation about RequestProcessors</td>\n</tr>\n<tr>\n<td>12</td>\n<td>13262494</td>\n<td>ZOOKEEPER-3583</td>\n<td>Add new apis to get node type and ttl time info</td>\n</tr>\n<tr>\n<td>13</td>\n<td>12998876</td>\n<td>ZOOKEEPER-2519</td>\n<td>zh-&gt;state should not be 0 while handle is active</td>\n</tr>\n<tr>\n<td>14</td>\n<td>13536435</td>\n<td>ZOOKEEPER-4696</td>\n<td>Update for Zookeeper latest version</td>\n</tr>\n<tr>\n<td>15</td>\n<td>13297249</td>\n<td>ZOOKEEPER-3789</td>\n<td>fix the build warnings about @see,@link,@return found by IDEA</td>\n</tr>\n<tr>\n<td>16</td>\n<td>12728973</td>\n<td>ZOOKEEPER-1983</td>\n<td>Append to zookeeper.out (not overwrite) to support logrotation</td>\n</tr>\n<tr>\n<td>17</td>\n<td>12478629</td>\n<td>ZOOKEEPER-915</td>\n<td>Errors that happen during sync() processing at the leader do not get propagated back to the client.</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Dopo aver incluso il reranker, eseguiamo ora la pipeline di query:</p><pre><code class=\"language-Python\">result = query_pipeline_reranker.run(data={'query_embedder_reranker':{'text': query},\n                                  'query_retriever_reranker': {'top_k': 20},\n                                  'query_cleaner_reranker': {'query_id': query_ticket_id},\n                                  'query_ranker_reranker': {'query': query, 'top_k': 10}\n                                  }\n                            )\n\nfor idx, res in enumerate(result['query_ranker_reranker']['documents']):\n    print('Doc {}:'.format(idx + 1), res)\n</code></pre><p>L'output finale √® composto dai 10 ticket pi√π rilevanti:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Issue ID</th>\n<th>Issue Key</th>\n<th>Summary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>13262989</td>\n<td>ZOOKEEPER-3587</td>\n<td>Add a documentation about docker</td>\n</tr>\n<tr>\n<td>2</td>\n<td>13265507</td>\n<td>ZOOKEEPER-3600</td>\n<td>support the complete linearizable read and multiply read consistency level</td>\n</tr>\n<tr>\n<td>3</td>\n<td>13249579</td>\n<td>ZOOKEEPER-3499</td>\n<td>[admin server way] Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n<tr>\n<td>4</td>\n<td>12478629</td>\n<td>ZOOKEEPER-915</td>\n<td>Errors that happen during sync() processing at the leader do not get propagated back to the client.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>13262828</td>\n<td>ZOOKEEPER-3585</td>\n<td>Add a documentation about RequestProcessors</td>\n</tr>\n<tr>\n<td>6</td>\n<td>13297249</td>\n<td>ZOOKEEPER-3789</td>\n<td>fix the build warnings about @see,@link,@return found by IDEA</td>\n</tr>\n<tr>\n<td>7</td>\n<td>12998876</td>\n<td>ZOOKEEPER-2519</td>\n<td>zh-&gt;state should not be 0 while handle is active</td>\n</tr>\n<tr>\n<td>8</td>\n<td>13536435</td>\n<td>ZOOKEEPER-4696</td>\n<td>Update for Zookeeper latest version</td>\n</tr>\n<tr>\n<td>9</td>\n<td>12728973</td>\n<td>ZOOKEEPER-1983</td>\n<td>Append to zookeeper.out (not overwrite) to support logrotation</td>\n</tr>\n<tr>\n<td>10</td>\n<td>13222060</td>\n<td>ZOOKEEPER-3318</td>\n<td>[CLI way]Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"advantages-of-jina-embeddings-and-reranker\">Vantaggi di Jina Embeddings e Reranker</h2><p>Per riassumere questo tutorial, abbiamo costruito uno strumento di identificazione dei ticket duplicati basato su <a href=\"https://jina.ai/embeddings/?ref=jina-ai-gmbh.ghost.io\">Jina Embeddings</a>, <a href=\"https://jina.ai/reranker/?ref=jina-ai-gmbh.ghost.io\">Jina Reranker</a> e <a href=\"https://haystack.deepset.ai/?ref=jina-ai-gmbh.ghost.io\">Haystack 2.0</a>. I risultati sopra mostrano chiaramente la necessit√† sia di Jina Embeddings per recuperare documenti rilevanti attraverso la ricerca vettoriale, sia di Jina Reranker per ottenere infine il contenuto pi√π rilevante.</p><p>Se prendiamo, per esempio, i due problemi relativi all'aggiunta di documentazione, cio√® \"ZOOKEEPER-3585\" e \"ZOOKEEPER-3587\", vediamo che dopo la fase di recupero, sono entrambi correttamente inclusi rispettivamente nelle posizioni 11 e 9. Dopo il riordino dei documenti, si trovano ora entrambi tra i 5 documenti pi√π rilevanti rispettivamente alle posizioni 5 e 1, mostrando un miglioramento significativo.</p><p>Integrando entrambi i modelli nelle pipeline di Haystack, l'intero strumento √® pronto all'uso. Questa combinazione rende l'<a href=\"https://haystack.deepset.ai/integrations/jina/?ref=jina-ai-gmbh.ghost.io\">estensione Jina Haystack</a> la soluzione perfetta per la tua applicazione.</p>",
  "comment_id": "661543ffd6a1020001681e99",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/04/Reranker-Haystack.jpg",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-04-09T15:34:55.000+02:00",
  "updated_at": "2024-07-08T21:11:51.000+02:00",
  "published_at": "2024-04-10T16:00:49.000+02:00",
  "custom_excerpt": "Learn how to use Jina Reranker and Embeddings with Haystack to create your own Jira ticket search engine, streamlining your operations and never again waste time creating duplicate issues.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "authors": [
    {
      "id": "65e85e35b22368000152a4bf",
      "name": "Francesco Kruk",
      "slug": "francesco",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Portrait-Picture_Low.jpg",
      "cover_image": null,
      "bio": null,
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/francesco/"
    }
  ],
  "primary_author": {
    "id": "65e85e35b22368000152a4bf",
    "name": "Francesco Kruk",
    "slug": "francesco",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Portrait-Picture_Low.jpg",
    "cover_image": null,
    "bio": null,
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/francesco/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/retrieve-jira-tickets-with-jina-reranker-and-haystack-20/",
  "excerpt": "Scopri come utilizzare Jina Reranker ed Embeddings con Haystack per creare il tuo motore di ricerca per i ticket Jira, ottimizzando le tue operazioni ed evitando di perdere tempo nella creazione di segnalazioni duplicate.",
  "reading_time": 10,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Graphic with \"Reranker\" and \"Haystack by deepset\" on a black background with teal decorative elements.",
  "feature_image_caption": null
}