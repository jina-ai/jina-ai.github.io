{
  "slug": "reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown",
  "id": "66dff7eba241f5000155d851",
  "uuid": "49dc11d4-e792-49d6-b778-512add9024bc",
  "title": "Reader-LM: Piccoli Language Model per Pulire e Convertire HTML in Markdown",
  "html": "<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-0.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-0.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Siamo in un viaggio per far progredire e democratizzare l'intelligenza artificiale attraverso l'open source e la scienza aperta.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-0.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-1.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-1.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Siamo in un viaggio per far progredire e democratizzare l'intelligenza artificiale attraverso l'open source e la scienza aperta.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-1.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Ad aprile 2024, abbiamo rilasciato <a href=\"https://jina.ai/reader?ref=jina-ai-gmbh.ghost.io\">Jina Reader</a>, una semplice API che converte qualsiasi URL in markdown compatibile con LLM con un semplice prefisso: <code>r.jina.ai</code>. Nonostante la sofisticata programmazione di rete dietro le quinte, la parte centrale di \"lettura\" è piuttosto semplice. Prima, utilizziamo un browser Chrome headless per recuperare il codice sorgente della pagina web. Poi, sfruttiamo il pacchetto <a href=\"https://github.com/mozilla/readability?ref=jina-ai-gmbh.ghost.io\">Readability</a> di Mozilla per estrarre il contenuto principale, rimuovendo elementi come intestazioni, piè di pagina, barre di navigazione e barre laterali. Infine, convertiamo l'HTML ripulito in markdown utilizzando <a href=\"https://x.com/JinaAI_/status/1823756993108304135?ref=jina-ai-gmbh.ghost.io\">regex</a> e la <a href=\"https://github.com/mixmark-io/turndown?ref=jina-ai-gmbh.ghost.io\">libreria Turndown</a>. Il risultato è un file markdown ben strutturato, pronto per essere utilizzato dagli LLM per il grounding, il riassunto e il ragionamento.</p><p>Nelle prime settimane dopo il rilascio di Jina Reader, abbiamo ricevuto molti feedback, in particolare sulla qualità del contenuto. Alcuni utenti lo hanno trovato troppo dettagliato, mentre altri lo ritenevano non abbastanza dettagliato. Ci sono state anche segnalazioni che il filtro Readability rimuoveva il contenuto sbagliato o che Turndown aveva difficoltà a convertire alcune parti dell'HTML in markdown. Fortunatamente, molti di questi problemi sono stati risolti con successo correggendo la pipeline esistente con nuovi pattern regex o euristiche.</p><p>Da allora, ci siamo posti una domanda: invece di correggerlo con più euristiche e regex (che diventa sempre più difficile da mantenere e non è multilingue-friendly), possiamo risolvere questo problema <em>end-to-end</em> con un modello linguistico?</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png\" class=\"kg-image\" alt=\"Diagramma di flusso che illustra la conversione da HTML grezzo a formato Markdown utilizzando le librerie readability e turndown, più regex/eu\" loading=\"lazy\" width=\"1800\" height=\"945\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/Heading--48-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/Heading--48-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/Heading--48-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png 1800w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Illustrazione di </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>reader-lm</span></code><span style=\"white-space: pre-wrap;\">, che sostituisce la pipeline di readability+turndown+regex euristiche utilizzando un piccolo modello linguistico.</span></figcaption></figure><p>A prima vista, utilizzare LLM per la pulizia dei dati potrebbe sembrare eccessivo a causa della loro bassa efficienza in termini di costi e della velocità più lenta. Ma se considerassimo un <strong>small language model (SLM)</strong> — uno con meno di 1 miliardo di parametri che può funzionare efficacemente sull'edge? Suona molto più interessante, vero? Ma è veramente fattibile o solo un pensiero ottimistico? Secondo la legge di scaling, meno parametri generalmente portano a capacità ridotte di ragionamento e sintesi. Quindi un SLM potrebbe persino faticare a generare contenuti significativi se la sua dimensione parametrica è troppo piccola. Per esplorare ulteriormente questo aspetto, diamo uno sguardo più da vicino al task di conversione HTML-to-Markdown:</p><ul><li>Prima di tutto, il task che stiamo considerando <strong>non è creativo o complesso come i tipici task LLM</strong>. Nel caso della conversione da HTML a markdown, il modello deve principalmente <strong>copiare selettivamente</strong> dall'input all'output (cioè, saltare il markup HTML, le barre laterali, le intestazioni, i piè di pagina), con uno sforzo minimo speso per generare nuovo contenuto (principalmente inserendo la sintassi markdown). Questo contrasta nettamente con i task più ampi gestiti dagli LLM, come generare poesie o scrivere codice, dove l'output richiede molta più creatività e non è un semplice copia-incolla dall'input. Questa osservazione suggerisce che un SLM potrebbe funzionare, poiché il task <em>sembra</em> più semplice rispetto alla generazione di testo più generale.</li><li>In secondo luogo, dobbiamo <strong>dare priorità al supporto per contesti lunghi</strong>. L'HTML moderno spesso contiene molto più rumore del semplice markup <code>&lt;div&gt;</code>. CSS inline e script possono facilmente far lievitare il codice a centinaia di migliaia di token. Perché un SLM sia pratico in questo scenario, la lunghezza del contesto deve essere sufficientemente grande. Lunghezze di token come 8K o 16K non sono <em>per nulla</em> utili.</li></ul><p>Sembra che ciò di cui abbiamo bisogno sia un SLM <strong><em>shallow-but-wide</em></strong>. \"Shallow\" nel senso che il task è principalmente un semplice \"copia-incolla\", quindi sono necessari meno blocchi transformer; e \"wide\" nel senso che richiede supporto per contesti lunghi per essere pratico, quindi il meccanismo di attenzione necessita di particolare cura. Ricerche precedenti hanno dimostrato che la lunghezza del contesto e la capacità di ragionamento sono strettamente interconnesse. Per un SLM, è estremamente impegnativo ottimizzare entrambe le dimensioni mantenendo piccola la dimensione dei parametri.</p><p>Oggi, siamo entusiasti di annunciare la prima versione di questa soluzione con il rilascio di <code>reader-lm-0.5b</code> e <code>reader-lm-1.5b</code>, due SLM specificamente addestrati <strong>per generare markdown pulito direttamente da HTML grezzo rumoroso</strong>. Entrambi i modelli sono multilingue e supportano una lunghezza di contesto fino a <strong>256K token</strong>. Nonostante le loro dimensioni compatte, questi modelli raggiungono prestazioni allo stato dell'arte su questo task, superando controparti LLM più grandi pur essendo solo 1/50 delle loro dimensioni.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Reader-LM-vs-LLMs-on-the-HTML2Markdown-task--1-.svg\" class=\"kg-image\" alt=\"Grafico a barre che mostra le prestazioni superiori di Reader-LM nel task HTML2Markdown con il punteggio più alto a 0.72 rispetto a vari LLM.\" loading=\"lazy\" width=\"805\" height=\"514\"></figure><p>Di seguito sono riportate le specifiche dei due modelli:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">reader-lm-0.5b</th>\n<th style=\"text-align:center\">reader-lm-1.5b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td># Parametri</td>\n<td style=\"text-align:center\">494M</td>\n<td style=\"text-align:center\">1.54B</td>\n</tr>\n<tr>\n<td>Lunghezza contesto</td>\n<td style=\"text-align:center\">256K</td>\n<td style=\"text-align:center\">256K</td>\n</tr>\n<tr>\n<td>Hidden Size</td>\n<td style=\"text-align:center\">896</td>\n<td style=\"text-align:center\">1536</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">128</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td style=\"text-align:center\">4864</td>\n<td style=\"text-align:center\">8960</td>\n</tr>\n<tr>\n<td>Multilingue</td>\n<td style=\"text-align:center\">Sì</td>\n<td style=\"text-align:center\">Sì</td>\n</tr>\n<tr>\n<td>Repository HuggingFace</td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-0.5b/?ref=jina-ai-gmbh.ghost.io\">Link</a></td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-1.5b/?ref=jina-ai-gmbh.ghost.io\">Link</a></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"get-started-with-reader-lm\">Iniziare con Reader-LM</h2><h3 id=\"on-google-colab\">Su Google Colab</h3><p>Il modo più semplice per sperimentare <code>reader-lm</code> è eseguire il nostro notebook Colab, dove dimostriamo come utilizzare <code>reader-lm-1.5b</code> per convertire il sito web di Hacker News in markdown. Il notebook è ottimizzato per funzionare senza problemi sul tier GPU T4 gratuito di Google Colab. Puoi anche caricare <code>reader-lm-0.5b</code> o cambiare l'URL in qualsiasi sito web ed esplorare l'output. Nota che l'input (cioè il prompt) al modello è l'HTML grezzo—non è richiesta alcuna istruzione di prefisso.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/1wXWyj5hOxEHY6WeHbOwEzYAC0WB1I5uA?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/colab_favicon_256px.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Si prega di notare che la GPU T4 del tier gratuito presenta limitazioni che potrebbero impedire l'uso di ottimizzazioni avanzate durante l'esecuzione del modello. Funzionalità come bfloat16 e flash attention non sono disponibili sulla T4, il che potrebbe comportare un maggior utilizzo di VRAM e prestazioni più lente per input più lunghi. <strong>Per ambienti di produzione, raccomandiamo l'utilizzo di una GPU di fascia alta come la RTX 3090/4090 per prestazioni significativamente migliori.</strong></p><h3 id=\"in-production-available-on-azure-aws-soon\">In Produzione: Presto disponibile su Azure e AWS</h3><p>Reader-LM è disponibile su Azure Marketplace e AWS SageMaker. Se hai bisogno di utilizzare questi modelli al di fuori di queste piattaforme o on-premises all'interno della tua azienda, nota che entrambi i modelli sono concessi in licenza sotto CC BY-NC 4.0. <a href=\"https://jina.ai/contact-sales/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Per richieste di utilizzo commerciale, non esitare a contattarci.</a></p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-nli7b6dueo424?sr=0-1&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 0.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-ms27ixcwq3wjk?sr=0-2&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 1.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-500m?tab=Overview&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-1500m?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><h2 id=\"benchmark\">Benchmark</h2><p>Per valutare quantitativamente le prestazioni di Reader-LM, lo abbiamo confrontato con diversi modelli linguistici di grandi dimensioni, tra cui: GPT-4o, Gemini-1.5-Flash, Gemini-1.5-Pro, LLaMA-3.1-70B, Qwen2-7B-Instruct.</p><p>I modelli sono stati valutati utilizzando le seguenti metriche:</p><ul><li><strong>ROUGE-L (più alto è meglio)</strong>: Questa metrica, ampiamente utilizzata per compiti di riassunto e domanda-risposta, misura la sovrapposizione tra l'output previsto e il riferimento a livello di n-gram.</li><li><strong>Token Error Rate (TER, più basso è meglio)</strong>: Questa metrica calcola il tasso con cui i token markdown generati non appaiono nel contenuto HTML originale. Abbiamo progettato questa metrica per valutare il tasso di allucinazione del modello, aiutandoci a identificare i casi in cui il modello produce contenuti non basati sull'HTML. Ulteriori miglioramenti saranno apportati in base agli studi dei casi.</li><li><strong>Word Error Rate (WER, più basso è meglio)</strong>: Comunemente utilizzato nei compiti di OCR e ASR, WER considera la sequenza di parole e calcola errori come inserimenti (ADD), sostituzioni (SUB) ed eliminazioni (DEL). Questa metrica fornisce una valutazione dettagliata delle discrepanze tra il markdown generato e l'output previsto.</li></ul><p>Per sfruttare i LLM per questo compito, abbiamo utilizzato la seguente istruzione uniforme come prompt di prefisso:</p><pre><code>Your task is to convert the content of the provided HTML file into the corresponding markdown file. You need to convert the structure, elements, and attributes of the HTML into equivalent representations in markdown format, ensuring that no important information is lost. The output should strictly be in markdown format, without any additional explanations.</code></pre><p>I risultati sono disponibili nella tabella sottostante.</p>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ROUGE-L</th>\n<th>WER</th>\n<th>TER</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reader-lm-0.5b</td>\n<td>0.56</td>\n<td>3.28</td>\n<td>0.34</td>\n</tr>\n<tr>\n<td>reader-lm-1.5b</td>\n<td><strong>0.72</strong></td>\n<td><strong>1.87</strong></td>\n<td><strong>0.19</strong></td>\n</tr>\n<tr>\n<td>gpt-4o</td>\n<td>0.43</td>\n<td>5.88</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>gemini-1.5-flash</td>\n<td>0.40</td>\n<td>21.70</td>\n<td>0.55</td>\n</tr>\n<tr>\n<td>gemini-1.5-pro</td>\n<td>0.42</td>\n<td>3.16</td>\n<td>0.48</td>\n</tr>\n<tr>\n<td>llama-3.1-70b</td>\n<td>0.40</td>\n<td>9.87</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>Qwen2-7B-Instruct</td>\n<td>0.23</td>\n<td>2.45</td>\n<td>0.70</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"qualitative-study\">Studio Qualitativo</h2><p>Abbiamo condotto uno studio qualitativo esaminando visivamente l'output markdown. <a href=\"https://docs.google.com/spreadsheets/d/1Wb2sMdiEoToPaXohcrEznFKStt_4alVOnJD3WKkiM7o/edit?gid=1576339853&ref=jina-ai-gmbh.ghost.io#gid=1576339853\">Abbiamo selezionato 22 fonti HTML</a> tra cui articoli di news, post di blog, landing page, pagine di e-commerce e post di forum in diverse lingue: inglese, tedesco, giapponese e cinese. Abbiamo incluso anche la Jina Reader API come baseline, che si basa su regex, euristiche e regole predefinite.</p><p>La valutazione si è concentrata su quattro dimensioni chiave dell'output, con ogni modello valutato su una scala da 1 (più basso) a 5 (più alto):</p><ol><li><strong>Estrazione Header</strong>: Valutato quanto bene ogni modello ha identificato e formattato gli header h1,h2,..., h6 del documento usando la corretta sintassi markdown.</li><li><strong>Estrazione Contenuto Principale</strong>: Valutato la capacità dei modelli di convertire accuratamente il testo del corpo, preservando paragrafi, formattando liste e mantenendo la consistenza nella presentazione.</li><li><strong>Preservazione Struttura Complessa</strong>: Analizzato quanto efficacemente ogni modello ha mantenuto la struttura complessiva del documento, inclusi titoli, sottotitoli, punti elenco e liste ordinate.</li><li><strong>Utilizzo Sintassi Markdown</strong>: Valutato la capacità di ogni modello di convertire correttamente gli elementi HTML come <code>&lt;a&gt;</code> (link), <code>&lt;strong&gt;</code> (testo in grassetto) e <code>&lt;em&gt;</code> (corsivo) nei loro equivalenti markdown appropriati.</li></ol><p>I risultati sono disponibili di seguito.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Qualitative-Evaluation-of-Reader-LM-vs-LLMs-and-Jina-Reader-API--1-.svg\" class=\"kg-image\" alt=\"Grafico a barre che confronta Reader-LM, LLM e Jina Reader API su metriche come l'estrazione di header e la preservazione dei contenuti.\" loading=\"lazy\" width=\"863\" height=\"533\"></figure><p>Reader-LM-1.5B si comporta costantemente bene in tutte le dimensioni, eccellendo particolarmente nella preservazione della struttura e nell'utilizzo della sintassi markdown. Anche se non sempre supera Jina Reader API, le sue prestazioni sono competitive con modelli più grandi come Gemini 1.5 Pro, rendendolo un'alternativa altamente efficiente ai LLM più grandi. Reader-LM-0.5B, sebbene più piccolo, offre comunque prestazioni solide, in particolare nella preservazione della struttura.</p><h2 id=\"how-we-trained-reader-lm\">Come Abbiamo Addestrato Reader-LM</h2><h3 id=\"data-preparation\">Preparazione dei Dati</h3><p>Abbiamo utilizzato la Jina Reader API per generare coppie di addestramento di HTML grezzo e il loro corrispondente markdown. Durante l'esperimento, abbiamo scoperto che gli SLM sono particolarmente sensibili alla qualità dei dati di addestramento. Quindi abbiamo costruito una pipeline di dati che assicura che solo voci markdown di alta qualità siano incluse nel set di addestramento.</p><p>Inoltre, abbiamo aggiunto alcuni HTML sintetici e i loro corrispondenti markdown, generati da <code>GPT-4o</code>. Rispetto all'HTML del mondo reale, i dati sintetici tendono ad essere molto più brevi, con strutture più semplici e prevedibili, e un livello di rumore significativamente inferiore.</p><p>Infine, abbiamo concatenato l'HTML e il markdown utilizzando un template di chat. I dati di addestramento finali sono formattati come segue:</p><pre><code>&lt;|im_start|&gt;system\nYou are a helpful assistant.&lt;|im_end|&gt;\n&lt;|im_start|&gt;user\n{{RAW_HTML}}&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n{{MARKDOWN}}&lt;|im_end|&gt;\n</code></pre><p>I dati di addestramento completi ammontano a 2,5 miliardi di token.</p><h3 id=\"two-stage-training\">Addestramento in Due Fasi</h3><p>Abbiamo sperimentato con diverse dimensioni di modello, partendo da 65M e 135M fino a 3B parametri. Le specifiche per ogni modello sono riportate nella tabella qui sotto.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>reader-lm-65m</th>\n<th>reader-lm-135m</th>\n<th>reader-lm-360m</th>\n<th>reader-lm-0.5b</th>\n<th>reader-lm-1.5b</th>\n<th>reader-lm-1.7b</th>\n<th>reader-lm-3b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hidden Size</td>\n<td>512</td>\n<td>576</td>\n<td>960</td>\n<td>896</td>\n<td>1536</td>\n<td>2048</td>\n<td>3072</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td>8</td>\n<td>30</td>\n<td>32</td>\n<td>24</td>\n<td>28</td>\n<td>24</td>\n<td>32</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td>16</td>\n<td>9</td>\n<td>15</td>\n<td>14</td>\n<td>12</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td>8</td>\n<td>3</td>\n<td>5</td>\n<td>2</td>\n<td>2</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n<td>128</td>\n<td>64</td>\n<td>96</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td>2048</td>\n<td>1536</td>\n<td>2560</td>\n<td>4864</td>\n<td>8960</td>\n<td>8192</td>\n<td>8192</td>\n</tr>\n<tr>\n<td>Attention Bias</td>\n<td>False</td>\n<td>False</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Embedding Tying</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Vocabulary Size</td>\n<td>32768</td>\n<td>49152</td>\n<td>49152</td>\n<td>151646</td>\n<td>151646</td>\n<td>49152</td>\n<td>32064</td>\n</tr>\n<tr>\n<td>Base Model</td>\n<td>Lite-Oute-1-65M-Instruct</td>\n<td>SmolLM-135M</td>\n<td>SmolLM-360M-Instruct</td>\n<td>Qwen2-0.5B-Instruct</td>\n<td>Qwen2-1.5B-Instruct</td>\n<td>SmolLM-1.7B</td>\n<td>Phi-3-mini-128k-instruct</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>L'addestramento del modello è stato condotto in due fasi:</p><ol><li><strong>HTML breve e semplice: </strong>In questa fase, la lunghezza massima della sequenza (HTML + markdown) è stata impostata a 32K token, con un totale di 1,5 miliardi di token di addestramento.</li><li><strong>HTML lungo e complesso</strong>: la lunghezza della sequenza è stata estesa a 128K token, con 1,2 miliardi di token di addestramento. Abbiamo implementato il meccanismo zigzag-ring-attention da <a href=\"https://github.com/zhuzilin/ring-flash-attention?ref=jina-ai-gmbh.ghost.io\">Ring Flash Attention di Zilin Zhu (2024)</a> per questa fase.</li></ol><p>Poiché i dati di addestramento includevano sequenze fino a 128K token, riteniamo che il modello possa supportare fino a 256K token senza problemi. Tuttavia, gestire 512K token potrebbe essere problematico, poiché estendere gli embedding posizionali RoPE a quattro volte la lunghezza della sequenza di addestramento potrebbe comportare un degrado delle prestazioni.</p><p>Per i modelli da 65M e 135M parametri, abbiamo osservato che potevano ottenere un comportamento di \"copia\" ragionevole, ma solo con sequenze brevi (meno di 1K token). All'aumentare della lunghezza dell'input, questi modelli faticavano a produrre output ragionevoli. Considerando che il codice HTML moderno può facilmente superare i 100K token, un limite di 1K token è ben lontano dall'essere sufficiente.</p><h3 id=\"degeneration-and-dull-loops\">Degenerazione e Loop Monotoni</h3><p>Una delle sfide principali che abbiamo incontrato è stata la degenerazione, in particolare sotto forma di ripetizione e loop. Dopo aver generato alcuni token, il modello iniziava a generare ripetutamente lo stesso token o rimaneva bloccato in un loop, ripetendo continuamente una breve sequenza di token fino a raggiungere la lunghezza massima consentita dell'output.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png\" class=\"kg-image\" alt=\"Dark themed coding script with repeated structural programming comments about data types, functions, and mathematical operati\" loading=\"lazy\" width=\"2000\" height=\"1278\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/image-1.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png 2040w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Un esempio di degenerazione si verifica quando il modello inizia con una normale generazione markdown ma improvvisamente si blocca in \"loop monotoni\", come indicato dalle frecce rosse.</span></figcaption></figure><p>Per affrontare questo problema:</p><ul><li>Abbiamo applicato la <a href=\"https://github.com/yxuansu/SimCTG?ref=jina-ai-gmbh.ghost.io\">ricerca contrastiva</a> come metodo di decodifica e incorporato la loss contrastiva durante l'addestramento. Dai nostri esperimenti, questo metodo ha ridotto efficacemente la generazione ripetitiva nella pratica.</li><li>Abbiamo implementato un semplice criterio di interruzione della ripetizione all'interno della pipeline del transformer. Questo criterio rileva automaticamente quando il modello inizia a ripetere i token e interrompe la decodifica in anticipo per evitare loop monotoni. Questa idea è stata ispirata da questa <a href=\"https://github.com/huggingface/transformers/issues/32902?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\">discussione</a>.</li></ul><h3 id=\"training-efficiency-on-long-inputs\">Efficienza di Addestramento su Input Lunghi</h3><p>Per mitigare il rischio di errori di memoria insufficiente (OOM) durante la gestione di input lunghi, abbiamo implementato l'inoltro del modello a blocchi. Questo approccio codifica l'input lungo con blocchi più piccoli, riducendo l'utilizzo della VRAM.</p><p>Abbiamo migliorato l'implementazione del data packing nel nostro framework di addestramento, basato su Transformers Trainer. Per ottimizzare l'efficienza dell'addestramento, più testi brevi (ad esempio 2K token) vengono concatenati in un'unica sequenza lunga (ad esempio 30K token), consentendo un addestramento senza padding. Tuttavia, nell'implementazione originale, alcuni esempi brevi venivano divisi in due sotto-testi e inclusi in diverse sequenze di addestramento lunghe. In questi casi, il secondo sotto-testo avrebbe perso il suo contesto (ad esempio il contenuto HTML grezzo nel nostro caso), portando a dati di addestramento corrotti. Questo costringe il modello a fare affidamento sui suoi parametri piuttosto che sul contesto di input, che riteniamo sia una fonte principale di allucinazione.</p><p>Alla fine, abbiamo selezionato i modelli da 0,5B e 1,5B per la pubblicazione. <strong>Il modello da 0,5B è il più piccolo in grado di ottenere il comportamento desiderato di \"copia selettiva\" su input con contesto lungo</strong>, mentre il modello da 1,5B è il più piccolo modello più grande che migliora significativamente le prestazioni senza raggiungere rendimenti decrescenti in relazione alla dimensione dei parametri.</p><h3 id=\"alternative-architecture-encoder-only-model\">Architettura Alternativa: Modello Solo Encoder</h3><p>Nei primi giorni di questo progetto, abbiamo anche esplorato l'utilizzo di un'architettura solo encoder per affrontare questo compito. Come menzionato in precedenza, il compito di conversione da HTML a Markdown sembra essere principalmente un compito di \"copia selettiva\". Data una coppia di addestramento (HTML grezzo e markdown), possiamo etichettare i token che esistono sia nell'input che nell'output come <code>1</code>, e il resto come <code>0</code>. Questo converte il problema in un compito di classificazione dei token, simile a quello utilizzato nel Named Entity Recognition (NER).</p><p>Sebbene questo approccio sembrasse logico, ha presentato sfide significative nella pratica. Prima di tutto, l'HTML grezzo da fonti del mondo reale è estremamente rumoroso e lungo, rendendo le etichette <code>1</code> estremamente sparse e quindi difficili da apprendere per il modello. In secondo luogo, la codifica della sintassi markdown speciale in uno schema <code>0-1</code> si è rivelata problematica, poiché simboli come <code>## title</code>, <code>*bold*</code>, e <code>| table |</code> non esistono nell'input HTML grezzo. In terzo luogo, i token di output non seguono sempre rigorosamente l'ordine dell'input. Si verificano spesso riordinamenti minori, in particolare con tabelle e link, rendendo difficile rappresentare tali comportamenti di riordinamento in un semplice schema <code>0-1</code>. Il riordinamento a breve distanza potrebbe potenzialmente essere gestito con programmazione dinamica o algoritmi di allineamento-warping introducendo etichette come <code>-1, -2, +1, +2</code> per rappresentare gli offset di distanza, trasformando il problema di classificazione binaria in un compito di classificazione token multi-classe.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png\" class=\"kg-image\" alt=\"Chart titled &quot;Token-Level DP Alignment (Horizontal)&quot; with tokens on the x-axis and alignment on the y-axis, highlighting best\" loading=\"lazy\" width=\"2000\" height=\"1436\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/output--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/output--2-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/output--2-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png 2179w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Utilizzo della programmazione dinamica per allineare l'HTML grezzo (asse X) e il markdown (asse Y) per creare etichette di addestramento a livello di token.</span></figcaption></figure><p>In sintesi, risolvere il problema con un'architettura solo encoder e trattarlo come un compito di classificazione dei token ha il suo fascino, soprattutto perché le sequenze di addestramento sono molto più brevi rispetto a un modello solo decoder, rendendolo più efficiente in termini di VRAM. Tuttavia, <strong>la sfida principale risiede nella preparazione di buoni dati di addestramento.</strong> Quando ci siamo resi conto che il tempo e lo sforzo spesi nel preprocessare i dati—utilizzando programmazione dinamica ed euristiche per creare sequenze di etichettatura perfette a livello di token—era eccessivo, abbiamo deciso di interrompere questo approccio.</p><h2 id=\"conclusion\">Conclusione</h2><p>Reader-LM è un innovativo small language model (SLM) progettato per l'estrazione e la pulizia dei dati dal web aperto. Ispirato da Jina Reader, il nostro obiettivo era creare una soluzione end-to-end basata su language model in grado di convertire HTML grezzo e rumoroso in markdown pulito. Al contempo, ci siamo concentrati sull'efficienza dei costi, mantenendo ridotte le dimensioni del modello per garantire che Reader-LM rimanga pratico e utilizzabile. <strong>È anche il primo modello decoder-only a lungo contesto addestrato presso Jina AI.</strong></p><p>Anche se inizialmente il compito può sembrare un semplice problema di \"copia selettiva\", convertire e pulire l'HTML in markdown è tutt'altro che semplice. Nello specifico, richiede che il modello eccella nel ragionamento basato sul contesto e consapevole della posizione, che richiede una dimensione maggiore dei parametri, in particolare negli hidden layer. In confronto, l'apprendimento della sintassi markdown è relativamente semplice.</p><p>Durante i nostri esperimenti, abbiamo anche scoperto che addestrare un SLM da zero è particolarmente impegnativo. Iniziare con un modello pre-addestrato e proseguire con l'addestramento specifico per il compito ha migliorato significativamente l'efficienza dell'addestramento. C'è ancora molto spazio per miglioramenti sia in termini di efficienza che di qualità: espandere la lunghezza del contesto, velocizzare il decoding e aggiungere il supporto per le istruzioni nell'input, che permetterebbe a Reader-LM di estrarre parti specifiche di una pagina web in markdown.</p>",
  "comment_id": "66dff7eba241f5000155d851",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/09/reader-lm-banner.jpg",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-09-10T09:40:27.000+02:00",
  "updated_at": "2024-09-20T14:09:30.000+02:00",
  "published_at": "2024-09-11T12:25:03.000+02:00",
  "custom_excerpt": "Reader-LM-0.5B and Reader-LM-1.5B are two novel small language models inspired by Jina Reader, designed to convert raw, noisy HTML from the open web into clean markdown.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "62e3d0ef9cd5ce003d5e49e2",
      "name": "Jina AI",
      "slug": "company",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
      "cover_image": null,
      "bio": "Creator of neural search, contributor to open source.",
      "website": "https://www.jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@JinaAI_",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/company/"
    }
  ],
  "tags": [
    {
      "id": "655b2782bb728c000101bed7",
      "name": "Press",
      "slug": "press",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
    }
  ],
  "primary_author": {
    "id": "62e3d0ef9cd5ce003d5e49e2",
    "name": "Jina AI",
    "slug": "company",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
    "cover_image": null,
    "bio": "Creator of neural search, contributor to open source.",
    "website": "https://www.jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@JinaAI_",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/company/"
  },
  "primary_tag": {
    "id": "655b2782bb728c000101bed7",
    "name": "Press",
    "slug": "press",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown/",
  "excerpt": "Reader-LM-0.5B e Reader-LM-1.5B sono due nuovi piccoli language model ispirati a Jina Reader, progettati per convertire l'HTML grezzo e confuso del web pubblico in markdown pulito.",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Technical screenshot displaying \"REAPER-LM-0.5B/1.5B\" with HTML source code for Jina's search grounding feature.",
  "feature_image_caption": null
}