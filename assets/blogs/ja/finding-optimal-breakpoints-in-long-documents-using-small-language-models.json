{
  "slug": "finding-optimal-breakpoints-in-long-documents-using-small-language-models",
  "id": "67126986708dbe00019249f2",
  "uuid": "b7e55a5d-f267-4a4a-b861-27221c0f3827",
  "title": "小規模言語モデルを使用した長文書における最適な分割点の発見",
  "html": "<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">これはチャンキングシリーズのパート III です。<b><strong style=\"white-space: pre-wrap;\">推奨される読む順序: </strong></b><a href=\"https://jina.ai/news/late-chunking-in-long-context-embedding-models/?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">パート I</strong></b></a><b><strong style=\"white-space: pre-wrap;\">、</strong></b><a href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">パート II</strong></b></a><b><strong style=\"white-space: pre-wrap;\">、</strong></b><a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">研究論文</strong></b></a><b><strong style=\"white-space: pre-wrap;\">、パート III。</strong></b></div></div><p>前回の投稿では、チャンキングの課題を探り、チャンクの埋め込み時のコンテキスト損失を減らすのに役立つ<a href=\"https://jina.ai/news/late-chunking-in-long-context-embedding-models/?ref=jina-ai-gmbh.ghost.io\">レイトチャンキングの概念を紹介</a>しました。今回の投稿では、もう1つの課題である最適な分割点の発見に焦点を当てます。<a href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii/?ref=jina-ai-gmbh.ghost.io#late-chunking-is-resilient-to-poor-boundary-cues\" rel=\"noreferrer\">私たちのレイトチャンキング戦略は不適切な境界に対してかなりの耐性があることが証明されていますが</a>、これは境界を無視できるということではありません。境界は人間と LLM の両方の読みやすさにとって依然として重要です。私たちの視点は次の通りです：分割点を決定する際、意味やコンテキストの損失を心配することなく、読みやすさに完全に集中できます。レイトチャンキングは良い分割点も悪い分割点も処理できるので、読みやすさが主な関心事となります。</p><p>これを踏まえて、長文書を意味的一貫性を保ちながら分割し、複雑なコンテンツ構造を処理するように特別に設計された3つの小規模言語モデルを訓練しました。それらは:</p><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/text-seg-lm-qwen2-0.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/text-seg-lm-qwen2-0.5b · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://huggingface.co/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://cdn-thumbnails.huggingface.co/social-thumbnails/models/jinaai/text-seg-lm-qwen2-0.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>simple-qwen-0.5</span></code><span style=\"white-space: pre-wrap;\">：文書の構造要素に基づいてテキストを分割します。</span></p></figcaption></figure><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/text-seg-lm-qwen2-0.5b-cot-topic-chunking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/text-seg-lm-qwen2-0.5b-cot-topic-chunking · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://huggingface.co/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://cdn-thumbnails.huggingface.co/social-thumbnails/models/jinaai/text-seg-lm-qwen2-0.5b-cot-topic-chunking.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>topic-qwen-0.5</span></code><span style=\"white-space: pre-wrap;\">：テキスト内のトピックに基づいてテキストを分割します。</span></p></figcaption></figure><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/text-seg-lm-qwen2-0.5b-summary-chunking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/text-seg-lm-qwen2-0.5b-summary-chunking · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://huggingface.co/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://cdn-thumbnails.huggingface.co/social-thumbnails/models/jinaai/text-seg-lm-qwen2-0.5b-summary-chunking.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>summary-qwen-0.5</span></code><span style=\"white-space: pre-wrap;\">：各セグメントの要約を生成します。</span></p></figcaption></figure><p>この投稿では、なぜこのモデルを開発したのか、3つのバリアントにどのようにアプローチしたのか、そして<a href=\"https://www.notion.so/Advancing-Segmentation-Strategies-in-RAG-with-a-Custom-Small-Language-Model-Restructure-638b84ae461d412eb6889cfa7f54cce1?pvs=21&ref=jina-ai-gmbh.ghost.io\">Jina AI の Segmenter API</a> に対してどのようにベンチマークを行ったのかについて説明します。最後に、学んだことと今後の展望を共有します。</p><h2 id=\"segmentation-problem\">セグメンテーションの問題</h2><p>セグメンテーションは RAG システムの中核要素です。長文書をどのように一貫性のある管理可能なセグメントに分割するかは、検索と生成の両方のステップの品質に直接影響を与え、回答の関連性から要約の品質まで、すべてに影響を及ぼします。従来のセグメンテーション手法は適度な結果を生み出してきましたが、限界がないわけではありません。</p><p><a href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii/?ref=jina-ai-gmbh.ghost.io\">前回の投稿</a>を言い換えると：</p><blockquote>長文書をセグメント化する際の重要な課題は、セグメントをどこで作成するかを決定することです。これは固定トークン長、一定数の文、または正規表現や意味的セグメンテーションモデルなどのより高度な手法を使用して行うことができます。正確なセグメント境界を確立することは、検索結果の読みやすさを向上させるだけでなく、RAG システムで LLM に提供されるセグメントが正確で十分であることを保証するために重要です。</blockquote><p>レイトチャンキングは検索パフォーマンスを向上させますが、<strong>RAG アプリケーションでは、可能な限りすべてのセグメントがランダムなテキストの断片ではなく、それ自体で意味を持つことを確保することが重要です。</strong>LLM は正確な応答を生成するために一貫性があり、よく構造化されたデータに依存しています。セグメントが不完全であったり意味が欠けている場合、レイトチャンキングの利点があるにもかかわらず、LLM はコンテキストと正確性に苦労し、全体的なパフォーマンスに影響を与える可能性があります。つまり、レイトチャンキングを使用するかどうかにかかわらず、効果的な RAG システムを構築するには堅実なセグメンテーション戦略が不可欠です（後のベンチマークセクションで見るように）。</p><p>改行や文などの単純な境界で内容を分割する方法や、厳密なトークンベースのルールを使用する従来のセグメンテーション手法は、同じような限界に直面します。どちらのアプローチも意味的な境界を考慮せず、あいまいなトピックの処理に苦労し、断片化されたセグメントにつながります。これらの課題に対応するため、私たちはセグメンテーション専用の小規模言語モデルを開発・訓練し、トピックの変化を捉え、一貫性を保ちながら、様々なタスクで効率的で適応可能なものとなるように設計しました。</p><h2 id=\"why-small-language-model\">なぜ小規模言語モデルなのか？</h2><p>私たちは、従来のセグメンテーション技術で遭遇した特定の制限、特にコードスニペットやテーブル、リスト、数式などの複雑な構造を処理する際の制限に対応するために、Small Language Model (SLM) を開発しました。トークン数や厳格な構造的ルールに依存する従来のアプローチでは、意味的に一貫性のあるコンテンツの整合性を維持することが困難でした。例えば、コードスニペットは頻繁に複数の部分に分割され、そのコンテキストが破壊され、下流のシステムが正確に理解または検索することが困難になっていました。</p><p>専門的な SLM を訓練することで、これらの意味のある境界を知的に認識して保持し、関連要素を一緒に保つことができるモデルの作成を目指しました。これは RAG システムでの検索品質を向上させるだけでなく、一貫性のある文脈的に関連性のあるセグメントの維持が重要な要約や質問応答などの下流タスクも向上させます。SLM アプローチは、厳格な境界を持つ従来のセグメンテーション手法では単純に提供できない、より適応性が高く、タスク固有のソリューションを提供します。</p><h2 id=\"training-slms-three-approaches\">SLM の訓練：3つのアプローチ</h2><p>私たちは SLM の3つのバージョンを訓練しました：</p><ul><li><code>simple-qwen-0.5</code> は最も単純なモデルで、文書の構造要素に基づいて境界を識別するように設計されています。その単純さは、基本的なセグメンテーションニーズに対する効率的なソリューションとなっています。</li><li><code>topic-qwen-0.5</code> は Chain-of-Thought 推論に触発され、「第二次世界大戦の開始」などのテキスト内のトピックを識別し、これらのトピックを使用してセグメント境界を定義することで、セグメンテーションをさらに一歩進めています。このモデルは各セグメントがトピック的に一貫していることを確保し、複雑な多トピック文書に適しています。初期のテストでは、人間の直感に近い方法でコンテンツを分割することに優れていることが示されました。</li><li><code>summary-qwen-0.5</code> はテキストの境界を識別するだけでなく、各セグメントの要約も生成します。セグメントの要約は RAG アプリケーションで非常に有利です。特に長文書の質問応答などのタスクで有効ですが、訓練時により多くのデータを必要とするというトレードオフがあります。</li></ul><p>すべてのモデルは<em>セグメントヘッド</em>のみを返します。これは各セグメントの切り詰めたバージョンです。モデルは入力コンテンツを単にコピーするのではなく、意味的な遷移に焦点を当てることで、境界検出と一貫性を向上させる重要なポイントやサブトピックを出力します。セグメントを取得する際、文書テキストはそれらのセグメントヘッドに基づいて分割され、それに応じて完全なセグメントが再構築されます。</p><h3 id=\"dataset\">データセット</h3><p>私たちは<a href=\"https://github.com/koomri/text-segmentation?ref=jina-ai-gmbh.ghost.io\">wiki727k</a> データセットを使用しました。これは Wikipedia 記事から抽出された構造化テキストスニペットの大規模なコレクションです。イントロダクション、セクション、サブセクションなど、Wikipedia 記事の異なる部分を表す727,000以上のセクションが含まれています。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/koomri/text-segmentation?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub - koomri/text-segmentation: Implementation of the paper: Text Segmentation as a Supervised Learning Task</div><div class=\"kg-bookmark-description\">論文の実装：Text Segmentation as a Supervised Learning Task - koomri/text-segmentation</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">koomri</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://opengraph.githubassets.com/a0a75db005774d424366f3fa2d4c70930927a0b2d8032ef3c04cb0f3beebcb8e/koomri/text-segmentation\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><h3 id=\"data-augmentation\">データ拡張</h3><p>各モデルバリアントのトレーニングペアを生成するため、GPT-4 を使用してデータを拡張しました。トレーニングデータセット内の各記事に対して、以下のプロンプトを送信しました：</p><pre><code class=\"language-python\">f\"\"\"\nGenerate a five to ten words topic and a one sentence summary for this chunk of text.\n```\n{text}\n```\nMake sure the topic is concise and the summary covers the main topic as much as possible.\n\nPlease respond in the following format:\n```\nTopic: ...\nSummary: ...\n```\n\nDirectly respond with the required topic and summary, do not include any other details, and do not surround your response with quotes, backticks or other separators.\n   \"\"\".strip()</code></pre><p>単純な分割を使用して各記事からセクションを生成し、<code>\\\\n\\\\n\\\\n</code>で分割し、さらに<code>\\\\n\\\\n</code>で分割して以下のようになりました（この例では、Common Gateway Interface に関する記事）：</p><pre><code>[\n    [\n      \"In computing, Common Gateway Interface (CGI) offers a standard protocol for web servers to execute programs that execute like Console applications (also called Command-line interface programs) running on a server that generates web pages dynamically.\",\n      \"Such programs are known as \\\\\"CGI scripts\\\\\" or simply as \\\\\"CGIs\\\\\".\",\n      \"The specifics of how the script is executed by the server are determined by the server.\",\n      \"In the common case, a CGI script executes at the time a request is made and generates HTML.\"\n    ],\n    [\n      \"In 1993 the National Center for Supercomputing Applications (NCSA) team wrote the specification for calling command line executables on the www-talk mailing list; however, NCSA no longer hosts the specification.\",\n      \"The other Web server developers adopted it, and it has been a standard for Web servers ever since.\",\n      \"A work group chaired by Ken Coar started in November 1997 to get the NCSA definition of CGI more formally defined.\",\n      \"This work resulted in RFC 3875, which specified CGI Version 1.1.\",\n      \"Specifically mentioned in the RFC are the following contributors: \\\\n1. Alice Johnson\\\\n2. Bob Smith\\\\n3. Carol White\\\\n4. David Nguyen\\\\n5. Eva Brown\\\\n6. Frank Lee\\\\n7. Grace Kim\\\\n8. Henry Carter\\\\n9. Ingrid Martinez\\\\n10. Jack Wilson\",\n      \"Historically CGI scripts were often written using the C language.\",\n      \"RFC 3875 \\\\\"The Common Gateway Interface (CGI)\\\\\" partially defines CGI using C, as in saying that environment variables \\\\\"are accessed by the C library routine getenv() or variable environ\\\\\".\"\n    ],\n    [\n      \"CGI is often used to process inputs information from the user and produce the appropriate output.\",\n      \"An example of a CGI program is one implementing a Wiki.\",\n      \"The user agent requests the name of an entry; the Web server executes the CGI; the CGI program retrieves the source of that entry's page (if one exists), transforms it into HTML, and prints the result.\",\n      \"The web server receives the input from the CGI and transmits it to the user agent.\",\n      \"If the \\\\\"Edit this page\\\\\" link is clicked, the CGI populates an HTML textarea or other editing control with the page's contents, and saves it back to the server when the user submits the form in it.\\\\n\",\n      \"\\\\n# CGI script to handle editing a page\\\\ndef handle_edit_request(page_content):\\\\n    html_form = f'''\\\\n    &lt;html&gt;\\\\n    &lt;body&gt;\\\\n        &lt;form action=\\\\\"/save_page\\\\\" method=\\\\\"post\\\\\"&gt;\\\\n            &lt;textarea name=\\\\\"page_content\\\\\" rows=\\\\\"20\\\\\" cols=\\\\\"80\\\\\"&gt;\\\\n            {page_content}\\\\n            &lt;/textarea&gt;\\\\n            &lt;br&gt;\\\\n            &lt;input type=\\\\\"submit\\\\\" value=\\\\\"Save\\\\\"&gt;\\\\n        &lt;/form&gt;\\\\n    &lt;/body&gt;\\\\n    &lt;/html&gt;\\\\n    '''\\\\n    return html_form\\\\n\\\\n# Example usage\\\\npage_content = \\\\\"Existing content of the page.\\\\\"\\\\nhtml_output = handle_edit_request(page_content)\\\\nprint(\\\\\"Generated HTML form:\\\\\")\\\\nprint(html_output)\\\\n\\\\ndef save_page(page_content):\\\\n    with open(\\\\\"page_content.txt\\\\\", \\\\\"w\\\\\") as file:\\\\n        file.write(page_content)\\\\n    print(\\\\\"Page content saved.\\\\\")\\\\n\\\\n# Simulating form submission\\\\nsubmitted_content = \\\\\"Updated content of the page.\\\\\"\\\\nsave_page(submitted_content)\"\n    ],\n    [\n      \"Calling a command generally means the invocation of a newly created process on the server.\",\n      \"Starting the process can consume much more time and memory than the actual work of generating the output, especially when the program still needs to be interpreted or compiled.\",\n      \"If the command is called often, the resulting workload can quickly overwhelm the server.\",\n      \"The overhead involved in process creation can be reduced by techniques such as FastCGI that \\\\\"prefork\\\\\" interpreter processes, or by running the application code entirely within the web server, using extension modules such as mod_perl or mod_php.\",\n      \"Another way to reduce the overhead is to use precompiled CGI programs, e.g.\",\n      \"by writing them in languages such as C or C++, rather than interpreted or compiled-on-the-fly languages such as Perl or PHP, or by implementing the page generating software as a custom webserver module.\",\n      \"Several approaches can be adopted for remedying this: \\\\n1. Implementing stricter regulations\\\\n2. Providing better education and training\\\\n3. Enhancing technology and infrastructure\\\\n4. Increasing funding and resources\\\\n5. Promoting collaboration and partnerships\\\\n6. Conducting regular audits and assessments\",\n      \"The optimal configuration for any Web application depends on application-specific details, amount of traffic, and complexity of the transaction; these tradeoffs need to be analyzed to determine the best implementation for a given task and time budget.\"\n    ]\n  ],\n</code></pre><p>その後、セクション、トピック、要約を含む JSON 構造を生成しました：</p><pre><code>{\n  \"sections\": [\n    [\n      \"In computing, Common Gateway Interface (CGI) offers a standard protocol for web servers to execute programs that execute like Console applications (also called Command-line interface programs) running on a server that generates web pages dynamically.\",\n      \"Such programs are known as \\\\\"CGI scripts\\\\\" or simply as \\\\\"CGIs\\\\\".\",\n      \"The specifics of how the script is executed by the server are determined by the server.\",\n      \"In the common case, a CGI script executes at the time a request is made and generates HTML.\"\n    ],\n    [\n      \"In 1993 the National Center for Supercomputing Applications (NCSA) team wrote the specification for calling command line executables on the www-talk mailing list; however, NCSA no longer hosts the specification.\",\n      \"The other Web server developers adopted it, and it has been a standard for Web servers ever since.\",\n      \"A work group chaired by Ken Coar started in November 1997 to get the NCSA definition of CGI more formally defined.\",\n      \"This work resulted in RFC 3875, which specified CGI Version 1.1.\",\n      \"Specifically mentioned in the RFC are the following contributors: \\\\n1. Alice Johnson\\\\n2. Bob Smith\\\\n3. Carol White\\\\n4. David Nguyen\\\\n5. Eva Brown\\\\n6. Frank Lee\\\\n7. Grace Kim\\\\n8. Henry Carter\\\\n9. Ingrid Martinez\\\\n10. Jack Wilson\",\n      \"Historically CGI scripts were often written using the C language.\",\n      \"RFC 3875 \\\\\"The Common Gateway Interface (CGI)\\\\\" partially defines CGI using C, as in saying that environment variables \\\\\"are accessed by the C library routine getenv() or variable environ\\\\\".\"\n    ],\n    [\n      \"CGI is often used to process inputs information from the user and produce the appropriate output.\",\n      \"An example of a CGI program is one implementing a Wiki.\",\n      \"The user agent requests the name of an entry; the Web server executes the CGI; the CGI program retrieves the source of that entry's page (if one exists), transforms it into HTML, and prints the result.\",\n      \"The web server receives the input from the CGI and transmits it to the user agent.\",\n      \"If the \\\\\"Edit this page\\\\\" link is clicked, the CGI populates an HTML textarea or other editing control with the page's contents, and saves it back to the server when the user submits the form in it.\\\\n\",\n      \"\\\\n# CGI script to handle editing a page\\\\ndef handle_edit_request(page_content):\\\\n    html_form = f'''\\\\n    &lt;html&gt;\\\\n    &lt;body&gt;\\\\n        &lt;form action=\\\\\"/save_page\\\\\" method=\\\\\"post\\\\\"&gt;\\\\n            &lt;textarea name=\\\\\"page_content\\\\\" rows=\\\\\"20\\\\\" cols=\\\\\"80\\\\\"&gt;\\\\n            {page_content}\\\\n            &lt;/textarea&gt;\\\\n            &lt;br&gt;\\\\n            &lt;input type=\\\\\"submit\\\\\" value=\\\\\"Save\\\\\"&gt;\\\\n        &lt;/form&gt;\\\\n    &lt;/body&gt;\\\\n    &lt;/html&gt;\\\\n    '''\\\\n    return html_form\\\\n\\\\n# Example usage\\\\npage_content = \\\\\"Existing content of the page.\\\\\"\\\\nhtml_output = handle_edit_request(page_content)\\\\nprint(\\\\\"Generated HTML form:\\\\\")\\\\nprint(html_output)\\\\n\\\\ndef save_page(page_content):\\\\n    with open(\\\\\"page_content.txt\\\\\", \\\\\"w\\\\\") as file:\\\\n        file.write(page_content)\\\\n    print(\\\\\"Page content saved.\\\\\")\\\\n\\\\n# Simulating form submission\\\\nsubmitted_content = \\\\\"Updated content of the page.\\\\\"\\\\nsave_page(submitted_content)\"\n    ],\n    [\n      \"Calling a command generally means the invocation of a newly created process on the server.\",\n      \"Starting the process can consume much more time and memory than the actual work of generating the output, especially when the program still needs to be interpreted or compiled.\",\n      \"If the command is called often, the resulting workload can quickly overwhelm the server.\",\n      \"The overhead involved in process creation can be reduced by techniques such as FastCGI that \\\\\"prefork\\\\\" interpreter processes, or by running the application code entirely within the web server, using extension modules such as mod_perl or mod_php.\",\n      \"Another way to reduce the overhead is to use precompiled CGI programs, e.g.\",\n      \"by writing them in languages such as C or C++, rather than interpreted or compiled-on-the-fly languages such as Perl or PHP, or by implementing the page generating software as a custom webserver module.\",\n      \"Several approaches can be adopted for remedying this: \\\\n1. Implementing stricter regulations\\\\n2. Providing better education and training\\\\n3. Enhancing technology and infrastructure\\\\n4. Increasing funding and resources\\\\n5. Promoting collaboration and partnerships\\\\n6. Conducting regular audits and assessments\",\n      \"The optimal configuration for any Web application depends on application-specific details, amount of traffic, and complexity of the transaction; these tradeoffs need to be analyzed to determine the best implementation for a given task and time budget.\"\n    ]\n  ],\n  \"topics\": [\n    \"Web サーバーにおける Common Gateway Interface\",\n    \"CGI の歴史と標準化\",\n    \"Web ページ編集用の CGI スクリプト\",\n    \"コマンド実行におけるWeb サーバーのオーバーヘッド削減\"\n  ],\n  \"summaries\": [\n    \"CGI は Web サーバーが動的なウェブページを生成するプログラムを実行するためのプロトコルを提供します。\",\n    \"NCSA が1993年に CGI を定義し、Web サーバーの標準として採用され、後に Ken Coar 議長のもと RFC 3875 として正式化されました。\",\n    \"このテキストは、CGI スクリプトが HTML フォームを通じてウェブページの内容を編集・保存する方法を説明しています。\",\n    \"頻繁なコマンド実行によるサーバーのオーバーヘッドを最小限に抑えるため、プロセスのプリフォーク、プリコンパイル済み CGI プログラムの使用、カスタム Web サーバーモジュールの実装などの技術について説明しています。\"\n  ]\n}\n</code></pre><p>また、データをシャッフルしたり、ランダムな文字/単語/文字を追加したり、句読点をランダムに削除したり、そして<em>必ず</em>改行文字を削除することでノイズを追加しました。</p><p>これらはすべて良いモデルを開発する上で一定の効果がありますが、それには限界があります。本当に全力を尽くすためには、コードスニペットを壊すことなく、モデルが一貫した塊を作成する必要がありました。そのために、GPT-4o で生成したコード、数式、リストでデータセットを拡張しました。</p><h3 id=\"the-training-setup\">トレーニングのセットアップ</h3><p>モデルのトレーニングには、以下のセットアップを実装しました：</p><ul><li><strong>フレームワーク</strong>：Hugging Face の <code>transformers</code> ライブラリを <code>Unsloth</code> と統合してモデルの最適化を行いました。これはメモリ使用量を最適化し、トレーニングを高速化するために重要で、大規模なデータセットで小規模なモデルを効果的に訓練することを可能にしました。</li><li><strong>オプティマイザとスケジューラ</strong>：初期エポックでトレーニングプロセスを安定させるため、線形学習率スケジュールとウォームアップステップを備えた AdamW オプティマイザを使用しました。</li><li><strong>実験の追跡</strong>：すべてのトレーニング実験を <a href=\"https://wandb.ai/?ref=jina-ai-gmbh.ghost.io\">Weights & Biases</a> で追跡し、トレーニングと検証のロス、学習率の変化、モデル全体のパフォーマンスなどの主要な指標を記録しました。このリアルタイムの追跡により、モデルの進捗状況を把握でき、学習成果を最適化するために必要に応じて素早い調整が可能になりました。</li></ul><h3 id=\"the-training-itself\">トレーニング自体</h3><p><a href=\"https://huggingface.co/Qwen/Qwen2-0.5B-Instruct?ref=jina-ai-gmbh.ghost.io\"><code>qwen2-0.5b-instruct</code></a> をベースモデルとして使用し、異なるセグメンテーション戦略を念頭に置いた 3 つのバリエーションの SLM を Unsloth でトレーニングしました。サンプルとして、wiki727k の記事のテキストと、トレーニングするモデルに応じて得られた <code>sections</code>、<code>topics</code>、または <code>summaries</code>（上記の「データ拡張」セクションで言及）からなるトレーニングペアを使用しました。</p><ul><li><code><strong>simple-qwen-0.5</strong></code>：10,000 サンプルで 5,000 ステップトレーニングを行い、迅速な収束を達成し、テキストの一貫したセクション間の境界を効果的に検出しました。トレーニングロスは 0.16 でした。</li><li><code><strong>topic-qwen-0.5</strong></code>：<code>simple-qwen-0.5</code> と同様に、10,000 サンプルで 5,000 ステップトレーニングを行い、トレーニングロス 0.45 を達成しました。</li><li><code><strong>summary-qwen-0.5</strong></code>：30,000 サンプルで 15,000 ステップトレーニングを行いました。このモデルは有望な結果を示しましたが、トレーニング中のロスが高く（0.81）、その潜在能力を十分に発揮するにはより多くのデータ（元のサンプル数の約 2 倍）が必要であることを示唆しています。</li></ul><h2 id=\"the-segments-themselves\">セグメント自体について</h2><p>各セグメンテーション戦略と Jina の Segmenter API による連続する 3 つのセグメントの例を示します。これらのセグメントを生成するために、まず <a href=\"https://jina.ai/reader/?ref=jina-ai-gmbh.ghost.io\">Jina Reader</a> を使用して Jina AI ブログの投稿をプレーンテキストとしてスクレイピングし（ヘッダー、フッターなどのすべてのページデータを含む）、その後各セグメンテーション手法に渡しました。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/can-embedding-reranker-models-compare-numbers/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Can Embedding/Reranker Models Compare Numbers?</div><div class=\"kg-bookmark-description\">A lot of LLMs can't figure out that 9.11 is actually smaller than 9.9. Can our embedding and reranker models do any better?</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/number-heading.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><h3 id=\"jina-segmenter-api\">Jina Segmenter API</h3><p>Jina Segmenter API は投稿の分割に非常に細かいアプローチを取り、<code>\\n</code>、<code>\\t</code> などの文字で分割して、しばしば非常に小さなセグメントに分割しました。最初の 3 つを見ただけでも、ウェブサイトのナビゲーションバーから <code>search\\\\n</code>、<code>notifications\\\\n</code>、<code>NEWS\\\\n</code> を抽出しましたが、投稿の内容に関連するものは何も抽出されませんでした：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-1.png\" class=\"kg-image\" alt=\"Minimalist navigation bar with &quot;NEWS&quot;, &quot;PRODUCTS&quot;, and &quot;COMPANY&quot; text on a black background, accented by colorful stripes to \" loading=\"lazy\" width=\"1164\" height=\"68\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-1.png 1164w\" sizes=\"(min-width: 720px) 720px\"></figure><p>さらに進むと、ようやくブログ投稿の実際の内容からのセグメントが得られましたが、それぞれのコンテキストはほとんど保持されていませんでした：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-2.png\" class=\"kg-image\" alt=\"Webpage discussing if embedding/reranker models can compare numbers, with a grid of numbered circles and references to an ICM\" loading=\"lazy\" width=\"1164\" height=\"1180\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-2.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-2.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-2.png 1164w\" sizes=\"(min-width: 720px) 720px\"></figure><p>（公平を期すため、Segmenter API については他のモデルよりも多くのチャンクを示しました。そうしなければ、意味のあるセグメントがほとんど表示されなかったためです）</p><h3 id=\"simple-qwen-05\"><code>simple-qwen-0.5</code></h3><p><code>simple-qwen-0.5</code> はブログ投稿を意味的構造に基づいて分解し、一貫した意味を持つより長いセグメントを抽出しました：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-3.png\" class=\"kg-image\" alt=\"Webpage screenshot with green background, top navigation bar, scientific graphs, and headers discussing model number comparis\" loading=\"lazy\" width=\"1164\" height=\"4590\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-3.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-3.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-3.png 1164w\" sizes=\"(min-width: 720px) 720px\"></figure><h3 id=\"topic-qwen-05\"><code>topic-qwen-0.5</code></h3><p><code>topic-qwen-0.5</code> はまず文書の内容に基づいてトピックを特定し、それらのトピックに基づいて文書をセグメント化しました：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-4.png\" class=\"kg-image\" alt=\"Webpage showcasing a scientific paper titled &quot;Can Embedding/Keras Models Compare Numbers?&quot; featuring plots, text blocks, and \" loading=\"lazy\" width=\"1164\" height=\"4526\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-4.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-4.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-4.png 1164w\" sizes=\"(min-width: 720px) 720px\"></figure><h3 id=\"summary-qwen-05\"><code>summary-qwen-0.5</code></h3><p><code>summary-qwen-0.5</code> はセグメントの境界を特定し、各セグメント内の内容の要約を生成しました：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-5.png\" class=\"kg-image\" alt=\"Green and gold-themed academic webpage discussing embedding/reranker models and experiment setup.\" loading=\"lazy\" width=\"1164\" height=\"3734\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-5.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-5.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-5.png 1164w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"benchmarking-the-models\">モデルのベンチマーク</h2><p>モデルのパフォーマンスをベンチマークするために、Jina AI ブログから 8 つのブログ投稿をスクレイピングし、GPT-4o を使用して 6 つの質問と正解を生成しました。</p><p>Jina Segmenter API を含む各セグメンテーション手法をこれらのブログ投稿に適用し、その結果得られたセグメントに対して <a href=\"https://jina.ai/embeddings?ref=jina-ai-gmbh.ghost.io\"><code>jina-embeddings-v3</code></a> を使用して、後期チャンキングやリランキングを行わずに埋め込みを生成しました。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/jina-embeddings-v3-a-frontier-multilingual-embedding-model/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Jina Embeddings v3: A Frontier Multilingual Embedding Model</div><div class=\"kg-bookmark-description\">jina-embeddings-v3 is a frontier multilingual text embedding model with 570M parameters and 8192 token-length, outperforming the latest proprietary embeddings from OpenAI and Cohere on MTEB.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/v3banner.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>その後、各セグメントセットを別々にインデックス化し、前に生成した質問を使って各インデックスに対して RAG システムでクエリを実行しました。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">比較を公平に保つため、<code spellcheck=\"false\" style=\"white-space: pre-wrap;\">topic-qwen-0.5</code> と <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">summary-qwen-0.5</code> のテスト時には、生成されたサマリーやトピックは含めず、セグメント自体のみをインデックス化しました。この追加データをインデックス化すれば、さらにパフォーマンスが向上する可能性があります。</div></div><p>パフォーマンスを測定するために、各分割方法のインデックスから生成された回答を、<a href=\"https://en.wikipedia.org/wiki/ROUGE_(metric)?ref=jina-ai-gmbh.ghost.io\">ROUGE-L 評価</a>の F1 スコアを使用して正解と比較しました。スコアが高いほど、パフォーマンスが良いことを示します。</p><p>例えば、「<code>jina-embeddings-v2-base-en</code> モデルの数値比較能力に影響を与える要因は何か？」という質問に対して、以下のような回答を得ました：</p><h3 id=\"ground-truth-generated-by-gpt-4o-from-the-full-post-text\">正解（全文から GPT-4o が生成）：</h3><pre><code>\"The two key factors are tokenization and training data. Tokenization determines how numbers are segmented into tokens, and training data influences numerical reasoning abilities.\"\n</code></pre><h3 id=\"jina-segmenter-api-score-0166667\">Jina Segmenter API（スコア：0.166667）</h3><pre><code>\"The context does not provide specific factors that impact the numerical comparison abilities of the jina-embeddings-v2-base-en model.\"\n</code></pre><h3 id=\"simple-qwen-05-score-0279070\"><code>simple-qwen-0.5</code>（スコア：0.279070）</h3><pre><code>\"The numerical comparison abilities of the jina-embeddings-v2-base-en model are impacted by tokenization and training data.\"\n</code></pre><h3 id=\"topic-qwen-05-score-0190476\"><code>topic-qwen-0.5</code>（スコア：0.190476）</h3><pre><code>\"The numerical comparison abilities of the jina-embeddings-v2-base-en model are impacted by factors such as tokenization and its ability to handle different numerical formats, including small integers, large numbers, floats, negative numbers, currency, dates, and times.\"\n</code></pre><h3 id=\"summary-qwen-05-0318182\"><code>summary-qwen-0.5</code>（0.318182）</h3><pre><code>\"The factors impacting the numerical comparison abilities of the jina-embeddings-v2-base-en model are tokenization and training data.\"\n</code></pre><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">なぜ </strong></b><b><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><strong>topic-qwen-0.5</strong></code></b><b><strong style=\"white-space: pre-wrap;\"> のスコアがこんなに低いのか？</strong></b><br>これは主にモデルに尋ねた特定の質問に基づく偶然の結果です。下の表に示されているように、<code spellcheck=\"false\" style=\"white-space: pre-wrap;\">topic-qwen-0.5</code> の<i><em class=\"italic\" style=\"white-space: pre-wrap;\">平均</em></i> ROUGE スコアは、すべての分割手法の中で最も高くなっています。</div></div><p>また、各手法の速度（セグメントの生成と埋め込みにかかる時間を計測）とディスク容量（埋め込み数に <code>jina-embeddings-v3</code> の 1024 次元の単一埋め込みのサイズを掛けて推定）も評価しました。これにより、異なる分割戦略の精度と効率性の両方を評価することができました。</p><h2 id=\"key-findings\">主な発見</h2><p>モデルのバリエーションを互いに、そして Jina の Segmenter API と比較テストした結果、新しいモデルは特にトピック分割において、すべての 3 つの手法で改善されたスコアを示しました：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-7.png\" class=\"kg-image\" alt=\"Bar chart comparing average ROUGE scores for Jina Segmenter, Simple, COATopic, and Summary Segmentation.\" loading=\"lazy\" width=\"1690\" height=\"1079\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-7.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-7.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/10/image-7.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-7.png 1690w\" sizes=\"(min-width: 720px) 720px\"></figure>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th><strong>Segmentation Method</strong></th>\n<th><strong>Average ROUGE Score</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Jina Segmenter</td>\n<td>0.352126</td>\n</tr>\n<tr>\n<td><code>simple-qwen-0.5</code></td>\n<td>0.386096</td>\n</tr>\n<tr>\n<td><code>topic-qwen-0.5</code></td>\n<td><strong>0.398340</strong></td>\n</tr>\n<tr>\n<td><code>summary-qwen-0.5</code></td>\n<td>0.328143</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">なぜ <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">summary-qwen-0.5</code> の ROUGE スコアは <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">topic-qwen-0.5</code> より低いのでしょうか？端的に言えば、<code spellcheck=\"false\" style=\"white-space: pre-wrap;\">summary-qwen-0.5</code> はトレーニング中により高い損失を示し、より良い結果を得るにはさらなるトレーニングが必要であることが明らかになりました。これは今後の実験のテーマとなるかもしれません。</div></div><p>ただし、セグメントの埋め込みのコンテキストの関連性を高め、より関連性の高い結果を提供する <code>jina-embeddings-v3</code> の遅延チャンキング機能を使用した結果を確認するのも興味深いでしょう。これは将来のブログ投稿のテーマになるかもしれません。</p><p>速度に関しては、後者が API である一方で、3 つのモデルを Nvidia 3090 GPU で実行したため、新しいモデルと Jina Segmenter を比較するのは難しい場合があります。Segmenter API の高速な分割ステップで得られたパフォーマンスの向上は、多数のセグメントの埋め込みを生成する必要性によってすぐに相殺されてしまいます：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-8.png\" class=\"kg-image\" alt=\"Bar chart showing time for text segmentation methods: Jina Segmenter, Simple, CoT Topic, and Summary Segmentation, with notab\" loading=\"lazy\" width=\"1682\" height=\"1079\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-8.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-8.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/10/image-8.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-8.png 1682w\" sizes=\"(min-width: 720px) 720px\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-9.png\" class=\"kg-image\" alt=\"Vertical bar chart displaying the embedding times for Jina Segmenter, Simple, CoT Topic, and Summary Segmentation.\" loading=\"lazy\" width=\"1698\" height=\"1079\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-9.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-9.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/10/image-9.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-9.png 1698w\" sizes=\"(min-width: 720px) 720px\"></figure><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">注意事項</strong></b><br>• 両グラフで異なる Y 軸を使用しています。これほど異なる時間枠を 1 つのグラフまたは一貫した Y 軸で表示することは現実的ではありませんでした。<br>• これは純粋な実験として行ったため、埋め込みの生成時にバッチ処理を使用しませんでした。バッチ処理を行えば、すべての手法で大幅な速度向上が見込めます。</div></div><p>当然、セグメントが多いということは、埋め込みも多いということです。そしてこれらの埋め込みは多くの容量を占めます：テストに使用した 8 つのブログ投稿の埋め込みは、Segmenter API では 21 MB 以上を占めましたが、Summary Segmentation では 468 KB と軽量でした。これに加えて、私たちのモデルからの高い ROUGE スコアは、より少ないセグメントでより良いセグメントが得られることを意味し、コストを節約しながらパフォーマンスを向上させます：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-6.png\" class=\"kg-image\" alt=\"Vertical bar chart comparing total embedding size of segmentation methods, with &quot;Jina Segmenter&quot; significantly higher at 20.0\" loading=\"lazy\" width=\"1690\" height=\"1079\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/10/image-6.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/10/image-6.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/10/image-6.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/10/image-6.png 1690w\" sizes=\"(min-width: 720px) 720px\"></figure>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th><strong>Segmentation Method</strong></th>\n<th><strong>Segment Count</strong></th>\n<th><strong>Average Length (characters)</strong></th>\n<th><strong>Segmentation Time (minutes/seconds)</strong></th>\n<th><strong>Embedding Time (hours/minutes)</strong></th>\n<th><strong>Total Embedding Size</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Jina Segmenter</td>\n<td>1,755</td>\n<td>82</td>\n<td>3.8s</td>\n<td>1h 46m</td>\n<td>21.06 MB</td>\n</tr>\n<tr>\n<td><code>simple-qwen-0.5</code></td>\n<td>48</td>\n<td>1,692</td>\n<td>49s</td>\n<td>1h 2m</td>\n<td>576 KB</td>\n</tr>\n<tr>\n<td><code>topic-qwen-0.5</code></td>\n<td>69</td>\n<td>1,273</td>\n<td>2m 3s</td>\n<td>1h 6m</td>\n<td>828 KB</td>\n</tr>\n<tr>\n<td><code>summary-qwen-0.5</code></td>\n<td>39</td>\n<td>1,799</td>\n<td>2m 40s</td>\n<td>53m</td>\n<td>468 KB</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h3 id=\"what-we-learned\">学んだこと</h3><h3 id=\"problem-formulation-is-critical\">問題設定が重要</h3><p>重要な洞察の1つは、タスクの枠組みの影響でした。モデルにセグメントヘッドを出力させることで、単に入力コンテンツを別々のセグメントにコピー＆ペーストするのではなく、意味的な遷移に焦点を当てることで、境界の検出と一貫性を改善しました。また、生成するテキストが少なくなったことで、モデルがタスクをより迅速に完了できるようになり、より高速なセグメンテーションモデルとなりました。</p><h3 id=\"llm-generated-data-is-effective\">LLM生成データの効果</h3><p>リスト、数式、コードスニペットなどの複雑なコンテンツに特に LLM 生成データを使用することで、モデルのトレーニングセットを拡大し、多様なドキュメント構造を処理する能力が向上しました。これにより、モデルはさまざまなコンテンツタイプに対応できるようになり、技術的または構造化されたドキュメントを扱う際に重要な利点となりました。</p><h3 id=\"output-only-data-collation\">出力専用データコレーション</h3><p>出力専用の<a href=\"https://huggingface.co/docs/transformers/en/main_classes/data_collator?ref=jina-ai-gmbh.ghost.io\">データコレーター</a>を使用することで、トレーニング中に入力からの単なるコピーではなく、ターゲットトークンの予測にモデルが集中できるようになりました。出力専用コレーターにより、モデルは実際のターゲットシーケンスから学習し、正しい補完や境界を強調することができました。この区別により、モデルは入力へのオーバーフィッティングを避けて収束が早くなり、異なるデータセット間でのより良い一般化が可能になりました。</p><h3 id=\"efficient-training-with-unsloth\">Unslothによる効率的なトレーニング</h3><p><a href=\"https://github.com/unslothai/unsloth?ref=jina-ai-gmbh.ghost.io\">Unsloth</a>を使用することで、小規模な言語モデルのトレーニングを効率化し、Nvidia 4090 GPU で実行することができました。この最適化されたパイプラインにより、大規模な計算リソースを必要とせずに、効率的で高性能なモデルをトレーニングすることができました。</p><h3 id=\"handling-complex-texts\">複雑なテキストの処理</h3><p>セグメンテーションモデルは、従来の手法では通常困難なコード、表、リストを含む複雑なドキュメントの処理に優れていました。技術的なコンテンツに関しては、<code>topic-qwen-0.5</code>や<code>summary-qwen-0.5</code>などの高度な戦略がより効果的で、下流の RAG タスクを強化する可能性を持っています。</p><h3 id=\"simple-methods-for-simpler-content\">シンプルなコンテンツにはシンプルな方法</h3><p>ストレートな物語主導のコンテンツには、Segmenter API のようなシンプルな方法で十分です。高度なセグメンテーション戦略は、より複雑で構造化されたコンテンツにのみ必要となる可能性があり、ユースケースに応じて柔軟に対応できます。</p><h2 id=\"next-steps\">次のステップ</h2><p>この実験は主に概念実証として設計されましたが、さらに拡張する場合、いくつかの改善が可能です。まず、この特定の実験の継続は考えにくいものの、<code>summary-qwen-0.5</code>を30,000サンプルではなく理想的には60,000サンプルの大規模なデータセットでトレーニングすることで、より最適なパフォーマンスが得られる可能性があります。また、ベンチマーキングプロセスの改善も有益でしょう。RAGシステムから生成された LLM の回答を評価する代わりに、取得されたセグメントを直接グランドトルースと比較することに焦点を当てます。最後に、ROUGE スコアを超えて、取得とセグメンテーションの品質のニュアンスをより良く捉える高度なメトリクス（おそらく ROUGE と LLM スコアリングの組み合わせ）を採用します。</p><h2 id=\"conclusion\">結論</h2><p>この実験では、特定のタスク向けにカスタマイズされたセグメンテーションモデルが RAG のパフォーマンスをどのように向上させることができるかを探りました。<code>simple-qwen-0.5</code>、<code>topic-qwen-0.5</code>、<code>summary-qwen-0.5</code>などのモデルを開発・トレーニングすることで、意味的な一貫性の維持やコードスニペットなどの複雑なコンテンツの効果的な処理など、従来のセグメンテーション手法に見られる主要な課題に対処しました。テストしたモデルの中で、<code>topic-qwen-0.5</code>は特にマルチトピックドキュメントにおいて、最も意味のある文脈的に関連性の高いセグメンテーションを一貫して提供しました。</p><p>セグメンテーションモデルは RAG システムに必要な構造的基盤を提供しますが、セグメント間の文脈的関連性を維持して検索パフォーマンスを最適化する後期チャンキングとは異なる機能を果たします。これらの2つのアプローチは相補的になり得ますが、セグメンテーションは特に、一貫性のあるタスク固有の生成ワークフロー向けにドキュメントを分割する方法が必要な場合に重要です。</p>",
  "comment_id": "67126986708dbe00019249f2",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/10/breakpoints.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-10-18T15:58:30.000+02:00",
  "updated_at": "2024-10-25T20:14:53.000+02:00",
  "published_at": "2024-10-25T10:35:07.000+02:00",
  "custom_excerpt": "We trained three small language models to better segment long documents into chunks, and here are the key lessons we learned.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "632ade4a3e4e55003d525971",
      "name": "Alex C-G",
      "slug": "alexcg",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/09/alex.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/twitter_banner.jpg",
      "bio": "Open-source Evangelist @ Jina AI. Old, grim, and full of Vim",
      "website": null,
      "location": "Berlin, Germany",
      "facebook": null,
      "twitter": "@alexcg",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/alexcg/"
    },
    {
      "id": "64ae64a4733bc60001949ca4",
      "name": "Andrei Ungureanu",
      "slug": "andrei",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2023/07/Me.jpg",
      "cover_image": null,
      "bio": "Software / AI Engineer, with a passion for content creation.",
      "website": null,
      "location": "Beijing, China",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/andrei/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "632ade4a3e4e55003d525971",
    "name": "Alex C-G",
    "slug": "alexcg",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/09/alex.jpg",
    "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/twitter_banner.jpg",
    "bio": "Open-source Evangelist @ Jina AI. Old, grim, and full of Vim",
    "website": null,
    "location": "Berlin, Germany",
    "facebook": null,
    "twitter": "@alexcg",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/alexcg/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/finding-optimal-breakpoints-in-long-documents-using-small-language-models/",
  "excerpt": "長い文書をチャンクに分割するための小規模な言語モデルを3つ学習させ、そこから得た重要な教訓をご紹介します。",
  "reading_time": 19,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "A pattern of yellow file icons on a blue background with one icon displaying a smiley face creating an emotive contrast.",
  "feature_image_caption": null
}