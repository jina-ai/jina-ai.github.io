{
  "slug": "dspy-not-your-average-prompt-engineering",
  "id": "66077bf0a5c39b0001044181",
  "uuid": "e242c77c-f712-462c-9745-3e9269eb8a8b",
  "title": "DSPy：通常のプロンプトエンジニアリングとは一線を画す",
  "html": "<div class=\"kg-card kg-file-card\"><a class=\"kg-file-card-container\" href=\"https://jina-ai-gmbh.ghost.io/content/files/2024/04/DSPy-Not-Your-Average-Prompt-Engineering--1-.pdf\" title=\"ダウンロード\" download=\"\"><div class=\"kg-file-card-contents\"><div class=\"kg-file-card-title\">[スライド] DSPy：普通のプロンプトエンジニアリングとは違う</div><div class=\"kg-file-card-caption\">2024年4月15日にMountain Viewで Han が行ったプレゼンテーション</div><div class=\"kg-file-card-metadata\"><div class=\"kg-file-card-filename\">DSPy Not Your Average Prompt Engineering (1).pdf</div><div class=\"kg-file-card-filesize\">7 MB</div></div></div><div class=\"kg-file-card-icon\"><svg viewBox=\"0 0 24 24\"><defs><style>.a{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;}</style></defs><title>download-circle</title><polyline class=\"a\" points=\"8.25 14.25 12 18 15.75 14.25\"></polyline><line class=\"a\" x1=\"12\" y1=\"6.75\" x2=\"12\" y2=\"18\"></line><circle class=\"a\" cx=\"12\" cy=\"12\" r=\"11.25\"></circle></svg></div></a></div><p>最近、Stanford NLP グループが開発した言語モデル（LM）プロンプトをアルゴリズム的に最適化することを目的とした最先端のフレームワーク DSPy について調査しました。この3日間で、DSPy に関する初期の印象といくつかの貴重な洞察を得ました。なお、私の観察は DSPy の公式ドキュメントに取って代わるものではありません。実際、この投稿に入る前に<a href=\"https://dspy-docs.vercel.app/?ref=jina-ai-gmbh.ghost.io\">彼らのドキュメント</a>と<a href=\"https://github.com/stanfordnlp/dspy/blob/main/README.md?ref=jina-ai-gmbh.ghost.io\">README</a>を少なくとも一度は読むことを強くお勧めします。ここでの議論は、DSPy の機能を数日間探求して得た予備的な理解を反映しています。DSPy Assertions、Typed Predictor、LM weights tuning などの高度な機能については、まだ十分に調査していません。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/stanfordnlp/dspy?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub - stanfordnlp/dspy: DSPy: The framework for programming—not prompting—foundation models</div><div class=\"kg-bookmark-description\">DSPy: The framework for programming—not prompting—foundation models - stanfordnlp/dspy</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">stanfordnlp</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://opengraph.githubassets.com/b8c1b2b4b3ff9c22d486f5c69dbda5fee6cc8dda8a42aaf1c2e154c17b7dc159/stanfordnlp/dspy\" alt=\"\"></div></a></figure><p>Jina AI での検索基盤に焦点を当てたバックグラウンドがありますが、DSPy への私の関心は Retrieval-Augmented Generation（RAG）での潜在的な可能性に直接起因するものではありません。代わりに、いくつかの生成タスクに対処するために DSPy を自動プロンプトチューニングに活用できる可能性に興味を持ちました。</p><p>DSPy を初めて使用する方で、アクセスしやすいエントリーポイントを探している方、またはフレームワークに慣れているものの公式ドキュメントが混乱したり圧倒的だと感じる方向けに、この記事を書きました。また、初心者には難しく感じるかもしれない DSPy の慣用句に厳密に従うことは避けています。それでは、より深く掘り下げていきましょう。</p><h2 id=\"what-i-like-about-dspy\">DSPy の好きなところ</h2><h3 id=\"dspy-closing-the-loop-of-prompt-engineering\">DSPy によるプロンプトエンジニアリングのループの閉じ込め</h3><p>DSPy で最も興奮するのは、プロンプトエンジニアリングのサイクルのループを閉じるアプローチで、<em>手動</em>で<em>手作業</em>のプロセスを、<em>構造化</em>された、<em>明確に定義された</em>機械学習ワークフロー（データセットの準備、モデルの定義、トレーニング、評価、テスト）に変換することです。<strong>これが DSPy の最も革新的な側面だと私は考えています。</strong></p><p>ベイエリアを旅行し、LLM 評価に焦点を当てた多くのスタートアップ創業者と話をする中で、メトリクス、ハルシネーション、観測可能性、コンプライアンスについての議論をよく耳にしました。しかし、これらの会話は重要な次のステップまで進むことがありません：<strong>これらすべてのメトリクスを手に入れた後、次に何をするのか？</strong>プロンプトの言い回しを調整し、特定の魔法の言葉（例：「私の祖母が死にかけています」）がメトリクスを向上させることを期待するのは、戦略的なアプローチと言えるでしょうか？この質問は多くの LLM 評価スタートアップによって未解決のままでした。そして、DSPy を発見するまで、私も答えることができませんでした。DSPy は、特定のメトリクスに基づいてプロンプトを最適化する、あるいはプロンプトと LLM の重みの両方を含む LLM パイプライン全体を最適化する、明確でプログラム的な方法を導入します。</p><p>LangChain の CEO の Harrison と、OpenAI の元 Developer Relations 責任者の Logan は、<a href=\"https://podcasts.apple.com/us/podcast/unsupervised-learning/id1672188924?ref=jina-ai-gmbh.ghost.io\">Unsupervised Learning Podcast</a> で、2024年が LLM 評価の重要な年になると述べています。このため、DSPy がパズルの重要な欠落部分を提供しているので、現在よりもっと注目に値すると私は考えています。</p><h3 id=\"dspy-separating-logic-from-textual-representation\">DSPy によるロジックとテキスト表現の分離</h3><p>DSPy の印象的なもう一つの側面は、プロンプトエンジニアリングを再現可能で LLM に依存しないモジュールに定式化することです。これを達成するために、<strong>プロンプトからロジックを抽出し、<em>ロジック</em>と<em>テキスト表現</em>の間に明確な関心の分離を作成します</strong>。以下に示す通りです。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--5-.png\" class=\"kg-image\" alt=\"Flowchart depicting sentiment analysis process with steps such as Prompt, Logic, and Textual Representation on a black backgr\" loading=\"lazy\" width=\"1200\" height=\"630\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Heading--5-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/Heading--5-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--5-.png 1200w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">DSPy では、プロンプトは本質的なロジック（つまり </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>dspy.Module</span></code><span style=\"white-space: pre-wrap;\">）とそのテキスト表現で構成されます。ロジックは不変で、再現可能、テスト可能、そして LLM に依存しません。テキスト表現はロジックの結果に過ぎません。</span></figcaption></figure><p><strong>DSPy のロジックを不変、テスト可能、LLM に依存しない「原因」とし、テキスト表現をその「結果」とする概念</strong>は、最初は理解が難しいかもしれません。特に「プログラミング言語の未来は自然言語である」という広く信じられている考えの中では、そうです。「プロンプトエンジニアリングが未来である」という考えを受け入れると、DSPy の設計哲学に出会った時に混乱を感じるかもしれません。単純化するという期待に反して、DSPy は一連のモジュールとシグネチャ構文を導入し、自然言語プロンプティングを C プログラミングの複雑さに逆行させているように見えます！</p><p>しかし、なぜこのようなアプローチを取るのでしょうか？私の理解では、<strong>プロンプトプログラミングの中核にはロジックがあり、コミュニケーションはその効果を増幅させる増幅器として機能する</strong>ということです。<code>\"Do sentiment classification\"</code> という指示は中核的なロジックを表し、<code>\"Follow these demonstrations or I will fire you\"</code> のような表現はそれを伝える一つの方法です。実生活でのやり取りと同様に、物事がうまくいかない原因は、多くの場合ロジックの欠陥ではなく、コミュニケーションの問題にあります。これは、特に非ネイティブスピーカーが、なぜプロンプトエンジニアリングを難しいと感じるのかを説明しています。私の会社では、優秀なソフトウェアエンジニアがプロンプトエンジニアリングに苦労しているのを見てきましたが、それはロジックの欠如ではなく、「雰囲気を話せない」ためです。ロジックをプロンプトから分離することで、<a href=\"https://dspy-docs.vercel.app/docs/building-blocks/modules?ref=jina-ai-gmbh.ghost.io\">DSPy は <code>dspy.Module</code> を介して決定論的なロジックのプログラミングを可能にし</a>、開発者は使用する LLM に関係なく、従来のエンジニアリングと同じようにロジックに焦点を当てることができます。</p><p>では、開発者がロジックに焦点を当てる一方で、誰がテキスト表現を管理するのでしょうか？<strong>DSPy がこの役割を担い、あなたのデータと評価メトリクスを使用してテキスト表現を洗練させます</strong>—物語の焦点を決定することからヒントの最適化、良いデモンストレーションの選択まで、すべてを行います。驚くべきことに、DSPy は評価メトリクスを使用して LLM の重みを微調整することさえできます！</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--6-.png\" class=\"kg-image\" alt=\"Flowchart illustrating a language model with branches for training data, logic, textual representation, and final results.\" loading=\"lazy\" width=\"1200\" height=\"630\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Heading--6-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/Heading--6-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--6-.png 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>私にとって、DSPy の主要な貢献—プロンプトエンジニアリングにおけるトレーニングと評価のループを閉じること、そしてロジックをテキスト表現から分離すること—は、LLM/エージェントシステムに対する潜在的な重要性を強調しています。確かに野心的なビジョンですが、間違いなく必要なものです！</p><h2 id=\"what-i-think-dspy-can-improve\">DSPy が改善できると思う点</h2><p>まず、DSPy は慣用句のため、初心者にとって学習曲線が急です。<code>signature</code>、<code>module</code>、<code>program</code>、<code>teleprompter</code>、<code>optimization</code>、<code>compile</code> などの用語は圧倒的です。プロンプトエンジニアリングに熟練している人でさえ、DSPy 内でこれらの概念を把握することは難しい迷路となり得ます。</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Yeah, DSPy really needs someone to come in and explain everything without suitcase words. <a href=\"https://twitter.com/CShorten30?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">@CShorten30</a> does a great job, but we need more.</p>— Jonathan Mugan (@jmugan) <a href=\"https://twitter.com/jmugan/status/1773036172723236895?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">March 27, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><p>この複雑さは、私の <a href=\"https://github.com/jina-ai/jina?ref=jina-ai-gmbh.ghost.io\">Jina 1.0</a> での経験と似ています。当時私たちは、<code>chunk</code>、<code>document</code>、<code>driver</code>、<code>executor</code>、<code>pea</code>、<code>pod</code>、<code>querylang</code>、<code>flow</code> といった多くのイディオムを導入しました（ユーザーが覚えやすいように可愛いステッカーまでデザインしました！）。</p><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Document-FLAT--3-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Document-FLAT--3-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Document-FLAT--3-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pea-FLAT--1-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Pea-FLAT--1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pea-FLAT--1-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/QueryLang--FLAT.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/QueryLang--FLAT.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/QueryLang--FLAT.png 700w\"></div></div><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--3-FLAT--1-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/ILLUST--3-FLAT--1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--3-FLAT--1-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pod-FLAT--2-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Pod-FLAT--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pod-FLAT--2-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--5-FLAT--2-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/ILLUST--5-FLAT--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--5-FLAT--2-.png 700w\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">これらの初期のコンセプトのほとんどは、後の Jina のリファクタリングで削除されました。今日では、「大粛清」から生き残ったのは </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Executor</span></code><span style=\"white-space: pre-wrap;\">、</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Document</span></code><span style=\"white-space: pre-wrap;\">、そして </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Flow</span></code><span style=\"white-space: pre-wrap;\"> だけです。Jina 3.0 では新しいコンセプトとして </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Deployment</span></code><span style=\"white-space: pre-wrap;\"> を追加しました。バランスは取れていますね。🤷</span></p></figcaption></figure><p>この問題は DSPy や Jina に固有のものではありません。TensorFlow のバージョン 0.x から 1.x の間に導入された無数のコンセプトと抽象化を思い出してください。これは、ソフトウェアフレームワークの初期段階でよく見られる問題だと考えています。その段階では、<strong>最大限の正確性と再現性を確保するために、アカデミックな表記法をコードベースに直接反映させようとする</strong>傾向があります。しかし、すべてのユーザーがそのような細かい抽象化を重視するわけではなく、シンプルなワンライナーを求める人から、より大きな柔軟性を求める人まで、さまざまな好みがあります。ソフトウェアフレームワークにおける抽象化についてのこのトピックについては、2020 年のブログ記事で詳しく議論しました。興味のある読者は参考になるかもしれません。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://hanxiao.io/2020/08/02/Layer-of-Abstraction-when-Building-Tensorflow-for-Search/?ref=jina-ai-gmbh.ghost.io#layer-of-abstraction\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Layer of Abstraction When Building \"Tensorflow\" for Search · Han Xiao Tech Blog - Neural Search &amp; AI Engineering</div><div class=\"kg-bookmark-description\">Since Feb. 2020, I started a new venture called Jina AI. Our mission is to build an open-source neural search ecosystem for businesses and developers, ... · Han Xiao</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://hanxiao.io/wechaticon.png\" alt=\"\"><span class=\"kg-bookmark-author\">logo</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://hanxiao.io/2020/08/02/Layer-of-Abstraction-when-Building-Tensorflow-for-Search/blog-abstraction-banner.jpg\" alt=\"\"></div></a></figure><p>第二に、DSPy のドキュメントは一貫性の面で時々不足しています。<code>module</code> と <code>program</code>、<code>teleprompter</code> と <code>optimizer</code>、あるいは <code>optimize</code> と <code>compile</code>（時には <code>training</code> や <code>bootstrapping</code> と呼ばれる）といった用語が互換的に使用され、混乱を招いています。その結果、私は DSPy を使い始めた最初の数時間を、何を <code>optimizes</code> するのか、<code>bootstrapping</code> のプロセスが何を意味するのかを理解することに費やしました。</p><p>これらの障壁にもかかわらず、DSPy をより深く掘り下げ、ドキュメントを再確認すると、すべてが腑に落ちる瞬間が訪れ、その独自の用語と PyTorch のような馴染みのある構造との関連性が明らかになるでしょう。しかし、DSPy は将来のバージョンで改善の余地があることは間違いありません。特に、PyTorch のバックグラウンドを持たないプロンプトエンジニアにとって、フレームワークをよりアクセスしやすくする点で改善が必要です。</p><h2 id=\"common-stumbling-blocks-for-dspy-newbies\">DSPy 初心者のよくつまずくポイント</h2><p>以下のセクションでは、私が DSPy で最初につまずいた質問のリストをまとめました。これらの洞察を共有することで、同様の課題に直面する他の学習者の助けになればと思います。</p><h3 id=\"what-are-teleprompter-optimization-and-compile-whats-exactly-being-optimized-in-dspy\"><code>teleprompter</code>、<code>optimization</code>、<code>compile</code> とは何か？DSPy で具体的に何が最適化されるのか？</h3><p>DSPy では、\"Teleprompters\" がオプティマイザーです（<a href=\"https://twitter.com/lateinteraction?ref=jina-ai-gmbh.ghost.io\">@lateinteraction</a> がドキュメントとコードを改訂して明確にしているようです）。<code>compile</code> 関数はこのオプティマイザーの中心として機能し、<code>optimizer.optimize()</code> を呼び出すのに似ています。これを DSPy における学習と考えてください。この <code>compile()</code> プロセスは以下を調整することを目的としています：</p><ul><li>few-shot のデモ</li><li>指示</li><li>LLM の重み</li></ul><p>ただし、DSPy の初心者向けチュートリアルのほとんどは重みと指示の調整には深入りしないため、次の質問につながります。</p><h3 id=\"whats-bootstrap-in-dspy-all-about\">DSPy の <code>bootstrap</code> とは何か？</h3><p>Bootstrap は、few-shot の文脈内学習のための自己生成デモの作成を指し、<code>compile()</code> プロセス（つまり、上述の最適化/学習）の重要な部分です。これらの few-shot デモは、ユーザーが提供したラベル付きデータから生成されます。1 つのデモは通常、入力、出力、根拠（例：思考の連鎖）、および中間の入力と出力（マルチステージのプロンプト用）で構成されます。もちろん、質の高い few-shot デモは出力の優秀性に不可欠です。そのために、DSPy ではユーザー定義のメトリック関数を使用して、特定の基準を満たすデモのみが選択されるようにすることができます。これは次の質問につながります。</p><h3 id=\"whats-dspy-metric-function\">DSPy のメトリック関数とは？</h3><p>DSPy を実践的に使用した経験から、メトリック関数は現在のドキュメントで説明されているよりもはるかに重要な強調が必要だと考えるようになりました。DSPy のメトリック関数は、その暗黙の性質（<code>trace=None</code> によって制御される）のおかげで、評価フェーズと学習フェーズの両方で重要な役割を果たし、「損失」関数としても機能します：</p><pre><code class=\"language-python\">def keywords_match_jaccard_metric(example, pred, trace=None):  \n    # Jaccard similarity between example keywords and predicted keywords  \n    A = set(normalize_text(example.keywords).split())  \n    B = set(normalize_text(pred.keywords).split())  \n    j = len(A &amp; B) / len(A | B)\n    if trace is not None:\n        # act as a \"loss\" function\n        return j  \n    return j > 0.8  # act as evaluation</code></pre><p>このアプローチは従来の機械学習とは大きく異なります。従来の機械学習では、損失関数は通常連続的で微分可能（例：ヒンジ損失/MSE）である一方、評価メトリックは全く異なり離散的（例：NDCG）である場合があります。DSPy では、評価と損失関数はメトリック関数に統合されており、離散的で、ほとんどの場合ブール値を返します。メトリック関数は LLM を統合することもできます！以下の例では、LLM を使用したファジーマッチを実装して、予測値と正解の答えが magnitude の面で類似しているかどうかを判断します。例えば、「100 万ドル」と「$1M」は true を返します。</p><pre><code class=\"language-python\">class Assess(dspy.Signature):  \n    \"\"\"Assess the if the prediction is in the same magnitude to the gold answer.\"\"\"  \n  \n    gold_answer = dspy.InputField(desc='number, could be in natural language')  \n    prediction = dspy.InputField(desc='number, could be in natural language')  \n    assessment = dspy.OutputField(desc='yes or no, focus on the number magnitude, not the unit or exact value or wording')  \n  \ndef same_magnitude_correct(example, pred, trace=None):  \n    return dspy.Predict(Assess)(gold_answer=example.answer, prediction=pred.answer).assessment.lower() == 'yes'</code></pre><p>強力な機能ではありますが、メトリック関数は、最終的な品質評価を決定するだけでなく、最適化の結果にも影響を与えることから、DSPy のユーザー体験に大きく影響を与えます。適切に設計されたメトリック関数は最適化されたプロンプトにつながりますが、設計の悪いメトリック関数は最適化の失敗を招く可能性があります。DSPy で新しい問題に取り組む際、ロジック（すなわち <code>DSPy.Module</code>）の設計と同じくらいの時間をメトリック関数の設計に費やすことになるかもしれません。このロジックとメトリックの両方に注力する必要性は、初心者にとって負担となる可能性があります。</p><h3 id=\"bootstrapped-0-full-traces-after-20-examples-in-round-0-what-does-this-mean\"><code>\"Bootstrapped 0 full traces after 20 examples in round 0\"</code> とはどういう意味でしょうか？</h3><p>この <code>compile()</code> 中に静かに表示されるメッセージは、最大限の注意を払うべきものです。これは本質的に最適化/コンパイルが失敗し、得られるプロンプトは単純な few-shot よりも優れていないことを意味します。何が問題なのでしょうか？このようなメッセージに遭遇した際の DSPy プログラムのデバッグに役立つヒントをまとめました：</p><h4 id=\"your-metric-function-is-incorrect\">メトリック関数が正しくない</h4><p><code>BootstrapFewShot(metric=your_metric)</code> で使用される関数 <code>your_metric</code> は正しく実装されていますか？単体テストを実施してください。<code>your_metric</code> が <code>True</code> を返すことはありますか？それとも常に <code>False</code> を返しているでしょうか？<code>True</code> を返すことが重要です。なぜなら、それが DSPy がブートストラップされた例を「成功」とみなす基準だからです。すべての評価で <code>True</code> を返すと、すべての例がブートストラップで「成功」とみなされます！これは理想的ではありませんが、メトリック関数の厳密さを調整して <code>\"Bootstrapped 0 full traces\"</code> の結果を変更する方法です。なお、DSPy のドキュメントではメトリクスがスカラー値を返すことも可能と記載されていますが、基底のコードを見た限り、初心者にはお勧めしません。</p><h4 id=\"your-logic-dspymodule-is-incorrect\">ロジック（<code>DSPy.Module</code>）が正しくない</h4><p>メトリック関数が正しい場合、ロジック <code>dspy.Module</code> が正しく実装されているかを確認する必要があります。まず、各ステップに <a href=\"https://dspy-docs.vercel.app/docs/building-blocks/signatures?ref=jina-ai-gmbh.ghost.io\">DSPy signature</a> が正しく割り当てられているかを確認します。<code>dspy.Predict('question-&gt;answer')</code> のようなインライン signatures は使いやすいですが、品質のために <a href=\"https://dspy-docs.vercel.app/docs/building-blocks/signatures?ref=jina-ai-gmbh.ghost.io#class-based-dspy-signatures\">クラスベースの signatures</a> での実装を強く推奨します。具体的には、クラスに説明的な docstrings を追加し、<code>InputField</code> と <code>OutputField</code> の desc フィールドを記入します。これらはすべて LM に各フィールドについてのヒントを提供します。以下に、<a href=\"https://en.wikipedia.org/wiki/Fermi_problem?ref=jina-ai-gmbh.ghost.io\">フェルミ問題</a>を解くための 2 つの多段階 <code>DSPy.Module</code> を実装しました。1 つはインライン signature を使用し、もう 1 つはクラスベースの signature を使用しています。</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-python\">class FermiSolver(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.step1 = dspy.Predict('question -&gt; initial_guess')\n        self.step2 = dspy.Predict('question, initial_guess -&gt; calculated_estimation')\n        self.step3 = dspy.Predict('question, initial_guess, calculated_estimation -&gt; variables_and_formulae')\n        self.step4 = dspy.ReAct('question, initial_guess, calculated_estimation, variables_and_formulae -&gt; gathering_data')\n        self.step5 = dspy.Predict('question, initial_guess, calculated_estimation, variables_and_formulae, gathering_data -&gt; answer')\n\n    def forward(self, q):\n        step1 = self.step1(question=q)\n        step2 = self.step2(question=q, initial_guess=step1.initial_guess)\n        step3 = self.step3(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation)\n        step4 = self.step4(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae)\n        step5 = self.step5(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae, gathering_data=step4.gathering_data)\n        return step5</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">インライン signature のみを使用したフェルミ問題ソルバー</span></p></figcaption></figure><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-python\">class FermiStep1(dspy.Signature):\n    question = dspy.InputField(desc='Fermi problems involve the use of estimation and reasoning')\n    initial_guess = dspy.OutputField(desc='Have a guess – don't do any calculations yet')\n\nclass FermiStep2(FermiStep1):\n    initial_guess = dspy.InputField(desc='Have a guess – don't do any calculations yet')\n    calculated_estimation = dspy.OutputField(desc='List the information you'll need to solve the problem and make some estimations of the values')\n\nclass FermiStep3(FermiStep2):\n    calculated_estimation = dspy.InputField(desc='List the information you'll need to solve the problem and make some estimations of the values')\n    variables_and_formulae = dspy.OutputField(desc='Write a formula or procedure to solve your problem')\n\nclass FermiStep4(FermiStep3):\n    variables_and_formulae = dspy.InputField(desc='Write a formula or procedure to solve your problem')\n    gathering_data = dspy.OutputField(desc='Research, measure, collect data and use your formula. Find the smallest and greatest values possible')\n\nclass FermiStep5(FermiStep4):\n    gathering_data = dspy.InputField(desc='Research, measure, collect data and use your formula. Find the smallest and greatest values possible')\n    answer = dspy.OutputField(desc='the final answer, must be a numerical value')\n\nclass FermiSolver2(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.step1 = dspy.Predict(FermiStep1)\n        self.step2 = dspy.Predict(FermiStep2)\n        self.step3 = dspy.Predict(FermiStep3)\n        self.step4 = dspy.Predict(FermiStep4)\n        self.step5 = dspy.Predict(FermiStep5)\n\n    def forward(self, q):\n        step1 = self.step1(question=q)\n        step2 = self.step2(question=q, initial_guess=step1.initial_guess)\n        step3 = self.step3(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation)\n        step4 = self.step4(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae)\n        step5 = self.step5(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae, gathering_data=step4.gathering_data)\n        return step5</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">各フィールドにより包括的な説明を付けたクラスベースの signature を使用したフェルミ問題ソルバー</span></p></figcaption></figure><p>また、<code>def forward(self, )</code> の部分も確認してください。多段階の Module の場合、最後のステップからの出力（または <code>FermiSolver</code> のような全ての出力）が次のステップの入力として渡されていることを確認してください。</p><h4 id=\"your-problem-is-just-too-hard\">問題が単に難しすぎる</h4><p>メトリックとモジュールの両方が正しいように見える場合、問題が単に難しすぎて、実装したロジックではそれを解決するのに十分でない可能性があります。そのため、DSPy はあなたのロジックとメトリック関数では、デモをブートストラップすることが不可能だと判断します。この段階で、以下のような選択肢を検討できます：</p><ul><li><strong>より強力な LM を使用する。</strong>例えば、学習者の LM として <code>gpt-35-turbo-instruct</code> を <code>gpt-4-turbo</code> に置き換えたり、より強力な LM を教師として使用したりします。これはしばしば非常に効果的です。結局のところ、より強力なモデルはプロンプトの理解力が高いということです。</li><li><strong>ロジックを改善する。</strong><code>dspy.Module</code> のステップを追加または置き換えて、より複雑なものにします。例えば、<code>Predict</code> を <code>ChainOfThought</code> や <code>ProgramOfThought</code> に置き換えたり、<code>Retrieval</code> ステップを追加したりします。</li><li><strong>より多くのトレーニング例を追加する。</strong>20 例が不十分な場合、100 例を目指しましょう！そうすれば、1 つの例がメトリックチェックを通過し、<code>BootstrapFewShot</code> によって選ばれることを期待できます。</li><li><strong>問題を再構成する。</strong>しばしば、問題の定式化が間違っているために解決不可能になります。しかし、異なる角度から見ることで、物事がずっと簡単で明白になることがあります。</li></ul><p>実践では、試行錯誤のプロセスが必要です。例えば、私は特に難しい問題に取り組みました：2～3 つのキーワードに基づいて Google Material Design アイコンに似た SVG アイコンを生成する問題です。最初の戦略は、<code>dspy.ChainOfThought('keywords -&gt; svg')</code> を使用する単純な <code>DSPy.Module</code> を利用し、生成された SVG と正解の Material Design SVG との視覚的類似性を pHash アルゴリズムのように評価するメトリック関数を組み合わせることでした。20 のトレーニング例から始めましたが、最初のラウンド後に <code>\"Bootstrapped 0 full traces after 20 examples in round 0\"</code> となり、最適化が失敗したことを示しました。データセットを 100 例に増やし、モジュールを複数のステージを含むように改訂し、メトリック関数のしきい値を調整することで、最終的に 2 つのブートストラップされたデモンストレーションを実現し、いくつかの最適化されたプロンプトを得ることができました。</p>",
  "comment_id": "66077bf0a5c39b0001044181",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--7-.png",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-03-30T03:41:52.000+01:00",
  "updated_at": "2024-04-23T10:46:48.000+02:00",
  "published_at": "2024-03-30T06:22:42.000+01:00",
  "custom_excerpt": "Heads up, Bay Area guys ditched their AVP already and buzz about DSPy now. Could DSPy be the new go-to framework for prompt engineering after LangChain and LlamaIndex?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/dspy-not-your-average-prompt-engineering/",
  "excerpt": "ベイエリアの人々は既に AVP から離れ、現在は DSPy について盛り上がっています。DSPy は LangChain や LlamaIndex に続くプロンプトエンジニアリングの新しい定番フレームワークになるのでしょうか？",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Screenshot of a Tetris-like game with \"Score: 40\" and \"Press Start 2P\" text on display.",
  "feature_image_caption": null
}