{
  "slug": "a-deep-dive-into-tokenization",
  "id": "65afb3ee8da8040001e17061",
  "uuid": "02d119e4-ed5f-4edf-8b66-65aea1386d96",
  "title": "トークン化について深く理解する",
  "html": "<p>AI モデルを理解する上では多くの壁があり、その中には非常に大きな壁もあり、AI プロセスの実装を妨げることがあります。しかし、多くの人が最初に直面するのは、<strong>トークン</strong>について話すときの意味を理解することです。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/tokenizer?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Tokenizer API</div><div class=\"kg-bookmark-description\">Free API to tokenize texts, count and get first/last-N tokens.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-tokenize-api.png\" alt=\"\"></div></a></figure><p>AI 言語モデルを選択する際の最も重要な実用的なパラメータの一つは、コンテキストウィンドウのサイズ（最大入力テキストサイズ）です。これは単語や文字、その他の自動認識可能な単位ではなく、トークンで表されます。</p><p>さらに、埋め込みサービスは通常「トークンごと」に計算されるため、トークンは請求書を理解する上で重要です。</p><p>トークンが何であるかを明確に理解していない場合、これは非常に混乱する可能性があります。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png\" class=\"kg-image\" alt=\"Jina Embeddings current price sheet (as of February 2024).\" loading=\"lazy\" width=\"2000\" height=\"1036\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png 2000w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Jina Embeddings の現在の価格表（2024年2月時点）。価格は「100万トークン」あたりで記載されていることに注意。</span></figcaption></figure><p>しかし、現代の AI の中で混乱する側面の中で、トークンはおそらく最も単純なものです。この記事では、トークン化とは何か、何をするものか、なぜそのような方法を採用しているのかを明確にしていきます。</p><h2 id=\"tldr\">要約</h2><p>Jina Embeddings から購入するトークン数を素早く把握したい方、または必要なトークン数の見積もりを知りたい方のために、以下の統計情報を提供します。</p><h3 id=\"tokens-per-english-word\">英語の単語あたりのトークン数</h3><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">英語モデル用の Jina Embeddings v2 API の呼び出しでは、テキスト内の単語数に対して<b><strong style=\"white-space: pre-wrap;\">およそ 10% 多い</strong></b>トークン数を使用し、<b><strong style=\"white-space: pre-wrap;\">さらに埋め込みごとに2トークン</strong></b>が追加されます。</div></div><p>この記事の後半で説明する実証テストでは、Jina Embeddings の英語専用モデルを使用して、さまざまな英語テキストをトークン化したところ、単語数に対してトークン数が約10%多くなるという結果が得られました。この結果はかなり安定していました。</p><p>Jina Embeddings v2 モデルのコンテキストウィンドウは 8192 トークンです。これは、Jina モデルに 7,400 語を超える英語テキストを渡すと、切り捨てられる可能性が高いことを意味します。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">英語用 Jina Embeddings v2</strong></b> の最大入力サイズは、およそ<b><strong style=\"white-space: pre-wrap;\">7,400 単語</strong></b>です。</div></div><h3 id=\"tokens-per-chinese-character\">中国語の文字あたりのトークン数</h3><p>中国語の場合、結果はより変動的です。テキストの種類によって、中国語の文字（漢字）1字あたり0.6から0.75トークンの比率で変動しました。中国語用 Jina Embeddings v2 に英語テキストを入力した場合は、英語用 Jina Embeddings v2 とほぼ同じ結果となり、単語数に対して約10%多いトークン数となります。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">中国語・英語用 Jina Embeddings v2</strong></b> の中国語での最大入力サイズは、およそ<b><strong style=\"white-space: pre-wrap;\">10,500 文字</strong></b>（<b><strong style=\"white-space: pre-wrap;\">字数</strong></b>）で、<b><strong style=\"white-space: pre-wrap;\">中国語の文字1字あたり0.6から0.75トークン、さらに埋め込みごとに2トークン</strong></b>が追加されます。</div></div><h3 id=\"tokens-per-german-word\">ドイツ語の単語あたりのトークン数</h3><p>ドイツ語の単語とトークンの比率は、英語よりも変動が大きいですが、中国語ほどではありません。テキストのジャンルによって、平均して単語数に対して20%から30%多いトークン数となりました。ドイツ語・英語用 Jina Embeddings v2 に英語テキストを入力した場合は、英語専用モデルや中国語/英語モデルよりもやや多くのトークンを使用し、単語数に対して12%から15%多いトークン数となります。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">ドイツ語・英語用 Jina Embeddings v2 では、<b><strong style=\"white-space: pre-wrap;\">単語数に対して20%から30%多いトークン数、さらに埋め込みごとに2トークン</strong></b>となります。入力コンテキストの最大サイズは、およそ<b><strong style=\"white-space: pre-wrap;\">6,300 ドイツ語単語</strong></b>です。</div></div><h3 id=\"caution\">注意事項</h3><p>これらは簡単な計算ですが、ほとんどの自然言語テキストとユーザーにとって、おおよそ正確なはずです。最終的に、トークン数は常にテキストの文字数に2を加えた数を超えないことのみを保証できます。実際にはそれよりもはるかに少なくなりますが、事前に特定のカウントを約束することはできません。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">結果は異なる場合があります！</strong></b><br><br>これらは統計的に単純な計算に基づく推定値です。特定のリクエストに必要なトークン数は保証できません。</div></div><p>Jina Embeddings のトークン購入に関するアドバイスだけが必要な場合は、ここで読み終えることができます。Jina AI 以外の企業の他の埋め込みモデルは、Jina モデルと同じトークンと単語、トークンと中国語文字の比率ではないかもしれませんが、全体的に大きな違いはないでしょう。</p><p>その理由を理解したい場合は、この記事の残りの部分で言語モデルのトークン化についてより深く掘り下げていきます。</p><h2 id=\"words-tokens-numbers\">単語、トークン、数字</h2><p>トークン化は、現代の AI モデルが存在する以前から自然言語処理の一部でした。</p><p>コンピュータ上のすべてが単なる数字だというのはありふれた言い方かもしれませんが、それはほぼ事実です。しかし、言語は自然には単なる数字の集まりではありません。音波で構成される音声かもしれませんし、紙の上の記号かもしれません。あるいは印刷されたテキストの画像や手話を使用している人のビデオかもしれません。しかし、コンピュータで自然言語を処理する場合、ほとんどの場合、文字（a、b、c など）、数字（0、1、2...）、句読点、スペースで構成される文字列のことを指します。これらは異なる言語やテキストエンコーディングで表現されます。</p><p>コンピュータエンジニアはこれらを「文字列」と呼びます。</p><p>AI 言語モデルは入力として数字の列を受け取ります。例えば、次のような文を書いたとします：</p><blockquote><em>What is today's weather in Berlin?</em></blockquote><p>しかし、トークン化後、AI モデルは以下のような入力を受け取ります：</p><pre><code class=\"language-python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>トークン化とは、入力文字列を AI モデルが理解できる特定の数字の列に変換するプロセスです。</p><p>トークンごとに課金するウェブ API を通じて AI モデルを使用する場合、各リクエストは上記のような数字の列に変換されます。リクエストのトークン数は、その数字の列の長さです。したがって、英語用 Jina Embeddings v2 に「<em>What is today's weather in Berlin?</em>」の埋め込みを要求すると、11 トークンの料金がかかります。これは、その文を AI モデルに渡す前に 11 個の数字の列に変換したためです。</p><p><a href=\"https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)?ref=jina-ai-gmbh.ghost.io\">Transformer アーキテクチャ</a>に基づく AI モデルは、トークンで測定される固定サイズの<strong>コンテキストウィンドウ</strong>を持っています。これは「入力ウィンドウ」「コンテキストサイズ」、または「シーケンス長」（特に<a href=\"https://huggingface.co/spaces/mteb/leaderboard?ref=jina-ai-gmbh.ghost.io\">Hugging Face MTEB リーダーボード</a>では）とも呼ばれます。これはモデルが一度に処理できる最大テキストサイズを意味します。</p><p>したがって、埋め込みモデルを使用する場合、これが許可される最大入力サイズとなります。</p><p>Jina Embeddings v2 モデルはすべて 8,192 トークンのコンテキストウィンドウを持っています。他のモデルは異なる（通常はより小さい）コンテキストウィンドウを持つでしょう。これは、入力するテキストの量に関係なく、その Jina Embeddings モデルに関連付けられたトークナイザーは、8,192 トークン以下に変換する必要があることを意味します。</p><h2 id=\"mapping-language-to-numbers\">言語から数字へのマッピング</h2><p>トークンのロジックを説明する最もシンプルな方法は以下の通りです：</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">トークンとは、文字列の一部を表す数字です。</div></div><p>自然言語モデルの場合、トークンが表す文字列の部分は、単語、単語の一部、または句読点です。スペースは一般的にトークナイザーの出力で明示的な表現を与えられません。</p><p>トークン化は、自然言語処理における<a href=\"https://en.wikipedia.org/wiki/Text_segmentation?ref=jina-ai-gmbh.ghost.io\"><em>テキスト分割</em></a>と呼ばれる技術群の一部であり、トークン化を実行するモジュールは、非常に論理的に<strong>トークナイザー</strong>と呼ばれます。</p><p>トークン化の仕組みを示すために、最小の英語用 Jina Embeddings v2 モデル：<code>jina-embeddings-v2-small-en</code>を使用していくつかの文をトークン化してみましょう。Jina Embeddings の他の英語専用モデル — <code>jina-embeddings-v2-base-en</code> — は同じトークナイザーを使用するため、この記事で使用しない AI モデルの追加メガバイトをダウンロードする必要はありません。</p><p>まず、Python 環境またはノートブックに<code>transformers</code>モジュールをインストールします。使用する<code>-U</code> フラグを使用して最新バージョンにアップグレードしてください。古いバージョンではこのモデルは動作しません：</p><pre><code class=\"language-bash\">pip install -U transformers\n</code></pre><p>次に、<code>AutoModel.from_pretrained</code> を使用して <a href=\"https://huggingface.co/jinaai/jina-embeddings-v2-small-en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\"><code>jina-embeddings-v2-small-en</code></a> をダウンロードします：</p><pre><code class=\"language-Python\">from transformers import AutoModel\n\nmodel = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-small-en', trust_remote_code=True)\n</code></pre><p>文字列をトークン化するには、モデルの <code>tokenizer</code> メンバーオブジェクトの <code>encode</code> メソッドを使用します：</p><pre><code class=\"language-Python\">model.tokenizer.encode(\"What is today's weather in Berlin?\")\n</code></pre><p>結果は数値のリストです：</p><pre><code class=\"language-Python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>これらの数値を文字列形式に戻すには、<code>tokenizer</code> オブジェクトの <code>convert_ids_to_tokens</code> メソッドを使用します：</p><pre><code class=\"language-Python\">model.tokenizer.convert_ids_to_tokens([101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102])\n</code></pre><p>結果は文字列のリストです：</p><pre><code class=\"language-Python\">['[CLS]', 'what', 'is', 'today', \"'\", 's', 'weather', 'in',\n 'berlin', '?', '[SEP]']\n</code></pre><p>モデルのトークナイザーには以下の特徴があります：</p><ol><li>先頭に <code>[CLS]</code>、末尾に <code>[SEP]</code> を追加します。これは技術的な理由で必要であり、テキストが必要とするトークン数に加えて、<strong>埋め込みのリクエストごとに 2 つの追加トークンが必要</strong>になることを意味します。</li><li>句読点を単語から分離し、\"<em>Berlin?</em>\" を <code>berlin</code> と <code>?</code> に、\"<em>today's</em>\" を <code>today</code>、<code>'</code>、<code>s</code> に分割します。</li><li>すべてを小文字にします。すべてのモデルがこれを行うわけではありませんが、英語を使用する場合のトレーニングに役立ちます。大文字小文字の意味が異なる言語では、あまり有用ではないかもしれません。</li></ol><p>異なるプログラムの異なる単語カウントアルゴリズムは、この文の単語数を異なる方法でカウントする可能性があります。OpenOffice では 6 単語としてカウントされます。Unicode テキストセグメンテーションアルゴリズム（<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode Standard Annex #29</a>）では 7 単語としてカウントされます。他のソフトウェアでは、句読点や \"'s\" のような接尾辞の扱い方によって、異なる数になる可能性があります。</p><p>このモデルのトークナイザーは、6～7 単語に対して 9 個のトークンを生成し、さらにすべてのリクエストに必要な 2 つの追加トークンを加えます。</p><p>では、ベルリンよりもあまり一般的ではない地名で試してみましょう：</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"I live in Kinshasa.\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>結果：</p><pre><code class=\"language-Python\">['[CLS]', 'i', 'live', 'in', 'kin', '##sha', '##sa', '.', '[SEP]']\n</code></pre><p>\"Kinshasa\" という名前は 3 つのトークンに分解されています：<code>kin</code>、<code>##sha</code>、<code>##sa</code>。<code>##</code> はこのトークンが単語の先頭ではないことを示しています。</p><p>完全に未知の単語をトークナイザーに与えると、単語数に対するトークン数の比率はさらに増加します：</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"Klaatu barada nikto\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n\n['[CLS]', 'k', '##la', '##at', '##u', 'bar', '##ada', 'nik', '##to', '[SEP]']\n</code></pre><p>3 つの単語が 8 つのトークンになり、さらに <code>[CLS]</code> と <code>[SEP]</code> トークンが追加されます。</p><p>ドイツ語のトークン化も同様です。<a href=\"https://jina.ai/news/ich-bin-ein-berliner-german-english-bilingual-embeddings-with-8k-token-length/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Jina Embeddings v2 for German</a> モデルを使用して、\"What is today's weather in Berlin?\" のドイツ語訳を英語モデルと同じ方法でトークン化できます。</p><pre><code class=\"language-Python\">german_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-de', trust_remote_code=True)\ntoken_ids = german_model.tokenizer.encode(\"Wie wird das Wetter heute in Berlin?\")\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>結果：</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Wie', 'wird', 'das', 'Wetter', 'heute', 'in', 'Berlin', '?', '&lt;/s&gt;']\n</code></pre><p>このトークナイザーは英語のものとは少し異なり、<code>[CLS]</code> と <code>[SEP]</code> の代わりに <code>&lt;s&gt;</code> と <code>&lt;/s&gt;</code> を使用しますが、同じ機能を果たします。また、ドイツ語では英語とは異なる形で大文字小文字が意味を持つため、テキストの大文字小文字は正規化されません。</p><p>（この説明を簡単にするため、単語の始まりを示す特殊文字は省略しています。）</p><p>次に、<a href=\"https://www.welt.de/politik/deutschland/plus249565102/Proteste-der-Landwirte-Die-Krux-mit-den-Foerdermitteln.html?ref=jina-ai-gmbh.ghost.io\">新聞記事から</a>より複雑な文を試してみましょう：</p><blockquote>Ein Großteil der milliardenschweren Bauern-Subventionen bleibt liegen – zu genervt sind die Landwirte von bürokratischen Gängelungen und Regelwahn.</blockquote><pre><code>sentence = \"\"\"\nEin Großteil der milliardenschweren Bauern-Subventionen\nbleibt liegen – zu genervt sind die Landwirte von \nbürokratischen Gängelungen und Regelwahn.\n\"\"\"\ntoken_ids = german_model.tokenizer.encode(sentence)\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)</code></pre><p>トークン化の結果：</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Ein', 'Großteil', 'der', 'mill', 'iarden', 'schwer', \n 'en', 'Bauern', '-', 'Sub', 'ventionen', 'bleibt', 'liegen', \n '–', 'zu', 'gen', 'ervt', 'sind', 'die', 'Landwirte', 'von', \n 'büro', 'krat', 'ischen', 'Gän', 'gel', 'ungen', 'und', 'Regel', \n 'wahn', '.', '&lt;/s&gt;']\n</code></pre><p>ここでは、多くのドイツ語の単語がより小さな部分に分割されており、必ずしもドイツ語文法で認められた分割方法に従っているわけではありません。結果として、単語カウンターでは 1 単語としてカウントされる長いドイツ語の単語が、Jina の AI モデルでは任意の数のトークンになる可能性があります。</p><p>次に、中国語で \"What is today's weather in Berlin?\" を翻訳してみましょう：</p><blockquote>柏林今天的天气怎么样？</blockquote><pre><code>chinese_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-zh', trust_remote_code=True)\ntoken_ids = chinese_model.tokenizer.encode(\"柏林今天的天气怎么样？\")\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>トークン化の結果：</p><pre><code class=\"language-Python\">['&lt;s&gt;', '柏林', '今天的', '天气', '怎么样', '？', '&lt;/s&gt;']\n</code></pre><p>中国語では通常、書き言葉に単語の区切りはありませんが、Jina Embeddings のトークナイザーは複数の漢字をまとめることが多くあります：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Token string</th>\n<th>Pinyin</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>柏林</td>\n<td>Bólín</td>\n<td>Berlin</td>\n</tr>\n<tr>\n<td>今天的</td>\n<td>jīntiān de</td>\n<td>today's</td>\n</tr>\n<tr>\n<td>天气</td>\n<td>tiānqì</td>\n<td>weather</td>\n</tr>\n<tr>\n<td>怎么样</td>\n<td>zěnmeyàng</td>\n<td>how</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p><a href=\"https://news.mingpao.com/pns/%e6%b8%af%e8%81%9e/article/20240116/s00002/1705335848777/%e7%81%a3%e5%8d%80%e7%86%b1%e6%90%9c-%e7%a9%97%e5%9c%b0%e9%90%b5%e6%8e%a8%e6%89%8b%e6%a9%9f%e3%80%8c%e9%9d%9c%e9%9f%b3%e4%bb%a4%e3%80%8d-%e7%84%a1%e7%bd%b0%e5%89%87-%e5%b8%82%e6%b0%91%e6%9c%89%e7%a8%b1%e5%85%b7%e8%ad%a6%e7%a4%ba%e4%bd%9c%e7%94%a8-%e6%9c%89%e6%84%9f%e5%af%a6%e6%95%88%e4%b8%8d%e5%a4%a7?ref=jina-ai-gmbh.ghost.io\">香港の新聞から</a>より複雑な文を試してみましょう：</p><pre><code class=\"language-Python\">sentence = \"\"\"\n新規定執行首日，記者在下班高峰前的下午5時來到廣州地鐵3號線，\n從繁忙的珠江新城站啟程，向機場北方向出發。\n\"\"\"\ntoken_ids = chinese_model.tokenizer.encode(sentence)\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>（訳：『新しい規制が施行された初日の午後5時、記者は広州地下鉄3号線の珠江新城駅から空港方面に向かう電車に乗り込みました。ラッシュアワーの最中でした。』）</p><p>結果：</p><pre><code class=\"language-python\">['&lt;s&gt;', '新', '規定', '執行', '首', '日', '，', '記者', '在下', '班', \n '高峰', '前的', '下午', '5', '時', '來到', '廣州', '地', '鐵', '3', \n '號', '線', '，', '從', '繁忙', '的', '珠江', '新城', '站', '啟', \n '程', '，', '向', '機場', '北', '方向', '出發', '。', '&lt;/s&gt;']\n</code></pre><p>これらのトークンは中国語の特定の辞書（词典）にマッピングされているわけではありません。例えば、\"啟程\"（出発する、旅立つ）は通常一つの単語として分類されますが、ここでは2つの構成文字に分割されています。同様に、\"在下班\"は通常2つの単語として認識され、\"在\"（～において）と\"下班\"（退勤時間）の間で分割されるはずですが、トークナイザーは\"在下\"と\"班\"の間で分割しています。</p><p>3つの言語すべてにおいて、トークナイザーがテキストを分割する場所は、人間の読者が論理的に分割する場所とは直接関係ありません。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">トークナイザーのアルゴリズムは従来の言語を認識する辞書を使用しないため、その動作は人間が単語を数える方法とは一致しません。</div></div><p>これは Jina Embeddings モデルに特有の機能ではありません。このトークン化アプローチは AI モデル開発においてほぼ普遍的です。2つの異なる AI モデルが同一のトークナイザーを持つとは限りませんが、現在の開発状況では、実質的にすべてのモデルがこのような動作をするトークナイザーを使用しています。</p><p>次のセクションでは、トークン化に使用される具体的なアルゴリズムとその背後にある論理について説明します。</p><h2 id=\"why-do-we-tokenize-and-why-this-way\">なぜトークン化するのか？そしてなぜこの方法なのか？</h2><p>AI 言語モデルは、テキストシーケンスを表す数値のシーケンスを入力として受け取りますが、基礎となるニューラルネットワークを実行し埋め込みを作成する前に、もう少し処理が行われます。小さなテキストシーケンスを表す数値のリストが与えられると、モデルは各数値に対して内部辞書で一意のベクトルを検索します。それらを組み合わせてニューラルネットワークへの入力とします。</p><p>これは、トークナイザーが与えられた<strong><em>あらゆる</em></strong>入力テキストを、モデルのトークンベクトル辞書に存在するトークンに変換<strong>しなければならない</strong>ことを意味します。従来の辞書からトークンを取得した場合、スペルミスや珍しい固有名詞、外国語に初めて遭遇した時点でモデル全体が停止してしまいます。その入力を処理できなくなってしまいます。</p><p>自然言語処理では、これは語彙外（OOV）問題と呼ばれ、あらゆるテキストタイプとあらゆる言語で広く見られます。OOV 問題に対処するには、いくつかの戦略があります：</p><ol><li>無視する。辞書にないものはすべて「不明」トークンに置き換える。</li><li>回避する。テキストシーケンスをベクトルにマッピングする辞書の代わりに、<em>個々の文字</em>をベクトルにマッピングする辞書を使用する。英語は主に26文字しか使用しないため、これは任意の辞書よりも小さく、OOV 問題に対してより堅牢でなければならない。</li><li>テキスト内の頻出する部分シーケンスを見つけて辞書に入れ、残りの部分には文字（単一文字トークン）を使用する。</li></ol><p>最初の戦略では、多くの重要な情報が失われます。辞書にない形式のデータについて、モデルは学習すらできません。通常のテキストには、最大の辞書でさえ含まれていないものが多くあります。</p><p>2番目の戦略は可能で、研究者も調査しています。しかし、モデルがより多くの入力を受け入れ、より多くを学習しなければならないことを意味します。これは3番目の戦略よりも良い結果が得られなかった上に、はるかに大きなモデルとより多くのトレーニングデータが必要になります。</p><p>AI 言語モデルは、ほぼすべてが何らかの形で3番目の戦略を実装しています。ほとんどは <a href=\"https://huggingface.co/learn/nlp-course/chapter6/6?ref=jina-ai-gmbh.ghost.io\">Wordpiece アルゴリズム</a> <a href=\"https://ieeexplore.ieee.org/document/6289079?ref=jina-ai-gmbh.ghost.io\">[Schuster and Nakajima 2012]</a> のバリエーションか、<a href=\"https://en.wikipedia.org/wiki/Byte_pair_encoding?ref=jina-ai-gmbh.ghost.io\">Byte-Pair Encoding</a>（BPE）と呼ばれる同様の技術を使用しています。[<a href=\"https://www.drdobbs.com/a-new-algorithm-for-data-compression/184402829?ref=jina-ai-gmbh.ghost.io\">Gage 1994</a>、<a href=\"https://aclanthology.org/P16-1162/?ref=jina-ai-gmbh.ghost.io\">Senrich et al. 2016</a>] これらのアルゴリズムは<em>言語に依存しません</em>。つまり、可能な文字の包括的なリスト以外の知識なしに、すべての書き言葉に対して同じように機能します。Google の BERT のような多言語モデル向けに設計されており、インターネットからスクレイピングした入力（何百もの言語やコンピュータプログラムのような人間の言語以外のテキスト）を、複雑な言語学的処理なしにトレーニングできるようになっています。</p><p>より言語特有で言語を認識するトークナイザーを使用することで、大幅な改善が見られるという研究もあります。[<a href=\"https://aclanthology.org/2021.acl-long.243/?ref=jina-ai-gmbh.ghost.io\">Rust et al. 2021</a>] しかし、そのようなトークナイザーの構築には時間、お金、専門知識が必要です。BPE や Wordpiece のような普遍的な戦略を実装する方が、はるかに安価で容易です。</p><p>しかし結果として、特定のテキストが何個のトークンを表すかを知る方法は、トークナイザーを実行してから出力されたトークンの数を数える以外にありません。テキストの最小の部分シーケンスは1文字なので、トークンの数は文字数（スペースを除く）に2を加えた数を超えることはないと確信できます。</p><p>良い推定値を得るには、多くのテキストをトークナイザーに投入し、入力した単語数や文字数と比較して、平均して何個のトークンが得られるかを経験的に計算する必要があります。次のセクションでは、現在利用可能なすべての Jina Embeddings v2 モデルについて、あまり体系的ではない経験的な測定を行います。</p><h2 id=\"empirical-estimates-of-token-output-sizes\">トークン出力サイズの経験的推定</h2><p>英語とドイツ語については、Unicode テキストセグメンテーションアルゴリズム（<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode Standard Annex #29</a>）を使用して単語数を取得しました。このアルゴリズムは、ダブルクリックで何かを選択する際のテキスト断片の選択に広く使用されています。これが利用可能な普遍的で客観的な単語カウンターに最も近いものです。</p><p>Python で <a href=\"https://pypi.org/project/polyglot/?ref=jina-ai-gmbh.ghost.io\">polyglot ライブラリ</a>をインストールしました。このライブラリはこのテキストセグメンターを実装しています：</p><pre><code class=\"language-bash\">pip install -U polyglot\n</code></pre><p>テキストの単語数を取得するには、このようなコードスニペットを使用できます：</p><pre><code class=\"language-python\">from polyglot.text import Text\n\ntxt = \"What is today's weather in Berlin?\"\nprint(len(Text(txt).words))\n</code></pre><p>結果は <code>7</code> になるはずです。</p><p>トークン数を取得するために、テキストの各セグメントを以下に説明する様々な Jina Embeddings モデルのトークナイザーに渡し、その都度、返されたトークン数から2を引きました。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\">ここに記載されているトークン数は、トークン化されたテキストの先頭と末尾にある追加の2つのトークンを<b><strong style=\"white-space: pre-wrap;\">含みません</strong></b>。</div></div><h3 id=\"english-jina-embeddings-v2-small-en-and-jina-embeddings-v2-base-en\">英語<br>（<code>jina-embeddings-v2-small-en</code> および <code>jina-embeddings-v2-base-en</code>）</h3><p>平均値を計算するために、<a href=\"https://wortschatz.uni-leipzig.de/en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Wortschatz Leipzig</a>から2つの英語テキストコーパスをダウンロードしました。これはライプツィヒ大学がホストする、多数の言語と設定で自由にダウンロード可能なコーパスのコレクションです：</p><ul><li>2020年の英語ニュースデータから100万文のコーパス（<code>eng_news_2020_1M</code>）</li><li>2016年の<a href=\"https://en.wikipedia.org/?ref=jina-ai-gmbh.ghost.io\">英語Wikipedia</a>データから100万文のコーパス（<code>eng_wikipedia_2016_1M</code>）</li></ul><p>どちらも<a href=\"https://wortschatz.uni-leipzig.de/en/download/English?ref=jina-ai-gmbh.ghost.io\">英語のダウンロードページ</a>で見つけることができます。</p><p>多様性のために、Project Gutenberg から<a href=\"https://www.gutenberg.org/ebooks/135?ref=jina-ai-gmbh.ghost.io\">Hapgood によるビクトル・ユーゴーの『レ・ミゼラブル』の翻訳</a>と、1611年に英語に翻訳された欽定訳聖書のコピーもダウンロードしました。</p><p>4つのテキストすべてについて、<code>polyglot</code>で実装された Unicode セグメンターを使用して単語数を数え、次に <code>jina-embeddings-v2-small-en</code> で作成されたトークンを数え、各トークン化リクエストから2つのトークンを引きました。結果は以下の通りです：</p>\n<!--kg-card-begin: html-->\n<table id=\"6f07d5d4-ca08-466e-92fc-e784a932e4d0\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"4b8c4003-8ef9-4ac5-8df3-ef7662ab4d3b\"><th id=\"wvl`\" class=\"simple-table-header-color simple-table-header\">テキスト</th><th id=\"|<X;\" class=\"simple-table-header-color simple-table-header\">単語数<br>（Unicode セグメンター）<br></th><th id=\"GHal\" class=\"simple-table-header-color simple-table-header\">トークン数<br>（Jina Embeddings v2<br>英語用）<br></th><th id=\"h]mu\" class=\"simple-table-header-color simple-table-header\">トークン数/単語数の比率<br>（小数点以下3桁）<br></th></tr></thead><tbody><tr id=\"7e9eda1b-54b6-40f3-be6f-b233f161e2b5\"><td id=\"wvl`\" class=\"\"><code>eng_news_2020_1M</code></td><td id=\"|<X;\" class=\"\">22,825,712</td><td id=\"GHal\" class=\"\">25,270,581</td><td id=\"h]mu\" class=\"\">1.107</td></tr><tr id=\"a81dfe1d-9143-4306-9bf3-4891ca8fb019\"><td id=\"wvl`\" class=\"\"><code>eng_wikipedia_2016_1M</code></td><td id=\"|<X;\" class=\"\">24,243,607</td><td id=\"GHal\" class=\"\">26,813,877</td><td id=\"h]mu\" class=\"\">1.106</td></tr><tr id=\"d2fff413-6e0d-4ab2-9626-4d618d99af91\"><td id=\"wvl`\" class=\"\"><code>les_miserables_en</code></td><td id=\"|<X;\" class=\"\">688,911</td><td id=\"GHal\" class=\"\">764,121</td><td id=\"h]mu\" class=\"\">1.109</td></tr><tr id=\"eb304e43-4fd3-4e02-9993-13fb0307f544\"><td id=\"wvl`\" class=\"\"><code>kjv_bible</code></td><td id=\"|<X;\" class=\"\">1,007,651</td><td id=\"GHal\" class=\"\">1,099,335</td><td id=\"h]mu\" class=\"\">1.091</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>正確な数値を使用していることは、これが正確な結果であることを意味するわけではありません。このように異なるジャンルの文書がすべて単語数よりもトークン数が 9% から 11% 多いということは、Unicode セグメンターで計測した場合、単語数よりもトークン数が約 10% 多くなると予想できることを示しています。ワードプロセッサは多くの場合句読点をカウントしませんが、Unicode セグメンターはカウントするため、オフィスソフトウェアの単語数とは必ずしも一致しないと考えられます。</p><h3 id=\"german-jina-embeddings-v2-base-de\">ドイツ語<br>(<code>jina-embeddings-v2-base-de</code>)</h3><p>ドイツ語については、<a href=\"https://wortschatz.uni-leipzig.de/en/download/German?ref=jina-ai-gmbh.ghost.io\">Wortschatz Leipzig のドイツ語ページ</a>から 3 つのコーパスをダウンロードしました：</p><ul><li><code>deu_mixed-typical_2011_1M</code> — 2011 年時点の異なるジャンルのテキストをバランスよく混合した 100 万文。</li><li><code>deu_newscrawl-public_2019_1M</code> — 2019 年のニューステキスト 100 万文。</li><li><code>deu_wikipedia_2021_1M</code> — 2021 年のドイツ語版 Wikipedia から抽出した 100 万文。</li></ul><p>さらに多様性を持たせるため、<a href=\"https://www.deutschestextarchiv.de/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Deutsches Textarchiv</a>から<a href=\"https://deutschestextarchiv.de/search?q=Kapital&in=metadata&ref=jina-ai-gmbh.ghost.io\">カール・マルクスの『資本論』全 3 巻</a>もダウンロードしました。</p><p>そして英語と同じ手順で処理を行いました：</p>\n<!--kg-card-begin: html-->\n<table id=\"ad695a91-f35b-4215-bd4d-5d1415bb9812\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"7786decb-f68d-433d-8f58-3861d0350027\"><th id=\"UGp`\" class=\"simple-table-header-color simple-table-header\" style=\"width:234.2265625px\">テキスト</th><th id=\"|qln\" class=\"simple-table-header-color simple-table-header\">単語数<br>(Unicode セグメンター)<br></th><th id=\"YXZX\" class=\"simple-table-header-color simple-table-header\">トークン数<br>(Jina Embeddings v2 <br>ドイツ語および英語用)<br></th><th id=\"oEoQ\" class=\"simple-table-header-color simple-table-header\">トークン数/単語数の比率<br>(小数点以下 3 桁)<br></th></tr></thead><tbody><tr id=\"9cb48640-64db-4783-8bfe-c78412022a21\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_mixed-typical_2011_1M</code></td><td id=\"|qln\" class=\"\">7,924,024</td><td id=\"YXZX\" class=\"\">9,772,652</td><td id=\"oEoQ\" class=\"\">1.234</td></tr><tr id=\"32fee905-17dc-4c2c-a32d-5e6508b033bc\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_newscrawl-public_2019_1M</code></td><td id=\"|qln\" class=\"\">17,949,120</td><td id=\"YXZX\" class=\"\">21,711,555</td><td id=\"oEoQ\" class=\"\">1.210</td></tr><tr id=\"35d0c8c4-7912-4d61-829a-bb39b643aa1c\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_wikipedia_2021_1M</code></td><td id=\"|qln\" class=\"\">17,999,482</td><td id=\"YXZX\" class=\"\">22,654,901</td><td id=\"oEoQ\" class=\"\">1.259</td></tr><tr id=\"19e10367-e070-4dcc-8cbe-cfc75c43e0f9\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>marx_kapital</code></td><td id=\"|qln\" class=\"\">784,336</td><td id=\"YXZX\" class=\"\">1,011,377</td><td id=\"oEoQ\" class=\"\">1.289</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>これらの結果は英語専用モデルよりもばらつきが大きいものの、ドイツ語のテキストは平均して単語数よりもトークン数が 20% から 30% 多くなることを示唆しています。</p><p>英語のテキストは、ドイツ語・英語トークナイザーを使用すると、英語専用のものよりも多くのトークンが生成されます：</p>\n<!--kg-card-begin: html-->\n<table id=\"c31b2079-e921-4e06-a24b-8ed60ae63d8d\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"fe722fdd-ab88-44b4-9f3b-43c62eb3ccb5\"><th id=\"Nc<l\" class=\"simple-table-header-color simple-table-header\" style=\"width:187.78125px\">テキスト</th><th id=\"R@A^\" class=\"simple-table-header-color simple-table-header\">単語数<br>(Unicode セグメンター)<br></th><th id=\"UUfl\" class=\"simple-table-header-color simple-table-header\">トークン数<br>(Jina Embeddings v2 <br>ドイツ語および英語用)<br></th><th id=\"iTZS\" class=\"simple-table-header-color simple-table-header\">トークン数/単語数の比率<br>(小数点以下 3 桁)<br></th></tr></thead><tbody><tr id=\"3461fd8c-ca39-4670-8f0e-e38a4958464a\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_news_2020_1M</code></td><td id=\"R@A^\" class=\"\">24243607</td><td id=\"UUfl\" class=\"\">27758535</td><td id=\"iTZS\" class=\"\">1.145</td></tr><tr id=\"48770d4d-5855-4f5f-934f-5b2900aa56c3\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"R@A^\" class=\"\">22825712</td><td id=\"UUfl\" class=\"\">25566921</td><td id=\"iTZS\" class=\"\">1.120</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>バイリンガルのドイツ語/英語で英語のテキストを埋め込む場合、英語専用のものと比べてトークン数が 12% から 15% 多くなると予想されます。</p><h3 id=\"chinese-jina-embeddings-v2-base-zh\">中国語<br>(<code>jina-embeddings-v2-base-zh</code>)</h3><p>中国語は通常スペースなしで書かれ、20 世紀以前は「単語」という概念が伝統的にありませんでした。そのため、中国語のテキストの長さは通常、文字数（<strong>字数</strong>）で測られます。そこで、Unicode セグメンターを使用する代わりに、すべてのスペースを削除してから文字数を取得して中国語のテキストの長さを測定しました。</p><p><a href=\"https://wortschatz.uni-leipzig.de/en/download/Chinese?ref=jina-ai-gmbh.ghost.io\">Wortschatz Leipzig の中国語コーパスページ</a>から 3 つのコーパスをダウンロードしました：</p><ul><li><code>zho_wikipedia_2018_1M</code> — 2018 年に抽出された中国語版 Wikipedia からの 100 万文。</li><li><code>zho_news_2007-2009_1M</code> — 2007 年から 2009 年にかけて収集された中国語ニュースソースからの 100 万文。</li><li><code>zho-trad_newscrawl_2011_1M</code> — 繁体字（繁體字）のみを使用するニュースソースからの 100 万文。</li></ul><p>さらに多様性を持たせるため、魯迅（魯迅）による 1920 年代初頭の中編小説『阿 Q 正伝』（阿Q正傳）も使用しました。<a href=\"https://www.gutenberg.org/ebooks/25332?ref=jina-ai-gmbh.ghost.io\">Project Gutenberg から繁体字版をダウンロード</a>しました。</p>\n<!--kg-card-begin: html-->\n<table id=\"dace0ca3-97c0-481e-98e2-d2724b7bbe66\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"adc6e6ff-8afd-4915-8884-0894546a13dc\"><th id=\"bCvb\" class=\"simple-table-header-color simple-table-header\" style=\"width:223.6953125px\">テキスト</th><th id=\"CaUc\" class=\"simple-table-header-color simple-table-header\">文字数<br>(字数)<br></th><th id=\"CQ{d\" class=\"simple-table-header-color simple-table-header\">トークン数<br>(Jina Embeddings v2 <br>中国語および英語用)<br></th><th id=\"_};C\" class=\"simple-table-header-color simple-table-header\">トークン数/文字数の比率<br>(小数点以下 3 桁)<br></th></tr></thead><tbody><tr id=\"e75154ce-a33e-4af1-a983-4c4213f93c0e\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_wikipedia_2018_1M</code></td><td id=\"CaUc\" class=\"\">45,116,182</td><td id=\"CQ{d\" class=\"\">29,193,028</td><td id=\"_};C\" class=\"\">0.647</td></tr><tr id=\"605560a8-5c77-4add-a3e4-4615779b571a\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_news_2007-2009_1M</code></td><td id=\"CaUc\" class=\"\">44,295,314</td><td id=\"CQ{d\" class=\"\">28,108,090</td><td id=\"_};C\" class=\"\">0.635</td></tr><tr id=\"6e23944e-a480-4978-8550-a83404b218c4\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho-trad_newscrawl_2011_1M</code></td><td id=\"CaUc\" class=\"\">54,585,819</td><td id=\"CQ{d\" class=\"\">40,290,982</td><td id=\"_};C\" class=\"\">0.738</td></tr><tr id=\"50abbb96-06f7-4308-9c66-7c18f2a67721\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>Ah_Q</code></td><td id=\"CaUc\" class=\"\">41,268</td><td id=\"CQ{d\" class=\"\">25,346</td><td id=\"_};C\" class=\"\">0.614</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>トークンと文字の比率のこのようなばらつきは予想外であり、特に繁体字コーパスにおける外れ値についてはさらなる調査が必要です。それでも、中国語の場合、テキストの文字数よりも<em>少ない</em>トークンで済むと結論付けることができます。コンテンツによっては、25％から40％少なくて済むと予想できます。</p><p>Jina Embeddings v2 の中国語と英語モデルにおける英語テキストは、英語のみのモデルとほぼ同じ数のトークンを生成しました：</p>\n<!--kg-card-begin: html-->\n<table id=\"061e7c3f-d109-476d-85fb-db3b369e4f35\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"1200d074-3353-4815-ab66-a90e93ec349d\"><th id=\"v\\xv\" class=\"simple-table-header-color simple-table-header\" style=\"width:184.53125px\">Text</th><th id=\"qlUV\" class=\"simple-table-header-color simple-table-header\" style=\"width:165.3125px\">Word count<br>(Unicode Segmenter)<br></th><th id=\"=]?F\" class=\"simple-table-header-color simple-table-header\">Token count<br>(Jina Embeddings v2 for Chinese and English)<br></th><th id=\"<rlw\" class=\"simple-table-header-color simple-table-header\">Ratio of tokens to words<br>(to 3 decimal places)<br></th></tr></thead><tbody><tr id=\"2fe4e02d-94fd-4513-bfcb-7f85d66b6883\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_news_2020_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">24,243,607</td><td id=\"=]?F\" class=\"\">26,890,176</td><td id=\"<rlw\" class=\"\">1.109</td></tr><tr id=\"e7f937f4-b156-4f5d-9e0b-3041d07b1b20\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">22,825,712</td><td id=\"=]?F\" class=\"\">25,060,352</td><td id=\"<rlw\" class=\"\">1.097</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<h2 id=\"taking-tokens-seriously\">トークンを真剣に考える</h2><p>トークンは AI 言語モデルにとって重要な足場であり、この分野では研究が進行中です。</p><p>AI モデルが革新的だと証明された点の1つは、ノイズの多いデータに対して非常に頑健であることです。特定のモデルが最適なトークン化戦略を使用していない場合でも、ネットワークが十分に大きく、十分なデータがあり、適切に訓練されていれば、不完全な入力から正しい処理を学習することができます。</p><p>その結果、他の分野と比べてトークン化の改善にはあまり労力が費やされていませんが、これは変わる可能性があります。</p><p>埋め込みのユーザーとして、<a href=\"https://jina.ai/embeddings/?ref=jina-ai-gmbh.ghost.io\">Jina Embeddings のような API</a> を通じて購入する場合、特定のタスクに必要なトークン数を正確に知ることはできず、確実な数字を得るために独自のテストが必要になる場合があります。しかし、ここで提供された見積もり — 英語の場合は単語数の約110％、ドイツ語の場合は単語数の約125％、中国語の場合は文字数の約70％ — は、基本的な予算計画には十分なはずです。</p>",
  "comment_id": "65afb3ee8da8040001e17061",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/01/Untitled-design--25-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-01-23T13:41:18.000+01:00",
  "updated_at": "2024-08-14T11:38:01.000+02:00",
  "published_at": "2024-01-31T16:10:14.000+01:00",
  "custom_excerpt": "Tokenization, in LLMs, means chopping input texts up into smaller parts for processing. So why are embeddings billed by the token?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "632ae7353e4e55003d52598e",
    "name": "Scott Martens",
    "slug": "scott",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
    "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
    "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
    "website": "https://jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/a-deep-dive-into-tokenization/",
  "excerpt": "LLMでトークン化とは、入力テキストを処理のために小さな部分に分割することを意味します。では、なぜ embedding は token 単位で課金されるのでしょうか？",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Colorful speckled grid pattern with a mix of small multicolored dots on a black background, creating a mosaic effect.",
  "feature_image_caption": null
}