{
  "slug": "what-is-colbert-and-late-interaction-and-why-they-matter-in-search",
  "id": "65d3a2134a32310001f5b71b",
  "uuid": "726c942b-f6a7-4c89-a0ad-39aaad98d02f",
  "title": "ColBERT とは何か？Late Interaction とは何か？そして検索においてなぜ重要なのか？",
  "html": "<figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/jina-colbert-v2-multilingual-late-interaction-retriever-for-embedding-and-reranking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Jina ColBERT v2：埋め込みとリランキングのための多言語レイトインタラクションリトリーバー</div><div class=\"kg-bookmark-description\">Jina ColBERT v2 は 89 言語をサポートし、優れた検索性能、ユーザー制御可能な出力次元、8192 トークン長を提供します。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/colbert-banner.jpg\" alt=\"\"></div></a><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">更新：2024 年 8 月 31 日、Jina-ColBERT の第 2 版をリリースしました。性能が向上し、89 言語に対応した多言語サポートと柔軟な出力次元を実現しました。詳細はリリース記事をご確認ください。</span></p></figcaption></figure><p>先週金曜日、<a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">Hugging Face 上での Jina AI による ColBERT モデルのリリース</a>が、特に Twitter/X 上で AI コミュニティに大きな反響を呼びました。画期的な BERT モデルについては多くの人が知っていますが、ColBERT に関する話題は一部の人々に疑問を投げかけています：情報検索技術の混沌とした分野で ColBERT は何が特別なのでしょうか？なぜ AI コミュニティは 8192 長の ColBERT に興奮しているのでしょうか？この記事では、ColBERT と ColBERTv2 の詳細について、そのデザイン、改良点、そして ColBERT のレイトインタラクションの驚くべき効果を掘り下げていきます。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">検索の関連性と RAG の精度を簡単に最大化</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a></figure><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Introducing jina-colbert-v1-en. It takes late interactions &amp; token-level embeddings of ColBERTv2 and has better zero-shot performance on many tasks (in and out-of-domain). Now on <a href=\"https://twitter.com/huggingface?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">@huggingface</a> under Apache 2.0 licence<a href=\"https://t.co/snVGgI753H?ref=jina-ai-gmbh.ghost.io\">https://t.co/snVGgI753H</a></p>— Jina AI (@JinaAI_) <a href=\"https://twitter.com/JinaAI_/status/1758503072999907825?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">February 16, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><h2 id=\"what-is-colbert\">ColBERT とは何か？</h2><p>「ColBERT」という名称は、<strong>Co</strong>ntextualized <strong>L</strong>ate Interaction over <strong>BERT</strong>（BERT 上のコンテキスト化されたレイトインタラクション）の略で、スタンフォード大学から生まれたモデルです。BERT の深い言語理解を活用しながら、新しいインタラクションメカニズムを導入しています。「レイトインタラクション」として知られるこのメカニズムは、検索プロセスの最終段階までクエリとドキュメントを別々に処理することで、効率的で正確な検索を可能にします。具体的には、モデルには 2 つのバージョンがあります：</p><ul><li><strong>ColBERT</strong>：最初のモデルは、<a href=\"https://x.com/lateinteraction?s=20&ref=jina-ai-gmbh.ghost.io\"><strong>Omar Khattab</strong></a><strong> と Matei Zaharia</strong> が考案したもので、「ColBERT: Efficient and Effective Passage Search via Contextualized Late Interaction over BERT」という論文で情報検索に対する新しいアプローチを提示しました。この研究は SIGIR 2020 で発表されました。</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2004.12832?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERT: BERT 上のコンテキスト化されたレイトインタラクションによる効率的で効果的な文章検索</div><div class=\"kg-bookmark-description\">自然言語理解（NLU）の最近の進歩は、情報検索（IR）の急速な進展を促しています。これは主に、文書ランキングのための深層言語モデル（LM）のファインチューニングによるものです。これらの LM に基づくランキングモデルは驚くほど効果的ですが、単一の関連性スコアを計算するために各クエリ-文書ペアを巨大なニューラルネットワークに通す必要があるため、以前のアプローチと比べて計算コストが桁違いに増加します。これに対処するため、我々は ColBERT を提示します。これは効率的な検索のために深層 LM（特に BERT）を適応させた新しいランキングモデルです。ColBERT は、BERT を使用してクエリと文書を独立してエンコードし、その後、それらの細かい粒度の類似性をモデル化する安価だが強力なインタラクションステップを採用するレイトインタラクションアーキテクチャを導入します。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Omar Khattab</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">「レイトインタラクション」を導入したオリジナルの ColBERT 論文。</span></p></figcaption></figure><ul><li><strong>ColBERTv2</strong>：基礎研究をベースに、<strong>Omar Khattab</strong> は <strong>Barlas Oguz、Matei Zaharia、Michael S. Bernstein</strong> と共同で「ColBERTv2: Effective and Efficient Retrieval via Lightweight Late Interaction」を SIGIR 2021 で発表しました。この ColBERT の次のイテレーションでは、前バージョンの制限に対処し、<strong>ノイズ除去された教師あり学習</strong>と<strong>残差圧縮</strong>という主要な改良を導入し、モデルの検索効果と保存効率の両方を向上させました。</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2112.01488?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERTv2：軽量なレイトインタラクションによる効果的で効率的な検索</div><div class=\"kg-bookmark-description\">ニューラル情報検索（IR）は、検索や他の知識集約型言語タスクを大きく進展させました。多くのニューラル IR 手法がクエリとドキュメントを単一ベクトル表現にエンコードする一方で、レイトインタラクションモデルは各トークンの粒度で多ベクトル表現を生成し、関連性のモデリングをスケーラブルなトークンレベルの計算に分解します。この分解によりレイトインタラクションの効果が高まることが示されていますが、これらのモデルの空間フットプリントが 1 桁増加します。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Keshav Santhanam</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">ColBERTv2 はノイズ除去された教師あり学習と残差圧縮を追加し、トレーニングデータの品質を向上させ、空間フットプリントを削減しました。</span></p></figcaption></figure><h2 id=\"understand-colberts-design\">ColBERT のデザインを理解する</h2><p>ColBERTv2 のアーキテクチャは元の ColBERT と非常に似ており、主な革新はトレーニング技術と圧縮メカニズムに関するものであるため、まず元の ColBERT の基本的な側面について掘り下げていきましょう。</p><h3 id=\"what-is-late-interaction-in-colbert\">ColBERT のレイトインタラクションとは？</h3><p>「インタラクション」とは、クエリとドキュメントの表現を比較することで関連性を評価するプロセスを指します。</p><p>「<em>レイトインタラクション</em>」は ColBERT の本質です。この用語は、クエリとドキュメントの表現が独立してエンコードされた後、プロセスの後半でインタラクションが発生するというモデルのアーキテクチャと処理戦略に由来します。これは「<em>アーリーインタラクション</em>」モデルと対照的で、アーリーインタラクションではクエリとドキュメントの埋め込みが早い段階で、通常モデルによるエンコード前または途中でインタラクションします。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Interaction Type</th>\n<th>Models</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Early Interaction</td>\n<td>BERT, ANCE, DPR, Sentence-BERT, DRMM, KNRM, Conv-KNRM, etc.</td>\n</tr>\n<tr>\n<td>Late Interaction</td>\n<td>ColBERT, ColBERTv2</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>アーリーインタラクションは、すべての可能なクエリ-ドキュメントペアを考慮する必要があるため計算の複雑さが増加し、大規模なアプリケーションには効率的ではありません。</p><p>ColBERT のようなレイトインタラクションモデルは、ドキュメント表現の事前計算を可能にし、最後により軽量なインタラクションステップを採用することで、効率性とスケーラビリティを最適化します。このインタラクションステップは、すでにエンコードされた表現に焦点を当てます。このデザインの選択により、検索時間が短縮され、計算要求が軽減され、大規模なドキュメントコレクションの処理により適したものとなっています。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/colbert-blog-interaction.svg\" class=\"kg-image\" alt=\"Diagram illustrating query-document similarity with models for no, partial, and late interaction, including language mode rep\" loading=\"lazy\" width=\"300\" height=\"143\"><figcaption><span style=\"white-space: pre-wrap;\">ニューラル IR におけるクエリ・ドキュメント間の相互作用パラダイムを示す概念図。左端が ColBERT の後期相互作用を表しています。</span></figcaption></figure><h3 id=\"no-interaction-cosine-similarity-of-document-and-query-embeddings\">相互作用なし：ドキュメントとクエリの埋め込みのコサイン類似度</h3><p>多くの実用的なベクトルデータベースとニューラル検索ソリューションは、ドキュメントとクエリの埋め込み間の高速なコサイン類似度マッチングに依存しています。この方法は直感的で計算効率が良いという魅力がありますが、「相互作用なし」または「非相互作用ベース」と呼ばれ、クエリとドキュメント間の何らかの相互作用を組み込んだモデルと比較して性能が劣ることが分かっています。</p><p>「相互作用なし」アプローチの主な制限は、クエリとドキュメントの用語間の複雑なニュアンスや関係性を捉えられないことにあります。情報検索の本質は、クエリの背後にある意図とドキュメント内のコンテンツを理解しマッチングすることです。このプロセスには、関連する用語の深い文脈的理解が必要であり、ドキュメントとクエリの単一の集約された埋め込みではこれを提供することが困難です。</p><h2 id=\"query-and-document-encoders-in-colbert\">ColBERT におけるクエリとドキュメントのエンコーダー</h2><p>ColBERT のエンコーディング戦略は、言語の深い文脈理解で知られる BERT モデルに基づいています。このモデルは、クエリまたはドキュメント内の各トークンに対して密なベクトル表現を生成し、<strong>それぞれクエリとドキュメントの文脈化された埋め込みの集合を作成します。</strong>これにより、後期相互作用フェーズでの埋め込みの詳細な比較が可能になります。</p><h3 id=\"query-encoder-of-colbert\">ColBERT のクエリエンコーダー</h3><p>トークン ${q_1, q_2, ..., q_l}$ を持つクエリ $Q$ に対して、まず $Q$ を BERT ベースの WordPiece トークンにトークン化し、特殊な <code>[Q]</code> トークンを先頭に追加します。この <code>[Q]</code> トークンは BERT の <code>[CLS]</code> トークンの直後に配置され、クエリの開始を示します。</p><p>クエリが事前定義された トークン数 $N_q$ より短い場合は <code>[mask]</code> トークンで $N_q$ まで埋め込まれ、それ以外の場合は最初の $N_q$ トークンまで切り捨てられます。埋め込まれたシーケンスは BERT に通され、その後 CNN（畳み込みニューラルネットワーク）と正規化を経て、以下の $\\mathbf{E}_q$ として表される埋め込みベクトルのセットが出力されます：<br>$$\\mathbf{E}_q := \\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[Q]},q_0,q_1,\\ldots,q_l\\mathtt{[mask]},\\mathtt{[mask]},\\ldots,\\mathtt{[mask]}\\right)\\right)$$</p><h3 id=\"document-encoder-of-colbert\">ColBERT のドキュメントエンコーダー</h3><p>同様に、トークン ${d_1, d_2, ..., d_n}$ を持つドキュメント $D$ に対して、ドキュメントの開始を示す <code>[D]</code> トークンが先頭に追加されます。このシーケンスは、埋め込みの必要なく同じプロセスを経て、以下の $\\mathbf{E}_d$ として表される埋め込みベクトルのセットが生成されます：<br>$$\\mathbf{E}_d := \\mathrm{Filter}\\left(\\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[D]},d_0,d_1,...,d_n\\right)\\right)\\right)$$</p><p>クエリの埋め込みに <code>[mask]</code> トークンを使用すること（論文では<strong>クエリ拡張</strong>と呼ばれています）は、すべてのクエリで統一された長さを確保し、バッチ処理を容易にします。<code>[Q]</code> と <code>[D]</code> トークンは明示的にクエリとドキュメントの開始を示し、モデルがこれら2種類の入力を区別するのに役立ちます。</p><h3 id=\"comparing-colbert-to-cross-encoders\">ColBERT とクロスエンコーダーの比較</h3><p>クロスエンコーダーはクエリとドキュメントのペアを一緒に処理するため、非常に正確ですが、可能なすべてのペアを評価する計算コストが高いため、大規模なタスクには効率的ではありません。意味的類似性タスクや詳細なコンテンツ比較など、文ペアの正確なスコアリングが必要な特定のシナリオでは優れています。しかし、この設計は、事前計算された埋め込みと効率的な類似度計算が重要な、大規模データセットからの高速な検索が必要な状況での適用性を制限します。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/ce-vs-colbert.svg\" class=\"kg-image\" alt=\"Diagrams comparing &quot;Cross Encoder: Early all-to-all interaction&quot; and &quot;ColBERT: Late interaction&quot; with labeled Query and Docum\" loading=\"lazy\" width=\"210\" height=\"150\"></figure><p>対照的に、ColBERT の後期相互作用モデルは、ドキュメント埋め込みの事前計算を可能にし、意味解析の深さを損なうことなく検索プロセスを大幅に高速化します。クロスエンコーダーの直接的なアプローチと比較すると一見直感に反するように見えるこの方法は、リアルタイムおよび大規模な情報検索タスクに対してスケーラブルなソリューションを提供します。これは、計算効率と相互作用モデリングの品質の間の戦略的な妥協を表しています。</p><h2 id=\"finding-the-top-k-documents-using-colbert\">ColBERT を使用したトップ K ドキュメントの検索</h2><p>クエリとドキュメントの埋め込みが得られれば、最も関連性の高いトップ K ドキュメントを見つけることは簡単になります（ただし、2つのベクトルのコサインを計算するほど簡単ではありません）。</p><p>主な操作には、用語ごとの類似度を計算するためのバッチ内積計算、ドキュメント用語間のmax-poolingによるクエリ用語ごとの最高類似度の検出、クエリ用語間の合計によるドキュメントの総スコアの導出、そしてこれらのスコアに基づくドキュメントのソートが含まれます。以下に擬似 PyTorch コードを示します：</p><pre><code class=\"language-python\">import torch\n\ndef compute_relevance_scores(query_embeddings, document_embeddings, k):\n    \"\"\"\n    Compute relevance scores for top-k documents given a query.\n    \n    :param query_embeddings: Tensor representing the query embeddings, shape: [num_query_terms, embedding_dim]\n    :param document_embeddings: Tensor representing embeddings for k documents, shape: [k, max_doc_length, embedding_dim]\n    :param k: Number of top documents to re-rank\n    :return: Sorted document indices based on their relevance scores\n    \"\"\"\n    \n    # Ensure document_embeddings is a 3D tensor: [k, max_doc_length, embedding_dim]\n    # Pad the k documents to their maximum length for batch operations\n    # Note: Assuming document_embeddings is already padded and moved to GPU\n    \n    # Compute batch dot-product of Eq (query embeddings) and D (document embeddings)\n    # Resulting shape: [k, num_query_terms, max_doc_length]\n    scores = torch.matmul(query_embeddings.unsqueeze(0), document_embeddings.transpose(1, 2))\n    \n    # Apply max-pooling across document terms (dim=2) to find the max similarity per query term\n    # Shape after max-pool: [k, num_query_terms]\n    max_scores_per_query_term = scores.max(dim=2).values\n    \n    # Sum the scores across query terms to get the total score for each document\n    # Shape after sum: [k]\n    total_scores = max_scores_per_query_term.sum(dim=1)\n    \n    # Sort the documents based on their total scores\n    sorted_indices = total_scores.argsort(descending=True)\n    \n    return sorted_indices\n</code></pre><p>この手順は、トレーニングと推論時の再ランク付けの両方で使用されることに注意してください。ColBERT モデルはペアワイズランキング損失を使用してトレーニングされ、トレーニングデータは $(q, d^+, d^-)$ の三つ組で構成されます。ここで、$q$ はクエリ、$d^+$ はクエリに関連する（ポジティブな）ドキュメント、$d^-$ は関連のない（ネガティブな）ドキュメントを表します。モデルは、$q$ と $d^+$ の間の類似度スコアが $q$ と $d^-$ の間のスコアより高くなるような表現を学習することを目指します。</p><p>トレーニングの目的は、以下の損失関数を最小化することとして数学的に表現できます：$$\\mathrm{Loss} = \\max(0, 1 - S(q, d^+) + S(q, d^-))$$</p><p>ここで、$S(q, d)$ は ColBERT によって計算されるクエリ $q$ とドキュメント $d$ 間の類似度スコアを表します。このスコアは、モデルアーキテクチャで説明した後期相互作用パターンに従って、クエリとドキュメント間の最もマッチする埋め込みの最大類似度スコアを集約することで得られます。このアプローチにより、ポジティブとネガティブなドキュメントペアの類似度スコアの間でより大きなマージンを促すことで、モデルが与えられたクエリに対して関連するドキュメントと関連しないドキュメントを区別できるようにトレーニングされます。</p><h3 id=\"denoised-supervision-in-colbertv2\">ColBERTv2 のノイズ除去監督</h3><p>ColBERTv2 のノイズ除去監督は、チャレンジングなネガティブサンプルを選択し、クロスエンコーダーを使用した蒸留を活用することで、元のトレーニングプロセスを改良します。このトレーニングデータ品質を向上させる洗練された方法には、以下のステップが含まれます：</p><ol><li><strong>初期トレーニング</strong>：クエリ、関連ドキュメント、非関連ドキュメントで構成される MS MARCO データセットの公式三つ組を使用。</li><li><strong>インデックス作成と検索</strong>：ColBERTv2 の圧縮を使用してトレーニングパッセージのインデックスを作成し、各クエリに対してトップ k パッセージを検索。</li><li><strong>クロスエンコーダーによる再ランク付け</strong>：MiniLM クロスエンコーダーによる再ランク付けを通じてパッセージ選択を強化し、そのスコアを ColBERTv2 に蒸留。</li><li><strong>トレーニングタプルの形成</strong>：チャレンジングな例を作成するため、高ランクと低ランクの両方のパッセージを組み込んだ w-way タプルを生成。</li><li><strong>反復的な改良</strong>：ハードネガティブの選択を継続的に改善し、モデルの性能を向上させるためにプロセスを繰り返す。</li></ol><p>このプロセスは、ColBERT のトレーニング体制における洗練された改良を表しており、そのアーキテクチャの基本的な変更ではないことに注意してください。</p><h3 id=\"hyperparameters-of-colbert\">ColBERT のハイパーパラメーター</h3><p>ColBERT のハイパーパラメータは以下のようにまとめられます：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>ハイパーパラメータ</th>\n<th>最適な選択</th>\n<th>理由</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>学習率</td>\n<td>3 x 10^{-6}</td>\n<td>安定的で効果的なモデルの更新を確保するためのファインチューニングに選択。</td>\n</tr>\n<tr>\n<td>バッチサイズ</td>\n<td>32</td>\n<td>計算効率と更新ごとの十分な情報取得能力のバランスをとる。</td>\n</tr>\n<tr>\n<td>クエリごとの埋め込み数 (Nq)</td>\n<td>32</td>\n<td>効率的な処理を支援するため、クエリ間で一貫した表現サイズを確保するように固定。</td>\n</tr>\n<tr>\n<td>埋め込みの次元数 (m)</td>\n<td>128</td>\n<td>表現力と計算効率の良好なバランスを提供することが実証されている。</td>\n</tr>\n<tr>\n<td>学習イテレーション</td>\n<td>200k (MS MARCO), 125k (TREC CAR)</td>\n<td>過学習を避けながら十分な学習を確保するために選択され、データセットの特性に基づいて調整。</td>\n</tr>\n<tr>\n<td>埋め込みの次元あたりのバイト数</td>\n<td>4 (再ランク付け), 2 (エンドツーエンドランキング)</td>\n<td>アプリケーションのコンテキスト（再ランク付けvsエンドツーエンド）を考慮した精度と空間効率のトレードオフ。</td>\n</tr>\n<tr>\n<td>ベクトル類似度関数</td>\n<td>コサイン (再ランク付け), (二乗) L2 (エンドツーエンド)</td>\n<td>それぞれの検索コンテキストにおけるパフォーマンスと効率性に基づいて選択。</td>\n</tr>\n<tr>\n<td>FAISS インデックスパーティション (P)</td>\n<td>2000</td>\n<td>検索空間分割の粒度を決定し、検索効率に影響を与える。</td>\n</tr>\n<tr>\n<td>検索する最近傍パーティション数 (p)</td>\n<td>10</td>\n<td>検索の広さと計算効率のバランスをとる。</td>\n</tr>\n<tr>\n<td>埋め込みあたりのサブベクトル数 (s)</td>\n<td>16</td>\n<td>量子化の粒度に影響し、検索速度とメモリ使用量に影響を与える。</td>\n</tr>\n<tr>\n<td>インデックスの次元あたりの表現</td>\n<td>16 ビット値</td>\n<td>エンドツーエンド検索の第二段階で、精度と空間のトレードオフを管理するために選択。</td>\n</tr>\n<tr>\n<td>エンコーダーのレイヤー数</td>\n<td>12 レイヤー BERT</td>\n<td>文脈理解の深さと計算効率の最適なバランス。</td>\n</tr>\n<tr>\n<td>最大クエリ長</td>\n<td>128</td>\n<td>クエリエンコーダーが処理するトークンの最大数。<b>これは Jina-ColBERT モデルで拡張される。</b></td>\n</tr>\n<tr>\n<td>最大文書長</td>\n<td>512</td>\n<td>文書エンコーダーが処理するトークンの最大数。<b>これは Jina-ColBERT モデルで 8192 まで拡張される。</b></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"the-indexing-strategy-of-colbert\">ColBERT のインデックス戦略</h2><p>各文書を 1 つの埋め込みベクトルにエンコードする表現ベースのアプローチとは異なり、<strong>ColBERT は文書（およびクエリ）を埋め込みの集合としてエンコードし、文書内の各トークンが独自の埋め込みを持ちます。</strong>このアプローチは本質的に、長い文書ではより多くの埋め込みが保存されることを意味し、<strong>これは元の ColBERT の問題点であり、後に ColBERTv2 で解決されました。</strong></p><p>これを効率的に管理するカギは、ColBERT がインデックス作成と検索に（<a href=\"https://github.com/facebookresearch/faiss?ref=jina-ai-gmbh.ghost.io\">FAISS</a> などの）ベクトルデータベースを使用することと、大量のデータを効率的に処理できるように設計された詳細なインデックス作成プロセスにあります。元の ColBERT 論文では、インデックス作成と検索の効率を高めるためのいくつかの戦略が言及されています：</p><ul><li><strong>オフラインインデックス作成</strong>：文書の表現はオフラインで計算され、文書の埋め込みの事前計算と保存が可能です。このプロセスはバッチ処理と GPU アクセラレーションを活用して、大規模な文書コレクションを効率的に処理します。</li><li><strong>埋め込みストレージ</strong>：文書の埋め込みは各次元に 32 ビットまたは 16 ビット値を使用して保存でき、精度とストレージ要件のトレードオフを提供します。この柔軟性により、ColBERT は有効性（検索パフォーマンスの面で）と効率性（ストレージと計算コストの面で）のバランスを保つことができます。</li></ul><p>元の ColBERT には存在しなかった ColBERTv2 での<strong>残差圧縮</strong>の導入は、品質を維持しながらモデルの空間フットプリントを 6～10 倍削減する上で重要な役割を果たしています。この技術は、固定された参照セントロイドからの差分のみを効果的に捕捉して保存することで、埋め込みをさらに圧縮します。</p><h2 id=\"effectiveness-and-efficiency-of-colbert\">ColBERT の有効性と効率性</h2><p>BERT の深い文脈理解を検索に組み込むことは、本質的に大きな計算リソースを必要とし、高いレイテンシーと計算コストのためにリアルタイムアプリケーションには実現性が低いと当初は考えられるかもしれません。しかし、ColBERT は後期相互作用メカニズムを革新的に使用することで、この仮定に挑戦し覆します。以下が注目すべきポイントです：</p><ol><li><strong>大幅な効率性の向上</strong>：ColBERT は従来の BERT ベースのランキングモデルと比較して、計算コスト（FLOP）とレイテンシーを桁違いに削減します。具体的には、特定のモデルサイズ（例：12 レイヤーの「base」トランスフォーマーエンコーダー）において、ColBERT は BERT ベースのモデルの有効性に匹敵し、場合によってはそれを上回りながら、大幅に低い計算要求で実現します。例えば、再ランク付けの深さ <em>k</em>=10 では、BERT は ColBERT の約 180 倍の FLOP を必要とします。この差は <em>k</em> が増加するにつれて広がり、<em>k</em>=1000 で 13900 倍、<em>k</em>=2000 で 23000 倍にまで達します。</li><li><strong>エンドツーエンド検索における Recall と MRR@10 の向上</strong>：高い検索パフォーマンスには（早期相互作用モデルに見られるような）クエリと文書表現のより深い相互作用が必要だという当初の直感に反して、ColBERT のエンドツーエンド検索セットアップは優れた有効性を示します。例えば、その Recall@50 は公式の BM25 の Recall@1000 とほぼすべての他のモデルの Recall@200 を上回り、各クエリ-文書ペアの直接比較なしに広大なコレクションから関連文書を検索する際のモデルの優れた能力を強調しています。</li><li><strong>実世界アプリケーションへの実用性</strong>：実験結果は ColBERT の実世界シナリオへの実用的な適用性を強調しています。そのインデックス作成スループットとメモリ効率により、MS MARCO のような大規模な文書コレクションを数時間以内にインデックス化でき、管理可能な空間フットプリントで高い有効性を維持します。これらの特質は、パフォーマンスと計算効率の両方が最重要である本番環境への展開に ColBERT が適していることを示しています。</li><li><strong>文書コレクションのサイズに対するスケーラビリティ</strong>：おそらく最も驚くべき結論は、大規模な文書コレクションを扱う際の ColBERT のスケーラビリティと効率性です。このアーキテクチャは文書埋め込みの事前計算を可能にし、クエリ-文書相互作用の効率的なバッチ処理を活用することで、文書コレクションのサイズに応じて効果的にスケールすることができます。このスケーラビリティは、効果的な文書検索に必要な理解の複雑さと深さを考えると直感に反するものであり、ColBERT の計算効率と検索効率のバランスを取る革新的なアプローチを示しています。</li></ol><h2 id=\"using-jina-colbert-v1-en-a-8192-length-colbertv2-model\"><code>jina-colbert-v1-en</code> の使用：8192 長の ColBERTv2 モデル</h2><p>Jina-ColBERT は高速かつ正確な検索のために設計され、<a href=\"https://jina.ai/news/jina-ai-launches-worlds-first-open-source-8k-text-embedding-rivaling-openai/?ref=jina-ai-gmbh.ghost.io\">アーキテクチャの改良により長いシーケンス処理を可能にする JinaBERT の進歩を活用して、最大 8192 の長いコンテキスト長をサポート</a>します。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">厳密に言えば、Jina-ColBERT は 8190 トークン長をサポートします。ColBERT の文書エンコーダーでは、各文書の先頭に <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">[D],[CLS]</code> がパディングされることを思い出してください。</div></div><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/jina-colbert-v1-en · Hugging Face</div><div class=\"kg-bookmark-description\">私たちはオープンソースとオープンサイエンスを通じて、人工知能を進歩させ民主化する旅の途中です。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://huggingface.co/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://cdn-thumbnails.huggingface.co/social-thumbnails/models/jinaai/jina-colbert-v1-en.png\" alt=\"\"></div></a></figure><h3 id=\"jinas-improvement-over-original-colbert\">元の ColBERT に対する Jina の改良点</h3><p>Jina-ColBERT の主な進歩は、そのバックボーンである <code>jina-bert-v2-base-en</code> にあります。これは元の ColBERT が使用する <code>bert-base-uncased</code> と比較して、はるかに長いコンテキスト（最大 8192 トークン）の処理を可能にします。この能力は広範なコンテンツを持つ文書を扱い、より詳細でコンテキストに基づいた検索結果を提供する上で重要です。</p><h3 id=\"jina-colbert-v1-en-performance-comparison-vs-colbertv2\"><code>jina-colbert-v1-en</code> と ColBERTv2 のパフォーマンス比較</h3><p>私たちは <code>jina-colbert-v1-en</code> を BEIR データセットと長いコンテキストを重視する新しい LoCo ベンチマークで評価し、元の ColBERTv2 実装と非相互作用ベースの<code>jina-embeddings-v2-base-en</code> モデル。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>ColBERTv2</th>\n<th>jina-colbert-v1-en</th>\n<th>jina-embeddings-v2-base-en</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arguana</td>\n<td>46.5</td>\n<td><strong>49.4</strong></td>\n<td>44.0</td>\n</tr>\n<tr>\n<td>Climate-Fever</td>\n<td>18.1</td>\n<td>19.6</td>\n<td><strong>23.5</strong></td>\n</tr>\n<tr>\n<td>DBPedia</td>\n<td><strong>45.2</strong></td>\n<td>41.3</td>\n<td>35.1</td>\n</tr>\n<tr>\n<td>FEVER</td>\n<td>78.8</td>\n<td><strong>79.5</strong></td>\n<td>72.3</td>\n</tr>\n<tr>\n<td>FiQA</td>\n<td>35.4</td>\n<td>36.8</td>\n<td><strong>41.6</strong></td>\n</tr>\n<tr>\n<td>HotpotQA</td>\n<td><strong>67.5</strong></td>\n<td>65.9</td>\n<td>61.4</td>\n</tr>\n<tr>\n<td>NFCorpus</td>\n<td>33.7</td>\n<td><strong>33.8</strong></td>\n<td>32.5</td>\n</tr>\n<tr>\n<td>NQ</td>\n<td>56.1</td>\n<td>54.9</td>\n<td><strong>60.4</strong></td>\n</tr>\n<tr>\n<td>Quora</td>\n<td>85.5</td>\n<td>82.3</td>\n<td><strong>88.2</strong></td>\n</tr>\n<tr>\n<td>SCIDOCS</td>\n<td>15.4</td>\n<td>16.9</td>\n<td><strong>19.9</strong></td>\n</tr>\n<tr>\n<td>SciFact</td>\n<td>68.9</td>\n<td><strong>70.1</strong></td>\n<td>66.7</td>\n</tr>\n<tr>\n<td>TREC-COVID</td>\n<td>72.6</td>\n<td><strong>75.0</strong></td>\n<td>65.9</td>\n</tr>\n<tr>\n<td>Webis-touch2020</td>\n<td>26.0</td>\n<td><strong>27.0</strong></td>\n<td>26.2</td>\n</tr>\n<tr>\n<td>LoCo</td>\n<td>74.3</td>\n<td>83.7</td>\n<td><strong>85.4</strong></td>\n</tr>\n<tr>\n<td>Average</td>\n<td>51.7</td>\n<td><strong>52.6</strong></td>\n<td>51.6</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>この表は、特に長いコンテキスト長を必要とするシナリオにおいて、オリジナルの ColBERTv2 と比較して <code>jina-colbert-v1-en</code> の優れたパフォーマンスを示しています。なお、<code>jina-embeddings-v2-base-en</code> は<a href=\"https://arxiv.org/abs/2310.19923?ref=jina-ai-gmbh.ghost.io\">より多くのトレーニングデータを使用</a>していますが、<code>jina-colbert-v1-en</code> は MSMARCO のみを使用しており、これが一部のタスクにおける <code>jina-embeddings-v2-base-en</code> の良好なパフォーマンスを説明する可能性があります。</p><h3 id=\"example-usage-of-jina-colbert-v1-en\"><code>jina-colbert-v1-en</code> の使用例</h3><p>このスニペットは、長文書のサポートを示す Jina-ColBERT でのインデックス作成プロセスを概説しています。</p><pre><code class=\"language-python\">from colbert import Indexer\nfrom colbert.infra import Run, RunConfig, ColBERTConfig\n\nn_gpu: int = 1  # Set your number of available GPUs\nexperiment: str = \"\"  # Name of the folder where the logs and created indices will be stored\nindex_name: str = \"\"  # The name of your index, i.e. the name of your vector database\n\nif __name__ == \"__main__\":\n    with Run().context(RunConfig(nranks=n_gpu, experiment=experiment)):\n        config = ColBERTConfig(\n          doc_maxlen=8192  # Our model supports 8k context length for indexing long documents\n        )\n        indexer = Indexer(\n          checkpoint=\"jinaai/jina-colbert-v1-en\",\n          config=config,\n        )\n        documents = [\n          \"ColBERT is an efficient and effective passage retrieval model.\",\n          \"Jina-ColBERT is a ColBERT-style model but based on JinaBERT so it can support both 8k context length.\",\n          \"JinaBERT is a BERT architecture that supports the symmetric bidirectional variant of ALiBi to allow longer sequence length.\",\n          \"Jina-ColBERT model is trained on MSMARCO passage ranking dataset, following a very similar training procedure with ColBERTv2.\",\n          \"Jina-ColBERT achieves the competitive retrieval performance with ColBERTv2.\",\n          \"Jina is an easier way to build neural search systems.\",\n          \"You can use Jina-ColBERT to build neural search systems with ease.\",\n          # Add more documents here to ensure the clustering work correctly\n        ]\n        indexer.index(name=index_name, collection=documents)\n</code></pre><h3 id=\"use-jina-colbert-v1-en-in-ragatouille\">RAGatouille での <code>jina-colbert-v1-en</code> の使用</h3><p>RAGatouille は、RAG パイプライン内で高度な検索方法の使用を容易にする新しい Python ライブラリです。モジュール性と容易な統合のために設計されており、ユーザーが最先端の研究をシームレスに活用することを可能にします。RAGatouille の主な目的は、ColBERT のような複雑なモデルを RAG パイプラインで適用することを簡素化し、開発者が基礎となる研究について深い専門知識を必要とせずにこれらの手法を利用できるようにすることです。<a href=\"https://twitter.com/bclavie?ref=jina-ai-gmbh.ghost.io\">Benjamin Clavié</a> のおかげで、<code>jina-colbert-v1-en</code> を簡単に使用できるようになりました：</p><pre><code class=\"language-python\">from ragatouille import RAGPretrainedModel\n\n# Get your model &amp; collection of big documents ready\nRAG = RAGPretrainedModel.from_pretrained(\"jinaai/jina-colbert-v1-en\")\nmy_documents = [\n    \"very long document1\",\n    \"very long document2\",\n    # ... more documents\n]\n\n# And create an index with them at full length!\nRAG.index(collection=my_documents,\n          index_name=\"the_biggest_index\",\n          max_document_length=8190,)\n\n# or encode them in-memory with no truncation, up to your model's max length\nRAG.encode(my_documents)\n</code></pre><p>Jina-ColBERT に関する詳細な情報と更なる探求については、<a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">Hugging Face のページ</a>をご覧ください。</p><h2 id=\"conclusion\">結論</h2><p>ColBERT は情報検索の分野において大きな飛躍を表しています。Jina-ColBERT による長いコンテキスト長の実現と、ColBERT の後期相互作用アプローチとの互換性を維持することで、最先端の検索機能を実装しようとする開発者にとって強力な選択肢を提供しています。</p><p>複雑な検索モデルを RAG パイプラインに統合することを簡素化する RAGatouille ライブラリと組み合わせることで、開発者は今や高度な検索の力を容易に活用でき、ワークフローを効率化し、アプリケーションを強化することができます。Jina-ColBERT と RAGatouille の相乗効果は、高度な AI 検索モデルを実用的な使用のためにアクセスしやすく、効率的にする上で注目すべき進歩を示しています。</p>",
  "comment_id": "65d3a2134a32310001f5b71b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/02/Untitled-design--28-.png",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-02-19T19:46:43.000+01:00",
  "updated_at": "2024-08-30T23:11:22.000+02:00",
  "published_at": "2024-02-20T02:19:04.000+01:00",
  "custom_excerpt": "Jina AI's ColBERT on Hugging Face has set Twitter abuzz, bringing a fresh perspective to search with its 8192-token capability. This article unpacks the nuances of ColBERT and ColBERTv2, showcasing their innovative designs and why their late interaction feature is a game-changer for search.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/what-is-colbert-and-late-interaction-and-why-they-matter-in-search/",
  "excerpt": "Jina AI の ColBERT が Hugging Face でリリースされ、8192 トークンの処理能力を持つ新しい検索アプローチとして Twitter で話題を呼んでいます。本記事では、ColBERT と ColBERTv2 の特徴を詳しく解説し、その革新的な設計と、検索に革命をもたらす後期相互作用機能について解説します。",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Neon theater or concert hall marquee letters lit up at night with city lights and faint \"Adobe Sto\" visible.",
  "feature_image_caption": null
}