{
  "slug": "reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown",
  "id": "66dff7eba241f5000155d851",
  "uuid": "49dc11d4-e792-49d6-b778-512add9024bc",
  "title": "Reader-LM：HTML を Markdown に変換・クリーニングするための小規模言語モデル",
  "html": "<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-0.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-0.5b · Hugging Face</div><div class=\"kg-bookmark-description\">私たちはオープンソースとオープンサイエンスを通じて人工知能を発展させ、民主化する旅の途中です。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-0.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-1.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-1.5b · Hugging Face</div><div class=\"kg-bookmark-description\">私たちはオープンソースとオープンサイエンスを通じて人工知能を発展させ、民主化する旅の途中です。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-1.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>2024年4月、私たちは <a href=\"https://jina.ai/reader?ref=jina-ai-gmbh.ghost.io\">Jina Reader</a> をリリースしました。これは、単純なプレフィックス <code>r.jina.ai</code> を使用して、任意の URL を LLM フレンドリーな markdown に変換する簡単な API です。背後にある高度なネットワークプログラミングにもかかわらず、中核となる「読み取り」部分はかなり単純です。まず、ヘッドレスの Chrome ブラウザを使用してウェブページのソースを取得します。次に、Mozilla の <a href=\"https://github.com/mozilla/readability?ref=jina-ai-gmbh.ghost.io\">Readability</a> パッケージを活用して、ヘッダー、フッター、ナビゲーションバー、サイドバーなどの要素を削除しながらメインコンテンツを抽出します。最後に、<a href=\"https://x.com/JinaAI_/status/1823756993108304135?ref=jina-ai-gmbh.ghost.io\">regex</a> と <a href=\"https://github.com/mixmark-io/turndown?ref=jina-ai-gmbh.ghost.io\">Turndown ライブラリ</a>を使用して、クリーンアップされた HTML を markdown に変換します。結果として、LLM による根拠付け、要約、推論に使用できる、よく構造化された markdown ファイルが得られます。</p><p>Jina Reader のリリース後の最初の数週間で、特にコンテンツの品質に関して多くのフィードバックを受け取りました。詳細すぎると感じるユーザーもいれば、十分に詳細でないと感じるユーザーもいました。また、Readability フィルターが間違ったコンテンツを削除したり、Turndown が HTML の特定の部分を markdown に変換するのに苦労したりするという報告もありました。幸いなことに、これらの問題の多くは、既存のパイプラインに新しい regex パターンやヒューリスティックを適用することで解決されました。</p><p>それ以来、私たちは一つの疑問を抱いてきました：より多くのヒューリスティックと regex でパッチを当てる代わりに（これは維持が increasingly 困難で多言語対応にも適していません）、言語モデルを使って<em>エンドツーエンド</em>でこの問題を解決できないだろうか？</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png\" class=\"kg-image\" alt=\"Readability と turndown ライブラリに regex/heu を加えて生の HTML を Markdown 形式に変換するフローチャート\" loading=\"lazy\" width=\"1800\" height=\"945\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/Heading--48-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/Heading--48-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/Heading--48-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png 1800w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\"></span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>reader-lm</span></code><span style=\"white-space: pre-wrap;\">の図解。小規模な言語モデルを使用して readability+turndown+regex ヒューリスティクスのパイプラインを置き換えています。</span></figcaption></figure><p>一見すると、データクリーニングに LLM を使用することは、コスト効率が低く速度も遅いため過剰に思えるかもしれません。しかし、<strong>小規模言語モデル（SLM）</strong>、つまりパラメータ数が 10 億未満でエッジで効率的に実行できるモデルを考えた場合はどうでしょうか？それはずっと魅力的に聞こえますよね？しかし、これは本当に実現可能なのか、それとも単なる願望思考なのでしょうか？スケーリング則によると、パラメータが少なくなると一般的に推論や要約の能力は低下します。そのため、パラメータサイズが小さすぎる場合、SLM は意味のあるコンテンツを生成することすら困難かもしれません。これをさらに探るために、HTML から Markdown への変換タスクを詳しく見てみましょう：</p><ul><li>まず、私たちが考えているタスクは<strong>一般的な LLM タスクほど創造的で複雑ではありません</strong>。HTML から markdown への変換の場合、モデルは主に入力から出力への<strong>選択的コピー</strong>（つまり、HTML マークアップ、サイドバー、ヘッダー、フッターをスキップする）を行い、新しいコンテンツの生成（主に markdown 構文の挿入）に費やす労力は最小限です。これは、詩を生成したりコードを書いたりするような、出力がより多くの創造性を必要とし、入力からの単純なコピー＆ペーストではない LLM の一般的なタスクとは大きく異なります。このことから、タスクが比較的<em>シンプル</em>に見えるため、SLM が機能する可能性があることが示唆されます。</li><li>第二に、<strong>長いコンテキストのサポートを優先する必要があります</strong>。現代の HTML には、単純な <code>&lt;div&gt;</code> マークアップよりもはるかに多くのノイズが含まれていることがよくあります。インライン CSS やスクリプトによって、コードは容易に数十万トークンまで膨らむ可能性があります。このシナリオで SLM を実用的にするためには、コンテキスト長が十分に大きくなければなりません。8K や 16K といったトークン長は<em>全く</em>役に立ちません。</li></ul><p>私たちが必要としているのは、<strong><em>浅くて広い</em></strong> SLM のようです。「浅い」というのは、タスクが主に単純な「コピー＆ペースト」であり、より少ないトランスフォーマーブロックで済むという意味です。そして「広い」というのは、実用的であるために長いコンテキストのサポートが必要で、アテンション機構に注意を払う必要があるという意味です。過去の研究では、コンテキスト長と推論能力は密接に関連していることが示されています。SLM にとって、パラメータサイズを小さく保ちながら両方の次元を最適化することは非常に困難です。</p><p>本日、私たちは <code>reader-lm-0.5b</code> と <code>reader-lm-1.5b</code> のリリースにより、この解決策の第一版を発表できることを嬉しく思います。これらは、<strong>ノイズの多い生の HTML からきれいな markdown を直接生成する</strong>ように特別に訓練された 2 つの SLM です。両モデルは多言語対応で、最大 <strong>256K トークン</strong>のコンテキスト長をサポートします。コンパクトなサイズにもかかわらず、これらのモデルはこのタスクで最先端の性能を達成し、サイズが 1/50 でありながら、より大きな LLM を上回る性能を示しています。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Reader-LM-vs-LLMs-on-the-HTML2Markdown-task--1-.svg\" class=\"kg-image\" alt=\"様々な LLM と比較して Reader-LM が HTML2Markdown タスクで最高スコア 0.72 を達成したことを示す棒グラフ\" loading=\"lazy\" width=\"805\" height=\"514\"></figure><p>以下が 2 つのモデルの仕様です：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">reader-lm-0.5b</th>\n<th style=\"text-align:center\">reader-lm-1.5b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>パラメータ数</td>\n<td style=\"text-align:center\">494M</td>\n<td style=\"text-align:center\">1.54B</td>\n</tr>\n<tr>\n<td>コンテキスト長</td>\n<td style=\"text-align:center\">256K</td>\n<td style=\"text-align:center\">256K</td>\n</tr>\n<tr>\n<td>隠れ層サイズ</td>\n<td style=\"text-align:center\">896</td>\n<td style=\"text-align:center\">1536</td>\n</tr>\n<tr>\n<td>レイヤー数</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n<tr>\n<td>クエリヘッド数</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td>KV ヘッド数</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td>ヘッドサイズ</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">128</td>\n</tr>\n<tr>\n<td>中間サイズ</td>\n<td style=\"text-align:center\">4864</td>\n<td style=\"text-align:center\">8960</td>\n</tr>\n<tr>\n<td>多言語対応</td>\n<td style=\"text-align:center\">はい</td>\n<td style=\"text-align:center\">はい</td>\n</tr>\n<tr>\n<td>HuggingFace リポジトリ</td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-0.5b/?ref=jina-ai-gmbh.ghost.io\">リンク</a></td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-1.5b/?ref=jina-ai-gmbh.ghost.io\">リンク</a></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"get-started-with-reader-lm\">Reader-LM を使い始める</h2><h3 id=\"on-google-colab\">Google Colab で</h3><p><code>reader-lm</code> を体験する最も簡単な方法は、Colab ノートブックを実行することです。このノートブックでは、<code>reader-lm-1.5b</code> を使用して Hacker News のウェブサイトを markdown に変換する方法を紹介しています。このノートブックは Google Colab の無料 T4 GPU tier でスムーズに実行できるように最適化されています。<code>reader-lm-0.5b</code> を読み込んだり、URL を任意のウェブサイトに変更して出力を探索したりすることもできます。モデルへの入力（つまりプロンプト）は生の HTML であり、プレフィックスの指示は必要ないことに注意してください。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/1wXWyj5hOxEHY6WeHbOwEzYAC0WB1I5uA?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/colab_favicon_256px.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>無料版の T4 GPU には、モデル実行時の高度な最適化の使用を制限する制約があることにご注意ください。T4 では bfloat16 や flash attention などの機能が利用できないため、長い入力に対して VRAM 使用量が増加し、パフォーマンスが低下する可能性があります。<strong>本番環境では、大幅に優れたパフォーマンスを得るために、RTX 3090/4090 のような上位 GPU の使用をお勧めします。</strong></p><h3 id=\"in-production-available-on-azure-aws-soon\">本番環境：近日 Azure と AWS で利用可能</h3><p>Reader-LM は Azure Marketplace と AWS SageMaker で利用できます。これらのプラットフォーム以外や社内でオンプレミスでこれらのモデルを使用する必要がある場合は、両モデルが CC BY-NC 4.0 ライセンスの下で提供されていることにご注意ください。<a href=\"https://jina.ai/contact-sales/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">商用利用についてのお問い合わせは、お気軽にご連絡ください。</a></p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-nli7b6dueo424?sr=0-1&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 0.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-ms27ixcwq3wjk?sr=0-2&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 1.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-500m?tab=Overview&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-1500m?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><h2 id=\"benchmark\">ベンチマーク</h2><p>Reader-LM のパフォーマンスを定量的に評価するため、以下の大規模言語モデルと比較しました：GPT-4o、Gemini-1.5-Flash、Gemini-1.5-Pro、LLaMA-3.1-70B、Qwen2-7B-Instruct。</p><p>モデルは以下の指標で評価されました：</p><ul><li><strong>ROUGE-L（高いほど良い）</strong>：要約や質問応答タスクで広く使用されるこの指標は、予測出力と参照との n-gram レベルでの重なりを測定します。</li><li><strong>Token Error Rate（TER、低いほど良い）</strong>：この指標は、生成された markdown トークンが元の HTML コンテンツに現れない割合を計算します。この指標は、モデルのハルシネーション率を評価し、モデルが HTML に基づかないコンテンツを生成するケースを特定するために設計されました。ケーススタディに基づいてさらなる改善が行われる予定です。</li><li><strong>Word Error Rate（WER、低いほど良い）</strong>：OCR や ASR タスクで一般的に使用される WER は、単語シーケンスを考慮し、挿入（ADD）、置換（SUB）、削除（DEL）などのエラーを計算します。この指標は、生成された markdown と期待される出力との間のミスマッチを詳細に評価します。</li></ul><p>このタスクで LLM を活用するため、以下の統一された指示をプレフィックスプロンプトとして使用しました：</p><pre><code>Your task is to convert the content of the provided HTML file into the corresponding markdown file. You need to convert the structure, elements, and attributes of the HTML into equivalent representations in markdown format, ensuring that no important information is lost. The output should strictly be in markdown format, without any additional explanations.</code></pre><p>結果は以下の表の通りです。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ROUGE-L</th>\n<th>WER</th>\n<th>TER</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reader-lm-0.5b</td>\n<td>0.56</td>\n<td>3.28</td>\n<td>0.34</td>\n</tr>\n<tr>\n<td>reader-lm-1.5b</td>\n<td><strong>0.72</strong></td>\n<td><strong>1.87</strong></td>\n<td><strong>0.19</strong></td>\n</tr>\n<tr>\n<td>gpt-4o</td>\n<td>0.43</td>\n<td>5.88</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>gemini-1.5-flash</td>\n<td>0.40</td>\n<td>21.70</td>\n<td>0.55</td>\n</tr>\n<tr>\n<td>gemini-1.5-pro</td>\n<td>0.42</td>\n<td>3.16</td>\n<td>0.48</td>\n</tr>\n<tr>\n<td>llama-3.1-70b</td>\n<td>0.40</td>\n<td>9.87</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>Qwen2-7B-Instruct</td>\n<td>0.23</td>\n<td>2.45</td>\n<td>0.70</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"qualitative-study\">定性的研究</h2><p>出力された markdown を視覚的に検査することで定性的研究を実施しました。<a href=\"https://docs.google.com/spreadsheets/d/1Wb2sMdiEoToPaXohcrEznFKStt_4alVOnJD3WKkiM7o/edit?gid=1576339853&ref=jina-ai-gmbh.ghost.io#gid=1576339853\">英語、ドイツ語、日本語、中国語の複数言語による、ニュース記事、ブログ投稿、ランディングページ、E コマースページ、フォーラム投稿を含む 22 の HTML ソースを選択しました</a>。また、正規表現、ヒューリスティクス、事前定義ルールに依存する Jina Reader API をベースラインとして含めました。</p><p>評価は出力の 4 つの重要な側面に焦点を当て、各モデルを 1（最低）から 5（最高）のスケールで評価しました：</p><ol><li><strong>ヘッダー抽出</strong>：各モデルが h1、h2、...、h6 ヘッダーを正しい markdown 構文を使用して識別し、フォーマットする能力を評価。</li><li><strong>メインコンテンツ抽出</strong>：段落、リストのフォーマット、プレゼンテーションの一貫性を維持しながら、本文を正確に変換するモデルの能力を評価。</li><li><strong>豊かな構造の保持</strong>：見出し、小見出し、箇条書き、順序付きリストを含む文書の全体的な構造を効果的に維持する各モデルの能力を分析。</li><li><strong>Markdown 構文の使用</strong>：<code>&lt;a&gt;</code>（リンク）、<code>&lt;strong&gt;</code>（太字）、<code>&lt;em&gt;</code>（イタリック）などの HTML 要素を適切な markdown 相当に正しく変換する各モデルの能力を評価。</li></ol><p>結果は以下の通りです。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Qualitative-Evaluation-of-Reader-LM-vs-LLMs-and-Jina-Reader-API--1-.svg\" class=\"kg-image\" alt=\"ヘッダー抽出やコンテンツ保持などの指標で Reader-LM、LLM、Jina Reader API を比較する棒グラフ。\" loading=\"lazy\" width=\"863\" height=\"533\"></figure><p>Reader-LM-1.5B は全ての側面で一貫して良好なパフォーマンスを示し、特に構造の保持と markdown 構文の使用で優れています。Jina Reader API を常に上回るわけではありませんが、そのパフォーマンスは Gemini 1.5 Pro のような大規模モデルと競合しており、より大きな LLM に対する非常に効率的な代替手段となっています。Reader-LM-0.5B は小規模ながら、特に構造の保持において solid なパフォーマンスを提供します。</p><h2 id=\"how-we-trained-reader-lm\">Reader-LM の学習方法</h2><h3 id=\"data-preparation\">データ準備</h3><p>Jina Reader API を使用して、生の HTML とそれに対応する markdown のトレーニングペアを生成しました。実験中、SLM がトレーニングデータの品質に特に敏感であることがわかりました。そのため、高品質な markdown エントリーのみをトレーニングセットに含めるデータパイプラインを構築しました。</p><p>さらに、<code>GPT-4o</code> によって生成された合成 HTML とその markdown 対応を追加しました。実世界の HTML と比較して、合成データは一般的にはるかに短く、よりシンプルで予測可能な構造を持ち、ノイズレベルが大幅に低くなっています。</p><p>最後に、チャットテンプレートを使用して HTML と markdown を連結しました。最終的なトレーニングデータは以下のようにフォーマットされています：</p><pre><code>&lt;|im_start|&gt;system\nYou are a helpful assistant.&lt;|im_end|&gt;\n&lt;|im_start|&gt;user\n{{RAW_HTML}}&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n{{MARKDOWN}}&lt;|im_end|&gt;\n</code></pre><p>トレーニングデータの総量は 25 億トークンです。</p><h3 id=\"two-stage-training\">2 段階のトレーニング</h3><p>私たちは 65M から 135M、そして 3B パラメータまでの様々なモデルサイズで実験を行いました。各モデルの仕様は以下の表の通りです。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>reader-lm-65m</th>\n<th>reader-lm-135m</th>\n<th>reader-lm-360m</th>\n<th>reader-lm-0.5b</th>\n<th>reader-lm-1.5b</th>\n<th>reader-lm-1.7b</th>\n<th>reader-lm-3b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hidden Size</td>\n<td>512</td>\n<td>576</td>\n<td>960</td>\n<td>896</td>\n<td>1536</td>\n<td>2048</td>\n<td>3072</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td>8</td>\n<td>30</td>\n<td>32</td>\n<td>24</td>\n<td>28</td>\n<td>24</td>\n<td>32</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td>16</td>\n<td>9</td>\n<td>15</td>\n<td>14</td>\n<td>12</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td>8</td>\n<td>3</td>\n<td>5</td>\n<td>2</td>\n<td>2</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n<td>128</td>\n<td>64</td>\n<td>96</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td>2048</td>\n<td>1536</td>\n<td>2560</td>\n<td>4864</td>\n<td>8960</td>\n<td>8192</td>\n<td>8192</td>\n</tr>\n<tr>\n<td>Attention Bias</td>\n<td>False</td>\n<td>False</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Embedding Tying</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Vocabulary Size</td>\n<td>32768</td>\n<td>49152</td>\n<td>49152</td>\n<td>151646</td>\n<td>151646</td>\n<td>49152</td>\n<td>32064</td>\n</tr>\n<tr>\n<td>Base Model</td>\n<td>Lite-Oute-1-65M-Instruct</td>\n<td>SmolLM-135M</td>\n<td>SmolLM-360M-Instruct</td>\n<td>Qwen2-0.5B-Instruct</td>\n<td>Qwen2-1.5B-Instruct</td>\n<td>SmolLM-1.7B</td>\n<td>Phi-3-mini-128k-instruct</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>モデルのトレーニングは2段階で行われました：</p><ol><li><strong>短くて単純な HTML：</strong>この段階では、最大シーケンス長（HTML + markdown）を 32K トークンに設定し、合計 15 億トレーニングトークンを使用しました。</li><li><strong>長くて複雑な HTML：</strong>シーケンス長を 128K トークンまで拡張し、12 億トレーニングトークンを使用しました。この段階では、<a href=\"https://github.com/zhuzilin/ring-flash-attention?ref=jina-ai-gmbh.ghost.io\">Zilin Zhu の \"Ring Flash Attention\"（2024）</a>からジグザグリングアテンション機構を実装しました。</li></ol><p>トレーニングデータには 128K トークンまでのシーケンスが含まれていたため、モデルは 256K トークンまでは問題なく対応できると考えています。ただし、512K トークンの処理は困難かもしれません。なぜなら、RoPE 位置エンベッディングをトレーニングシーケンス長の4倍まで拡張すると、性能が低下する可能性があるためです。</p><p>65M と 135M パラメータのモデルでは、短いシーケンス（1K トークン未満）に対して妥当な「コピー」動作を達成できることがわかりましたが、入力長が増加すると、これらのモデルは合理的な出力を生成することが困難になりました。現代の HTML ソースコードは簡単に 100K トークンを超えることがあるため、1K トークンの制限では全く不十分です。</p><h3 id=\"degeneration-and-dull-loops\">劣化と単調なループ</h3><p>私たちが直面した主な課題の1つは、特に繰り返しやループの形での劣化でした。トークンを生成した後、モデルは同じトークンを繰り返し生成したり、短いトークン列を最大出力長に達するまで連続して繰り返すループに陥ったりしていました。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png\" class=\"kg-image\" alt=\"Dark themed coding script with repeated structural programming comments about data types, functions, and mathematical operati\" loading=\"lazy\" width=\"2000\" height=\"1278\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/image-1.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png 2040w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">劣化の例：モデルは通常の markdown 生成で始まりますが、突然「単調なループ」に陥ります（赤い矢印で示されています）。</span></figcaption></figure><p>この問題に対処するため：</p><ul><li>デコード方法として<a href=\"https://github.com/yxuansu/SimCTG?ref=jina-ai-gmbh.ghost.io\">対照的探索（contrastive search）</a>を適用し、トレーニング中に対照的損失を組み込みました。実験の結果、この方法は実際に繰り返し生成を効果的に削減しました。</li><li>transformer パイプライン内に単純な繰り返し停止基準を実装しました。この基準は、モデルがトークンの繰り返しを始めた時点を自動的に検出し、単調なループを避けるために早期にデコードを停止します。このアイデアは、この<a href=\"https://github.com/huggingface/transformers/issues/32902?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\">議論</a>からインスピレーションを得ました。</li></ul><h3 id=\"training-efficiency-on-long-inputs\">長い入力に対するトレーニング効率</h3><p>長い入力を処理する際のメモリ不足（OOM）エラーのリスクを軽減するため、チャンク単位のモデル転送を実装しました。このアプローチでは、長い入力を小さなチャンクでエンコードし、VRAM の使用量を削減します。</p><p>Transformers Trainer をベースにしたトレーニングフレームワークでデータパッキングの実装を改善しました。トレーニング効率を最適化するために、複数の短いテキスト（例：2K トークン）を1つの長いシーケンス（例：30K トークン）に連結し、パディングのないトレーニングを実現します。しかし、元の実装では、一部の短い例が2つのサブテキストに分割され、異なる長いトレーニングシーケンスに含まれていました。このような場合、2番目のサブテキストはコンテキスト（この場合は生の HTML コンテンツ）を失い、トレーニングデータが破損します。これにより、モデルは入力コンテキストではなくパラメータに依存せざるを得なくなり、これが幻覚の主要な原因になると考えています。</p><p>最終的に、私たちは 0.5B と 1.5B のモデルを公開用に選択しました。<strong>0.5B モデルは、長いコンテキスト入力に対して望ましい「選択的コピー」動作を達成できる最小のモデル</strong>であり、1.5B モデルはパラメータサイズに対して収穫逓減に達することなく、性能を大幅に向上させる最小の大型モデルです。</p><h3 id=\"alternative-architecture-encoder-only-model\">代替アーキテクチャ：エンコーダーのみのモデル</h3><p>このプロジェクトの初期段階では、この課題に取り組むためにエンコーダーのみのアーキテクチャも検討しました。前述のように、HTML から Markdown への変換タスクは主に「選択的コピー」タスクのように見えます。トレーニングペア（生の HTML と markdown）が与えられた場合、入力と出力の両方に存在するトークンを <code>1</code>、それ以外を <code>0</code> としてラベル付けすることができます。これにより、問題を Named Entity Recognition（NER）で使用されるようなトークン分類タスクに変換できます。</p><p>このアプローチは論理的に見えましたが、実践では重大な課題がありました。まず、実世界のソースからの生の HTML は非常にノイジーで長く、<code>1</code> のラベルが極めて疎になるため、モデルが学習するのが困難でした。次に、<code>## title</code>、<code>*bold*</code>、<code>| table |</code> のような特殊な markdown 構文を <code>0-1</code> スキーマでエンコードすることが問題となりました。これらの記号は生の HTML 入力には存在しないためです。第三に、出力トークンは必ずしも入力の順序に厳密に従わないことです。特にテーブルやリンクでは、マイナーな順序の変更がしばしば発生し、このような順序変更の動作を単純な <code>0-1</code> スキーマで表現することが困難でした。短距離の順序変更は、動的プログラミングやアライメント・ワーピングアルゴリズムを用いて、距離のオフセットを表す <code>-1, -2, +1, +2</code> のようなラベルを導入することで、バイナリ分類問題をマルチクラストークン分類タスクに変換することで、潜在的に処理できたかもしれません。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png\" class=\"kg-image\" alt=\"Chart titled &quot;Token-Level DP Alignment (Horizontal)&quot; with tokens on the x-axis and alignment on the y-axis, highlighting best\" loading=\"lazy\" width=\"2000\" height=\"1436\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/output--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/output--2-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/output--2-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png 2179w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">トークンレベルのトレーニングラベルを作成するために、動的プログラミングを使用して生の HTML（X軸）と markdown（Y軸）を整列させます。</span></figcaption></figure><p>要約すると、エンコーダーのみのアーキテクチャで問題を解決し、トークン分類タスクとして扱うことには魅力があります。特に、デコーダーのみのモデルと比較してトレーニングシーケンスがはるかに短くなり、VRAM の使用がより効率的になります。しかし、<strong>主な課題は良質なトレーニングデータの準備にあります。</strong>動的プログラミングやヒューリスティックを使用して完璧なトークンレベルのラベリングシーケンスを作成するためのデータ前処理に費やす時間と労力が膨大であることに気付いた時点で、このアプローチを中止することを決定しました。</p><h2 id=\"conclusion\">結論</h2><p>Reader-LM は、オープンウェブ上のデータ抽出とクリーニングのために設計された革新的な小規模言語モデル（SLM）です。Jina Reader にインスパイアされ、生の雑多な HTML をクリーンなマークダウンに変換できる、エンドツーエンドの言語モデルソリューションを作ることを目指しました。同時に、コスト効率を重視し、モデルサイズを小さく保つことで、Reader-LM の実用性と使いやすさを確保しています。<strong>これは Jina AI で初めて訓練されたデコーダーオンリーの長文コンテキストモデルでもあります。</strong></p><p>一見すると単純な「選択的コピー」の問題に見えるかもしれませんが、HTML をマークダウンに変換してクリーニングすることは決して容易ではありません。具体的には、モデルが位置を意識したコンテキストベースの推論に優れている必要があり、これには特に隠れ層において大きなパラメータサイズが求められます。それに比べて、マークダウン構文の学習は比較的単純です。</p><p>実験の過程で、SLM を一からトレーニングすることは特に困難であることも判明しました。事前訓練済みモデルから開始し、タスク固有のトレーニングを継続することで、トレーニングの効率が大幅に向上しました。効率性と品質の両面でまだ改善の余地があります：コンテキスト長の拡張、デコードの高速化、入力における指示のサポート追加（これにより Reader-LM がウェブページの特定の部分をマークダウンに抽出できるようになります）などです。</p>",
  "comment_id": "66dff7eba241f5000155d851",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/09/reader-lm-banner.jpg",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-09-10T09:40:27.000+02:00",
  "updated_at": "2024-09-20T14:09:30.000+02:00",
  "published_at": "2024-09-11T12:25:03.000+02:00",
  "custom_excerpt": "Reader-LM-0.5B and Reader-LM-1.5B are two novel small language models inspired by Jina Reader, designed to convert raw, noisy HTML from the open web into clean markdown.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "62e3d0ef9cd5ce003d5e49e2",
      "name": "Jina AI",
      "slug": "company",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
      "cover_image": null,
      "bio": "Creator of neural search, contributor to open source.",
      "website": "https://www.jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@JinaAI_",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/company/"
    }
  ],
  "tags": [
    {
      "id": "655b2782bb728c000101bed7",
      "name": "Press",
      "slug": "press",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
    }
  ],
  "primary_author": {
    "id": "62e3d0ef9cd5ce003d5e49e2",
    "name": "Jina AI",
    "slug": "company",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
    "cover_image": null,
    "bio": "Creator of neural search, contributor to open source.",
    "website": "https://www.jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@JinaAI_",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/company/"
  },
  "primary_tag": {
    "id": "655b2782bb728c000101bed7",
    "name": "Press",
    "slug": "press",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown/",
  "excerpt": "Reader-LM-0.5B と Reader-LM-1.5B は、Jina Reader にインスパイアされた 2 つの新しい小規模言語モデルで、オープンウェブ上の生の雑多な HTML をクリーンな markdown に変換するために設計されました。",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Technical screenshot displaying \"REAPER-LM-0.5B/1.5B\" with HTML source code for Jina's search grounding feature.",
  "feature_image_caption": null
}