{
  "slug": "snippet-selection-and-url-ranking-in-deepsearch-deepresearch",
  "id": "67d13ae9099ee70001bed48b",
  "uuid": "84611c0f-675d-4838-b809-4ced6cf842a9",
  "title": "DeepSearch/DeepResearch におけるスニペット選択と URL ランキング",
  "html": "<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/a-practical-guide-to-implementing-deepsearch-deepresearch\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">DeepSearch/DeepResearch 実装の実践ガイド</div><div class=\"kg-bookmark-description\">QPS アウト、深さイン。DeepSearch が新しい標準に。読む-検索する-推論するループで答えを見つける。それが何であり、どのように構築するかを学ぼう。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-128x128-22.png\" alt=\"\"><span class=\"kg-bookmark-author\">Jina AI</span><span class=\"kg-bookmark-publisher\">Han Xiao</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/a-practical-guide-to-implementing-deepsearch-deepresearch-1.webp\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>DeepSearch/DeepResearch の実装ガイドを既にお読みの方は、品質を大きく向上させる詳細についてさらに深く掘り下げていきましょう。この投稿では、2 つの重要な課題に焦点を当てます：<strong>長いウェブページからスニペットを選択するための埋め込みの活用</strong>と<strong>クロールする URL の優先順位付けにリランカーを使用すること</strong>です。</p><p>以前の結論で「埋め込みは STS タスク（意味的テキスト類似性）のようなクエリの重複排除にのみ有用で、リランカーは当初の DeepSearch 実装には含まれていなかった」と述べたことを覚えている方もいるでしょう。しかし、実は両方とも依然として非常に価値があることがわかりました - ただし、従来の期待とは異なる方法で。私たちは常に可能な限り<em>シンプル</em>な方法を追求してきました。埋め込みやリランカーのプロバイダーとしての存在価値を正当化するためだけに、コンポーネントを追加することはしません。<strong>私たちは検索が本質的に必要とするものに基づいています。</strong></p><p>数週間の実験と改良を重ねた結果、DeepSearch/DeepResearch システムにおける両者の一般的ではないが効果的な使用方法を発見しました。これらを適用することで、<a href=\"https://search.jina.ai\" rel=\"noreferrer\">Jina DeepSearch</a> の品質を大幅に向上させました（ぜひお試しください）。この分野で働く実践者の皆様と、これらの知見を共有したいと思います。</p><h2 id=\"select-snippet-from-long-content\">長いコンテンツからスニペットを選択する</h2><p>問題は次のとおりです：<a href=\"https://jina.ai/reader\">Jina Reader を使用してウェブページのコンテンツを読み取った</a>後、それを推論のためにエージェントのコンテキストに知識項目として追加する必要があります。完全なコンテンツを LLM のコンテキストウィンドウにダンプすることが最も簡単な方法ですが、トークンコストと生成速度を考慮すると最適ではありません。実際には、コンテンツのどの部分が質問に最も関連しているかを特定し、それらの部分のみをエージェントのコンテキストに知識として選択的に追加する必要があります。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Jina Reader のマークダウンクリーニング後でもコンテンツが長すぎる場合について話しています。これは GitHub の issue、Reddit のスレッド、フォーラムの議論、ブログ投稿（jina.ai/news の多くを含む）のような長いページでよく発生します。</div></div><p>LLM ベースのフィルタリングには同様のコストと遅延の問題があるため、より小さなモデルのソリューションを見つけましょう：より小さく安価で、<strong>しかもマルチリンガルなモデル</strong>が必要です - クエリもドキュメントも常に英語であるとは限らないため、これは重要な要素です。</p><p>一方にはクエリ（元のクエリまたはギャップクエリ）があり、もう一方には大部分が関連性のない大きなマークダウンコンテンツがあります。クエリに最も関連性の高いスニペットを選択する必要があります。これは 2023 年以来 RAG コミュニティが取り組んできたチャンキングの問題に似ています - 要約のためのコンテキストウィンドウに配置する関連チャンクのみを retriever モデルを使用して取得することです。ただし、私たちのケースには 2 つの重要な違いがあります：</p><ol><li>限られた数のドキュメントからの限られたチャンク。各チャンクが約 500 トークンを含む場合、典型的な長いウェブドキュメントは約 200,000 トークン（p50）から 1,000,000 トークン（p99）を含み、各ステップで Jina Reader を使用して 4-5 個の URL を取得すると、数百のチャンク - つまり数百の埋め込みベクトルと数百のコサイン類似度が生成されます。これはベクターデータベースなしで JavaScript のメモリ内で簡単に管理できます。</li><li>効果的な知識スニペットを形成するために連続したチャンクが必要です。<code>[1-2, 6-7, 9, 14, 17, ...]</code>のような散在する文を組み合わせたスニペットは受け入れられません。より有用な知識スニペットは<code>[3-15, 17-24, ...]</code>のようなパターンに従い、常に連続したテキストを維持します。これにより、LLM が知識ソースからコピーして引用しやすくなり、幻覚が減少します。</li></ol><p>残りは実践者が指摘してきた注意点すべてです：埋め込みモデルは長いコンテキストを適切に処理できないため、各チャンクは長すぎてはいけません；チャンキングはコンテキストの損失を引き起こし、チャンク埋め込みを i.i.d にします；そして読みやすさとセマンティクスの両方を維持する最適な境界キューをどのように見つけるのか？これらの問題について知っているなら、RAG の実装でこれらの問題に悩まされた経験があるでしょう。</p><p>しかし長い話を短くすると - <strong>late-chunking と <code>jina-embeddings-v3</code> が 3 つの問題すべてを見事に解決します。</strong>Late chunking は各チャンクのコンテキスト情報を維持し、<a href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii#late-chunking-is-resilient-to-poor-boundary-cues\">境界キューに影響されにくく</a>、<code>jina-embeddings-v3</code> 自体が<em>非対称な</em>多言語検索タスクで SOTA です。詳細に興味のある読者は私たちのブログ投稿や論文をご覧ください。以下が全体的な実装です。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/03/Untitled-design--14-.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1200\" height=\"1000\"><figcaption><span style=\"white-space: pre-wrap;\">この図は、</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Conv1D</span></code><span style=\"white-space: pre-wrap;\">と同様に動作するスニペット選択アルゴリズムを示しています。プロセスは長いドキュメントを固定長のチャンクに分割することから始まり、その後 late-chunking トグルをオンにした</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\">で埋め込みます。各チャンクとクエリ間の類似度スコアを計算した後、スライディングウィンドウが類似度スコアを移動して、最高の平均値を持つウィンドウを見つけます。</span></figcaption></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Late Chunking とは何か、そうでないものは何か：パート II</div><div class=\"kg-bookmark-description\">Late Chunking の探究パート 2、チャンク埋め込みと検索/RAG パフォーマンスの向上に最適な方法である理由について深く掘り下げます。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-128x128-23.png\" alt=\"\"><span class=\"kg-bookmark-author\">Jina AI</span><span class=\"kg-bookmark-publisher\">Han Xiao</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/what-late-chunking-really-is-and-what-its-not-part-ii.webp\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2409.10173\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jina-embeddings-v3：タスク LoRA を使用した多言語埋め込み</div><div class=\"kg-bookmark-description\">5 億 7000 万のパラメータを持つ新しいテキスト埋め込みモデル jina-embeddings-v3 を紹介します。多言語データと長文コンテキスト検索タスクで最先端の性能を達成し、最大 8192 トークンのコンテキスト長をサポートします。このモデルには、クエリ-ドキュメント検索、クラスタリング、分類、テキストマッチングのための高品質な埋め込みを生成するタスク固有の Low-Rank Adaptation（LoRA）アダプターのセットが含まれています。MTEB ベンチマークでの評価では、jina-embeddings-v3 は英語タスクで OpenAI と Cohere の最新の独自埋め込みを上回り、すべての多言語タスクで multilingual-e5-large-instruct を上回る性能を達成しています。デフォルトの出力次元は 1024 ですが、Matryoshka Representation Learning により、性能を損なうことなく埋め込み次元を最小 32 まで柔軟に削減できます。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/apple-touch-icon-9.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Saba Sturua</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/arxiv-logo-fb-5.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2409.04701\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Late Chunking：長文コンテキスト埋め込みモデルを使用したコンテキスチュアルチャンク埋め込み</div><div class=\"kg-bookmark-description\">多くのユースケースでは、テキストの小さな部分を検索する必要があり、密ベクターベースの検索システムは、セマンティクスが埋め込みで過度に圧縮される可能性が低いため、より短いテキストセグメントでより良いパフォーマンスを発揮することが多いです。そのため、実践者はテキストドキュメントを小さなチャンクに分割し、それらを個別にエンコードすることがよくあります。しかし、このように作成されたチャンク埋め込みは周囲のチャンクからのコンテキスト情報を失う可能性があり、最適とは言えない表現になります。本論文では、late chunking と呼ばれる新しい手法を紹介します。これは、長文コンテキスト埋め込みモデルを使用して最初に長いテキストのすべてのトークンを埋め込み、トランスフォーマーモデルの後、平均プーリングの直前にチャンキングを適用します - そのため late という名前が付いています。結果として得られるチャンク埋め込みは完全なコンテキスト情報を捉え、様々な検索タスクで優れた結果をもたらします。この手法は広範な長文コンテキスト埋め込みモデルに適用できるほど汎用的で、追加のトレーニングなしで機能します。late chunking の効果をさらに高めるために、埋め込みモデルの専用の微調整アプローチを提案します。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/apple-touch-icon-10.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Michael Günther</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/arxiv-logo-fb-6.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-javascript\">function cherryPick(question, longContext, options) {\n  if (longContext.length &lt; options.snippetLength * options.numSnippets)\n    return longContext;\n  \n  const chunks = splitIntoChunks(longContext, options.chunkSize);\n  \n  const chunkEmbeddings = getEmbeddings(chunks, \"retrieval.passage\");\n  const questionEmbedding = getEmbeddings([question], \"retrieval.query\")[0];\n  \n  const similarities = chunkEmbeddings.map(embed =&gt; \n    cosineSimilarity(questionEmbedding, embed));\n  \n  const chunksPerSnippet = Math.ceil(options.snippetLength / options.chunkSize);\n  const snippets = [];\n  const similaritiesCopy = [...similarities];\n  \n  for (let i = 0; i &lt; options.numSnippets; i++) {\n    let bestStartIndex = 0;\n    let bestScore = -Infinity;\n    \n    for (let j = 0; j &lt;= similarities.length - chunksPerSnippet; j++) {\n      const windowScores = similaritiesCopy.slice(j, j + chunksPerSnippet);\n      const windowScore = average(windowScores);\n      \n      if (windowScore &gt; bestScore) {\n        bestScore = windowScore;\n        bestStartIndex = j;\n      }\n    }\n    \n    const startIndex = bestStartIndex * options.chunkSize;\n    const endIndex = Math.min(startIndex + options.snippetLength, longContext.length);\n    snippets.push(longContext.substring(startIndex, endIndex));\n    \n    for (let k = bestStartIndex; k &lt; bestStartIndex + chunksPerSnippet; k++)\n      similaritiesCopy[k] = -Infinity;\n  }\n  \n  return snippets.join(\"\\n\\n\");\n}</code></pre><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">問題に関して最適なスニペットを選択するために、後期チャンキングと Conv1D のような平均プーリングを使用します。</span></p></figcaption></figure><p>Jina Embeddings API を呼び出す際は、以下のように retrieval <code>task</code>、<code>late_chunking</code>、<code>truncate</code> を設定してください：</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-javascript\">await axios.post(\n  'https://api.jina.ai/v1/embeddings',\n  {\n    model: \"jina-embeddings-v3\",\n    task: \"retrieval.passage\",\n    late_chunking: true,\n    input: chunks,\n    truncate: true\n  }, \n  { headers }); </code></pre><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">質問を埋め込む際は、</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>task</span></code><span style=\"white-space: pre-wrap;\"> を </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>retrieval.query</span></code><span style=\"white-space: pre-wrap;\"> に変更し、</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>late_chunking</span></code><span style=\"white-space: pre-wrap;\"> をオフにしてください</span></p></figcaption></figure><p>完全な実装は Github で確認できます：</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/jina-ai/node-DeepResearch/blob/main/src/tools/jina-latechunk.ts\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">node-DeepResearch/src/tools/jina-latechunk.ts at main · jina-ai/node-DeepResearch</div><div class=\"kg-bookmark-description\">Keep searching, reading webpages, reasoning until it finds the answer (or exceeding the token budget) - jina-ai/node-DeepResearch</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/pinned-octocat-093da3e6fa40-5.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">jina-ai</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/0921e515-0139-4540-bca4-52042b49328c-2\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><h2 id=\"rank-url-for-next-read\">次に読むべき URL のランク付け</h2><p>問題は次の通りです：DeepSearch セッション中に、検索エンジン結果ページ（SERP）から多くの URL を収集し、個々のウェブページを読むたびにさらに多くの URL（ページ内のリンク）を発見することになります。ユニークな URL の総数は簡単に数百に達する可能性があります。ここでも、すべての URL を単純に LLM のコンテキストに直接投入するのは非効率です - 貴重なコンテキストウィンドウのスペースを無駄にし、さらに問題なのは、<strong>LLM が本質的にランダムに URL を選択することがわかっています。</strong> 必要な回答を含む可能性が最も高い URL に LLM を導くことが重要です。</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-bash\">curl https://r.jina.ai/https://example.com \\\n  -H \"Accept: application/json\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-Retain-Images: none\" \\\n  -H \"X-Md-Link-Style: discarded\" \\\n  -H \"X-Timeout: 20\" \\\n  -H \"X-With-Links-Summary: all\"</code></pre><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">DeepSearch で Jina Reader を使用してページをクロールする最適なオプション。これにより、すべてのページ内リンクが別の </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>links</span></code><span style=\"white-space: pre-wrap;\"> フィールドに収集され、</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>content</span></code><span style=\"white-space: pre-wrap;\"> フィールドから削除されます。</span></p></figcaption></figure><p>この問題を、セッション中に数百の URL の重み付けが必要なコンテキスト内 PageRank として考えてください。私たちは、最終更新時間、ドメインの頻度、パス構造、そして最も重要なクエリへの意味的関連性を組み合わせて複合スコアを作成し、それに基づいて URL のランク付けを行います。URL を実際に訪問する<em>前</em>に利用可能な情報のみを使用することを忘れないでください：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/03/url-ranking-illustration--2-.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"199\" height=\"150\"></figure><p><strong>頻度シグナル</strong>：異なるソースで複数回出現する URL は追加の重みを受けます。検索結果で頻繁に出現するドメインの URL はブーストを受けます。人気のあるドメインには権威のあるコンテンツが含まれていることが多いためです。</p><p><strong>パス構造</strong>：コンテンツクラスターを識別するために URL パスを分析します。共通のパス階層内の URL はより高いスコアを受け、より深いパスには減衰係数が適用されます。</p><p><strong>意味的関連性</strong>：質問と各 URL のテキスト情報の間の意味的関連性を評価するために <code>jina-reranker-v2-base-multilingual</code> を使用します。これは<a href=\"https://jina.ai/reranker/#what_reranker\" rel=\"noreferrer\">典型的な再ランキング問題</a>です。各 URL のテキスト情報は以下から得られます：</p><ul><li>SERP API 結果のタイトルとスニペット（<code>https://s.jina.ai/</code> と <code>'X-Respond-With': 'no-content'</code> を使用）</li><li>ページ内 URL のアンカーテキスト（<code>https://r.jina.ai</code> と <code>'X-With-Links-Summary': 'all'</code> を使用）</li></ul><p><strong>最終更新時間</strong>：一部の DeepSearch クエリは時間に敏感であるため、最近更新された URL は古い URL よりも価値があります。Google のような主要な検索エンジンではない場合、最終更新時間を確実に判断することは困難です。私たちは、必要に応じて新しいコンテンツを優先する信頼度スコア付きのタイムスタンプを提供する、以下のシグナルを組み合わせた多層アプローチを実装しています。</p><ul><li>SERP API フィルター（s.jina.ai の最新性でフィルタリングする <code>tbs</code> パラメータなど）</li><li>HTTP ヘッダー分析（Last-Modified、ETag）</li><li>メタデータ抽出（メタタグ、Schema.org タイムスタンプ）</li><li>コンテンツパターン認識（HTML 内の可視日付）</li><li>WordPress、Drupal、Ghost などのプラットフォーム固有のインジケータ</li></ul><p><strong>ゲートコンテンツ：</strong>ソーシャルメディアプラットフォームの一部のコンテンツはゲート制または単純に有料壁の背後にあり、ログインせずに、または利用規約に違反せずに、このコンテンツを取得する正当な方法はありません。アクセスできないコンテンツに時間を無駄にしないよう、問題のある URL とホスト名のリストを積極的に維持し、それらのランキングを下げるべきです。</p><p><strong>ドメインの多様性：</strong>場合によっては、最も重み付けの高い URL がすべて同じホスト名から来ていることがあり、これによって DeepSearch がローカルな最適解に陥り、最終的な結果の品質が低下する可能性があります。上記の例では、上位の URL がすべて StackOverflow からのものです。多様性を改善するために、各ホスト名から上位 k 個のランク付けされた URL を選択する探索-活用アプローチを実装できます。</p><p>URL ランキングの完全な実装は Github で確認できます。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/jina-ai/node-DeepResearch/blob/main/src/utils/url-tools.ts#L192\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">node-DeepResearch/src/utils/url-tools.ts at main · jina-ai/node-DeepResearch</div><div class=\"kg-bookmark-description\">Keep searching, reading webpages, reasoning until it finds the answer (or exceeding the token budget) - jina-ai/node-DeepResearch</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/pinned-octocat-093da3e6fa40-6.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">jina-ai</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/0921e515-0139-4540-bca4-52042b49328c-3\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-xml\">&lt;action-visit&gt;\n- Crawl and read full content from URLs, you can get the fulltext, last updated datetime etc of any URL.  \n- Must check URLs mentioned in &lt;question&gt; if any\n- Choose and visit relevant URLs below for more knowledge. higher weight suggests more relevant:\n&lt;url-list&gt;\n  + weight: 0.20 \"https://huggingface.co/docs/datasets/en/loading\": \"Load - Hugging FaceThis saves time because instead of waiting for the Dataset builder download to time out, Datasets will look directly in the cache. Set the environment ...Some datasets may have more than one version based on Git tags, branches, or commits. Use the revision parameter to specify the dataset version you want to load ...\"\n  + weight: 0.20 \"https://huggingface.co/docs/datasets/en/index\": \"Datasets - Hugging Face🤗 Datasets is a library for easily accessing and sharing datasets for Audio, Computer Vision, and Natural Language Processing (NLP) tasks. Load a dataset in a ...\"\n  + weight: 0.17 \"https://github.com/huggingface/datasets/issues/7175\": \"[FSTimeoutError] load_dataset · Issue #7175 · huggingface/datasetsWhen using load_dataset to load HuggingFaceM4/VQAv2, I am getting FSTimeoutError. Error TimeoutError: The above exception was the direct cause of the following ...\"\n  + weight: 0.15 \"https://github.com/huggingface/datasets/issues/6465\": \"`load_dataset` uses out-of-date cache instead of re-downloading a ...When a dataset is updated on the hub, using load_dataset will load the locally cached dataset instead of re-downloading the updated dataset.\"\n  + weight: 0.12 \"https://stackoverflow.com/questions/76923802/hugging-face-http-request-on-data-from-parquet-format-when-the-only-way-to-get-i\": \"Hugging face HTTP request on data from parquet format when the ...I've had to get the data from their data viewer using the parquet option. But when I try to run it, there is some sort of HTTP error. I've tried downloading ...\"\n&lt;/url-list&gt;\n&lt;/action-visit&gt;</code></pre><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">URL の重みをエージェントのコンテキストに入れ、LLM にその重みを尊重するよう指示することを忘れないでください。</span></p></figcaption></figure><h2 id=\"conclusion\">結論</h2><p>DeepSearch システムの 2025 年 2 月 2 日のリリース以降、品質を大幅に向上させた 2 つの実装の詳細を発見しました。興味深いことに、どちらも多言語エンベディングとリランカーを「インコンテキスト」方式で活用しており、これらのモデルが通常必要とする事前計算されたインデックスよりもはるかに小規模で動作します。これが私たちが最初に見落としていた理由です。</p><p>これは検索技術の未来における興味深い二極化を示唆しています。カーネマンの二重過程理論に類似したフレームワークを考えてみましょう：</p><ul><li>高速思考（grep、BM25、SQL）：最小限の計算要求で、素早く、ルールに基づいたパターンマッチング。</li><li>遅速思考（LLM）：深い文脈理解を伴う包括的な推論で、かなりの計算を必要とする。</li><li>中速思考（エンベディング、リランカー）：リンボ状態？ 単純なパターンマッチングには高度/意味的すぎるが、真の推論能力は欠如。</li></ul><p>軽量で効率的な SQL/BM25 が初期コンテンツ検索を処理し、直接強力な LLM に送って深い処理を行う二分化されたアーキテクチャの人気を目の当たりにしているのかもしれません。これらの LLM は、以前は特殊な中間レベルのモデルを必要とした意味的機能を increasingly 組み込んでいます。中速思考モデルの残された役割は、フィルタリング、重複排除、完全な推論が非効率的な場合の限定的な操作など、特殊なインコンテキストタスクにシフトしています。</p><p>それにもかかわらず、重要なスニペットの選択と URL のランク付けは、DeepSearch/DeepResearch システムの品質に直接影響を与える基本的なコンポーネントであり続けています。私たちの知見が皆様の実装の改善のきっかけとなることを願っています。</p><p>クエリ拡張は引き続き重要な品質決定要因です。基本的なプロンプトベースの書き換えから、小規模言語モデルや推論ベースの手法まで、複数のアプローチを積極的に評価しています。この分野における新しい発見にご期待ください。続報をお待ちください。</p>",
  "comment_id": "67d13ae9099ee70001bed48b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/03/Heading--89-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-03-12T08:42:33.000+01:00",
  "updated_at": "2025-03-12T14:20:43.000+01:00",
  "published_at": "2025-03-12T14:20:43.000+01:00",
  "custom_excerpt": "Nailing these two details transforms your DeepSearch from mid to GOAT: selecting the best snippets from lengthy webpages and ranking URLs before crawling.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/snippet-selection-and-url-ranking-in-deepsearch-deepresearch/",
  "excerpt": "長いWebページから最適なスニペットを選択することと、クロール前にURLをランク付けすることという2つのポイントを押さえることで、あなたの DeepSearch は平凡なものから最高のものへと変貌します。",
  "reading_time": 11,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}