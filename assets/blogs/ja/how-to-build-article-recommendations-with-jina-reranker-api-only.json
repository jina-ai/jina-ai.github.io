{
  "slug": "how-to-build-article-recommendations-with-jina-reranker-api-only",
  "id": "65f53dc48ff065000146db23",
  "uuid": "70844a2b-50c2-458a-a609-a5bb11530451",
  "title": "Jina Reranker API だけを使って記事レコメンデーションを構築する方法",
  "html": "<p>2 週間前に<a href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\">Reranker API</a> を導入し、市場での主要な再ランキングソリューションとして確立しました。Jina Reranker は、<a href=\"https://jina.ai/news/maximizing-search-relevancy-and-rag-accuracy-with-jina-reranker?ref=jina-ai-gmbh.ghost.io\">様々なベンチマークで一般的なベースラインを上回る性能を示し、BM25 の結果と比較して最大 +33% のヒット率向上を実現しています。</a>性能は印象的ですが、私が本当に興奮しているのは Reranker API の可能性です。そのシンプルなインターフェースは、クエリとドキュメントのリストを入力し、再ランク付けされた top-k の結果を直接出力することができます。これは理論的には、BM25、埋め込み、ベクトルデータベース、あるいはパイプラインを必要とせず、Reranker のみを使用して検索や推薦システムを構築し、エンドツーエンドの機能を実現できることを意味します。</p><p>このコンセプトに非常に興味をそそられ、実験せずにはいられませんでした。そこで、当社のウェブサイトのニュースページ（現在閲覧中のページなど）で、<code><strong>@</strong></code> キーを押して「関連記事トップ 5 を取得」ボタンをクリックすると、<code>jina-reranker-v1</code> モデルを使用して約 5 秒以内に（<code>jina-colbert-v1</code> モデルの場合はやや長く）、現在の記事に最も関連する 5 つの記事が表示されます。すべての計算はオンラインで実行され、完全に Reranker API によって管理されています。以下は、その動作を示すビデオデモです：</p><figure class=\"kg-card kg-video-card kg-width-regular kg-card-hascaption\" data-kg-thumbnail=\"https://jina-ai-gmbh.ghost.io/content/media/2024/03/recommender_thumb.jpg\" data-kg-custom-thumbnail=\"\">\n            <div class=\"kg-video-container\">\n                <video src=\"https://jina-ai-gmbh.ghost.io/content/media/2024/03/recommender.mp4\" poster=\"https://img.spacergif.org/v1/1174x796/0a/spacer.png\" width=\"1174\" height=\"796\" playsinline=\"\" preload=\"metadata\" style=\"background: transparent url('https://jina-ai-gmbh.ghost.io/content/media/2024/03/recommender_thumb.jpg') 50% 50% / cover no-repeat;\"></video>\n                <div class=\"kg-video-overlay\">\n                    <button class=\"kg-video-large-play-icon\" aria-label=\"Play video\">\n                        <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                            <path d=\"M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z\"></path>\n                        </svg>\n                    </button>\n                </div>\n                <div class=\"kg-video-player-container\">\n                    <div class=\"kg-video-player\">\n                        <button class=\"kg-video-play-icon\" aria-label=\"Play video\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <path d=\"M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z\"></path>\n                            </svg>\n                        </button>\n                        <button class=\"kg-video-pause-icon kg-video-hide\" aria-label=\"Pause video\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <rect x=\"3\" y=\"1\" width=\"7\" height=\"22\" rx=\"1.5\" ry=\"1.5\"></rect>\n                                <rect x=\"14\" y=\"1\" width=\"7\" height=\"22\" rx=\"1.5\" ry=\"1.5\"></rect>\n                            </svg>\n                        </button>\n                        <span class=\"kg-video-current-time\">0:00</span>\n                        <div class=\"kg-video-time\">\n                            /<span class=\"kg-video-duration\">0:33</span>\n                        </div>\n                        <input type=\"range\" class=\"kg-video-seek-slider\" max=\"100\" value=\"0\">\n                        <button class=\"kg-video-playback-rate\" aria-label=\"Adjust playback speed\">1×</button>\n                        <button class=\"kg-video-unmute-icon\" aria-label=\"Unmute\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <path d=\"M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z\"></path>\n                            </svg>\n                        </button>\n                        <button class=\"kg-video-mute-icon kg-video-hide\" aria-label=\"Mute\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <path d=\"M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z\"></path>\n                            </svg>\n                        </button>\n                        <input type=\"range\" class=\"kg-video-volume-slider\" max=\"100\" value=\"100\">\n                    </div>\n                </div>\n            </div>\n            <figcaption><p><span style=\"white-space: pre-wrap;\">このデモを実行するには、十分なトークンが残っている API キーが必要です。クォータを使い切ってデモを実行できない場合は、</span><a href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\" target=\"_new\"><span style=\"white-space: pre-wrap;\">https://jina.ai/reranker</span></a><span style=\"white-space: pre-wrap;\">で新しいキーを生成できます。新しいキーにはそれぞれ 100 万の無料トークンが付いてきます。</span></p></figcaption>\n        </figure><h2 id=\"implementation\">実装</h2><p>実装はとてもシンプルです：<code>jina.ai/news/</code>上の特定の記事に関連する記事を見つけるために、現在読んでいる記事を<strong>クエリとして</strong>、そして他の 230+ の記事（フルテキストを使用！）を<strong>ドキュメントとして</strong>使用します（もちろん現在の記事は除きます）。そして、この $(q, d_1, d_2, \\cdots, d_{230})$ をペイロードとして Reranker API に送信します。レスポンスを受け取ったら、ソートされたドキュメントインデックスを使用して結果を表示します。したがって、基本的なコードは以下の通りです：</p><pre><code class=\"language-js\">const getRecommendedArticles = async () =&gt; {\n  \n  const query = `${currentNews.title} ${currentNews.excerpt}`;\n  const docs = newsStore.allBlogs.filter((item) =&gt; item.slug !== currentNews.slug);\n  \n  const data = {\n    model: modelName,\n    query: query,\n    documents: docs,\n    top_n: 5,\n  }\n\n  const rerankUrl = 'https://api.jina.ai/v1/rerank';\n  const headers = {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${apiKey}`,\n  };\n  const modelName = 'jina-reranker-v1-base-en';\n  \n  const res = await fetch(rerankUrl, {\n    method: 'POST',\n    headers: headers,\n    body: JSON.stringify(data),\n  });\n\n  const resp = await res.json();\n\n  const topKList = resp.results.map((item) =&gt; {\n    return docs[item.index];\n  });\n\n  console.log(topKList);\n}</code></pre><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">検索の関連性と RAG の精度を簡単に最大化</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">API キーを取得するには、Reranker API ページにアクセスして API セクションに移動するだけです。すでに Embedding API の API キーをお持ちの場合は、それをここで再利用できます。</span></p></figcaption></figure><p>このように、実装にわずか 10 分程度で、最初のイテレーションとしては非常に有望な結果が得られます。</p><p>読者の方々はこの実装について懸念を抱くかもしれませんが、一部の批判は考えすぎかもしれず、一方で妥当な指摘もあります：</p><ul><li><strong>長すぎるフルテキストとチャンキングの必要性に関する懸念は考えすぎかもしれません</strong>：<code>jina-reranker-v1</code> モデルは長さ 512 までのクエリと任意の長さのドキュメントを処理でき、<code>jina-colbert-v1</code> モデルはクエリとドキュメントの両方で 8192 まで処理できます。したがって、フルテキストを Reranker API に入力することは必要ないかもしれません。両モデルは長いコンテキストを効率的に処理できるため、心配する必要はありません。チャンキングは、埋め込み-ベクトル検索-再ランクパイプラインの中で最も面倒で経験的な側面かもしれませんが、ここではあまり問題になりません。ただし、長いコンテキストはより多くのトークンを必要とし、これは API の有料ユーザーが考慮する必要があるかもしれません。この例では、233 記事すべてのフルテキストを使用するため、1 回の再ランククエリで 30 万以上のトークンを消費します。</li><li><strong>生データとクリーニング済みデータの品質への影響</strong>。データクリーニングを追加することで、確かに改善が見込めます。例えば、単に HTML タグを削除するだけでも（つまり <code>docs.map(item =&gt; item.html.replace(/&lt;[^&gt;]*&gt;?/gm, '')</code>）、<code>jina-reranker-v1</code> モデルの推薦品質が大幅に向上することが観察されています。ただし、<code>jina-colbert-v1</code> モデルではその効果はそれほど顕著ではありません。これは、ColBERT モデルが <code>jina-reranker-v1</code> モデルよりもノイズのあるテキストに対してより寛容になるように訓練されていたことを示唆しています。</li><li><strong>異なるクエリ構築方法の品質への影響。</strong>上記の実装では、現在の記事のタイトルと抜粋を直接クエリとして使用しました。これは最適なアプローチなのでしょうか？<code>\"What is the most related article to...\"</code>のようなプレフィックスを追加することで、<code>\"最高の記事を推薦してくれたら 20 ドルのチップを渡します\"</code> のような、大規模言語モデルで使用されるようなプロンプトは有効なのでしょうか？これは、モデルの学習データ分布に関連する興味深い疑問を投げかけており、私たちは今後さらに探求していく予定です。</li><li>クエリ構築に関する前述のポイントを発展させると、ユーザーの最近の閲覧履歴を使用したパーソナライズされた推薦など、クエリの構成能力をさらに調査することは興味深いでしょう。特に、システムがクエリ内の肯定的な例だけでなく<strong>否定的な例も理解できるか</strong>、例えば <code>NOT_LIKE</code> 演算子、<code>\"この記事のような内容は推薦しないで\"</code> や <code>\"このような記事は減らしてほしい\"</code> などが理解できるかどうかは興味深い点です。次のセクションでこれについてさらに掘り下げていきます。</li></ul><h2 id=\"empirical-study-on-query-writing\">クエリ作成に関する実証研究</h2><p>Jina Reranker API を使用したさまざまなクエリ作成の探求において、上位 10 件の結果に焦点を当て、人間によるラベリング（つまり、私たち自身による評価）を通じて定性的な評価を行いました。これは、私たちがウェブサイト上のすべてのコンテンツについて完全な知識を持っているため理にかなっています。私たちが検証したクエリ作成の戦略は以下の通りです：</p><ul><li>記事のタイトル、抜粋、およびタイトル + 抜粋の組み合わせを使用する。</li><li>\"more like this\"、\"not like this\"、\"what is the most closely related article?\" などの「プロンプト」のような指示を採用する。</li></ul><p>リランカーの有効性をテストするため、200 以上の投稿から成る広範なカタログの中から最も関連性の高い記事を特定するという、LLM における「干し草の中の針」にヒントを得たチャレンジとして、2 つの非自明な記事をクエリ対象として選択しました。以下では、これらの「針」を分かりやすくするため緑色でハイライトしています。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/image.png\" class=\"kg-image\" alt=\"Screenshot of a table ranking articles on search technology relevance, featuring titles, excerpts, and 'More Like' or 'Not Li\" loading=\"lazy\" width=\"2000\" height=\"758\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/image.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/03/image.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2024/03/image.png 2400w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">研究の包括的な結果は</span><a href=\"https://docs.google.com/spreadsheets/d/1XDOXjP6IVK1hXk3gKkng_cOpTrmS9Hm1UKCGvW1wMxU/edit?usp=sharing&ref=jina-ai-gmbh.ghost.io\"><span style=\"white-space: pre-wrap;\">このスプレッドシート</span></a><span style=\"white-space: pre-wrap;\">で詳しく説明されています。</span></figcaption></figure><h2 id=\"summary\">まとめ</h2><p>テスト結果に基づいて、以下の観察と要約を行いました：</p><ol><li>タイトルと抜粋を組み合わせることで最良のリランキング結果が得られ、抜粋がリランキングの品質を向上させる重要な役割を果たしています。</li><li>「プロンプト」のような指示を組み込んでも改善は見られませんでした。</li><li>現在のリランカーモデルは、肯定的または否定的な修飾子を効果的に処理できません。\"more like\"、\"less like\"、\"not like\" などの用語はリランカーには理解できません。</li></ol><p>ポイント 2 と 3 から得られた知見は、リランカーの将来の改良に向けて興味深い方向性を提供しています。並べ替えのロジックを変更するためのオンザフライプロンプティングを可能にすることで、リランカーの機能が大幅に拡張され、パーソナライズされたコンテンツのキュレーション/推薦など、新たな潜在的なアプリケーションが実現できると考えています。</p>",
  "comment_id": "65f53dc48ff065000146db23",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--1-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-03-16T07:35:48.000+01:00",
  "updated_at": "2024-03-17T19:26:09.000+01:00",
  "published_at": "2024-03-17T06:38:36.000+01:00",
  "custom_excerpt": "You can build an article recommendation system with just the Jina Reranker API—no pipeline, no embeddings, no vector search, only reranking. Find out how in 20 lines of code.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "1",
      "name": "Engineering Group",
      "slug": "engineering",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/1.png",
      "cover_image": null,
      "bio": "We do opensource, we do neural search, we do creative AI, we do MLOps. We do we.",
      "website": "https://github.com/jina-ai",
      "location": "Berlin, Germany",
      "facebook": null,
      "twitter": "@jinaai_",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/engineering/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "1",
    "name": "Engineering Group",
    "slug": "engineering",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/1.png",
    "cover_image": null,
    "bio": "We do opensource, we do neural search, we do creative AI, we do MLOps. We do we.",
    "website": "https://github.com/jina-ai",
    "location": "Berlin, Germany",
    "facebook": null,
    "twitter": "@jinaai_",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/engineering/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/how-to-build-article-recommendations-with-jina-reranker-api-only/",
  "excerpt": "Jina Reranker APIを使うだけで記事推薦システムを構築できます—パイプラインも、埋め込みも、ベクトル検索も必要ありません。リランキングだけです。20行のコードでその方法をご紹介します。",
  "reading_time": 5,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Black background with a grid, multiple smiley faces, and a cursor pointing to one of them.",
  "feature_image_caption": null
}