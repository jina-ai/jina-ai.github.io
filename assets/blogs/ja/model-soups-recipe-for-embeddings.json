{
  "slug": "model-soups-recipe-for-embeddings",
  "id": "681b63a077c406000104263b",
  "uuid": "e3fc45b3-6cf9-4a0b-863f-bc4a8417c436",
  "title": "埋め込みに対する Model Soup のレシピ",
  "html": "<p>このような困難な時代には、温かいスープに勝るものはありません。</p><p>ミネストローネは、イタリアの定番スープの1つで、豆、滋養のある野菜、米またはパスタを組み合わせた、濃厚でボリュームがあり、風味豊かなスープです。その味は、多様な材料を組み合わせることで生まれます。東ヨーロッパのボルシチ、アメリカのキャセロール、太平洋アジアの自家製炒め物のように、手頃な価格の材料を組み合わせて愛される料理にしている点で似ています。</p><p><a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a> に始まる一連の論文によると、ニューラルネットワークモデルにも同じようなレシピを使用できます。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://proceedings.mlr.press/v162/wortsman22a.html\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time</div><div class=\"kg-bookmark-description\">The conventional recipe for maximizing model accuracy is to (1) train multiple models with various hyperparameters and (2) pick the individual model which performs best on a held-out validation set…</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-pmlr.ico\" alt=\"\"><span class=\"kg-bookmark-author\">PMLR</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://proceedings.mlr.press/v162/assets/images/logo-pmlr.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>「モデルスープ」（残念ながら「モデルキャセロール」や「モデル炒め物」ではありません）は、トレーニングデータとモデルのハイパーパラメータの最適化にかかるコストを軽減するように設計されたモデルアンサンブル手法の一種です。ニューラルネットワークをトレーニングする場合、通常、さまざまなデータとハイパーパラメータ値を試し、最高のパフォーマンスが得られる結果を探して複数回トレーニングします。トレーニングは計算コストが非常に高く、コストはすぐに増加します。</p><p>代わりに、モデルスープでは、通常と同じように、さまざまなハイパーパラメータとトレーニングデータの選択肢を使用して複数のモデルをトレーニングしますが、それらを組み合わせます。その結果、単一の最高のパフォーマンスを発揮するモデルよりも、パフォーマンスが高く、堅牢なモデルが得られます。複数のモデルをトレーニングするため、コストは削減されませんが、同じ価格でより良い結果を得ることができます。</p><p>モデルスープのアプローチは、テキスト-画像マルチモーダル埋め込みモデル <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">(Wortsman et al. 2022)</a> および生成的大規模言語モデルですでに有用であることが証明されています。（<a href=\"https://doi.org/10.1038/s42256-024-00975-8\">Takuya et al. 2025</a>）Jina AI では、この手法を使用して独自のモデルのトレーニングを開始しており、<code>jina-embeddings-v3</code> と <code>reader-lm-v2</code> の両方にモデルスープが組み込まれています。</p><p>この記事では、モデルスープについて見ていき、それらを使用した作業の結果を示します。具体的には、次のとおりです。</p><ol><li>モデルスープを使用して、トレーニングのさまざまな時点でモデルをマージすることにより、パフォーマンスを向上させることができますか？</li><li>異なるデータセットでトレーニングされたモデルと、異なるタスクのためにトレーニングされたモデルをマージして、単一のモデルをトレーニングするよりも優れたパフォーマンスと高いトレーニング効率を得ることができますか？</li></ol><p>これには、重要な潜在的な利点があります。</p><ul><li>モデルスープは、より優れた、より堅牢なパフォーマンスを発揮できます。</li><li>多言語埋め込みモデルは、トレーニングデータの量の不均衡によって引き起こされるバイアスとパフォーマンスの低下に悩まされることがよくあります。各タスクまたはデータセットで個別に可能な限り最高のモデルをトレーニングし、それらを均等に組み合わせることができるのは恩恵となるでしょう。</li><li>モデルをモジュール式に変更し、一度に1つのコンポーネントモデルを更新し、他のモデルと再マージすることで、より優れた継続的な学習とモデルの更新を行うことができる可能性があります。</li></ul><h2 id=\"how-does-it-work\">その仕組み</h2><p>複数のモデルの出力をマージすることは、統計的意思決定理論では古い手法です。たとえば、天気予報では、複数のモデルを作成し、多くの場合、異なる仮定を持つ異なる人々によって作成し、さまざまなメカニズムを使用して予測を平均化するのが一般的な方法です。各モデルのエラーがランダムに分布している場合、モデルを平均化すると、エラーの少ない回答が得られます。</p><p>たとえば、「はい」または「いいえ」のバイナリを出力する3つの異なるモデルがあり、それぞれが10％の時間間違っている場合、3つのうち2つが間違っているのはわずか2.8％の時間です。5つのモデルで、多数決基準を使用すると、間違っているのはわずか0.856％の時間です。</p><p>平均化モデルは同じ原理で機能しますが、異なるモデルの出力を組み合わせるのではなく、モデル自体を組み合わせます。</p><p>使用されるアプローチは、<em>確率的重み平均化</em>（<a href=\"https://auai.org/uai2018/proceedings/papers/313.pdf\">Izmailov et al. 2018</a>）の拡張であり、ニューラルネットワークの損失地形に関する洞察に基づいており、単純な重み平均化が一般的な条件下でモデルの汎化性能を向上させる可能性があることを示しています。</p><p>モデルを平均化する実際のメカニズムは、驚くほど単純です。複数のモデルの重みを平均化するだけです。</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/05/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"380\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/05/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/05/image.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2025/05/image.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2025/05/image.png 2400w\" sizes=\"(min-width: 1200px) 1200px\"><figcaption><span style=\"white-space: pre-wrap;\">モデルスープを作成するためにモデルをマージする方法。この例は非常に小さくて単純ですが、手順を示しています。重みを合計し、マージするモデルの数で割ります。</span></figcaption></figure><p>これが簡単すぎると思われる場合は、この方法でモデルをマージする場合に制限があることに注意することが重要です。任意の2つのニューラルネットワークの重みをマージして、それが機能することを期待することはできません。</p><p>モデルの平均化は、非常に類似したモデル、つまり、重みが最初から互いに大きく異ならないモデルでのみ機能します。これを確実にする方法は、1つのモデルを事前トレーニングし、異なるハイパーパラメータまたは異なるデータで微調整することにより、そのモデルの複数のバリアントを作成することです。これらのモデルは通常、平均化するのに十分似ています。</p><p>より専門的な用語では、事前トレーニングでは通常、重みが損失盆地の底の近くにあるモデルが生成され、微調整ではその損失盆地から簡単に抜け出すことはできません。マージするすべてのモデルの重みが同じ損失盆地にある場合、それらの重みはほぼ同じになり、それらを平均化するとうまくいく可能性があります。これは保証されていませんが、経験的には、それが有用であるのに十分な頻度で当てはまるようです。</p><h2 id=\"experimental-setup\">実験設定</h2><p><strong>ベースモデル</strong>：ここで説明する実験では、<a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\">FacebookAI の <code>xlm-roberta-base</code></a>（<a href=\"https://aclanthology.org/2020.acl-main.747/\">Conneau et al. 2020</a>）を事前トレーニング済みのベースモデルとして使用しました。このモデルには2億8000万のパラメータがあり、約100言語のテキストを含む2.5TB の Common Crawl データで事前トレーニングされています。</p><p>実験を行う前に、埋め込みトレーニング用にキュレーションされた文ペアトレーニングセットで <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code></a> を微調整しました。</p><p><strong>トレーニングデータ</strong>：Jina AI は、トレーニング用にカスタムキュレーションされたデータセットを維持しています。最初の実験では、英語、アラビア語、ドイツ語、スペイン語、日本語、中国語の6つの言語でコントラストトレーニング用に特別にキュレーションされた文トリプレットを使用しました。2番目の実験では、英語のタスク固有のトレーニングデータセットを使用しました。</p><p><strong>評価</strong>：トレーニングとマージによって生成されたモデルを評価するために、<a href=\"https://github.com/embeddings-benchmark/mteb/tree/main/docs/mmteb\">MMTEB ベンチマークセット</a>（<a href=\"https://arxiv.org/abs/2502.13595\">Enevoldsen et al. 2025</a>）と <a href=\"https://project-miracl.github.io/\">MIRACL ベンチマーク</a>（<a href=\"https://direct.mit.edu/tacl/article/doi/10.1162/tacl_a_00595/117438/MIRACL-A-Multilingual-Retrieval-Dataset-Covering\">Zhang et al. 2023</a>）の関連部分を使用しました。</p><h3 id=\"experiment-1-single-run-averaging\">実験1：単一実行平均化</h3><p>この実験では、6つの言語すべてのコントラスト文トリプレットを混合して使用し、バッチサイズ1,024アイテムで合計6,000回のトレーニングステップを実行しました。2,000ステップごとに、平均化のためにモデルの状態を保存し、それぞれがトレーニングプロセスの異なる時点を反映した3つのモデルを生成しました。</p><p>3つのモデルを平均化して、最終的なモデルを生成しました。次に、マージされたモデルと3つの保存されたチェックポイントを MMTEB-STS および MIRACL ベンチマークセットに対してテストしました。</p><p>結果を以下の表にまとめます。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>MIRACL<br>(avg 6 languages)</th>\n<th>MMTEB-STS English<br>(avg 8 benchmarks)</th>\n<th>MMTEB-STS Multilingual<br>(avg 6 benchmarks)</th>\n<th>Average of 20 benchmarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>No triplet training</td>\n<td>0.3163</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.6276</td>\n</tr>\n<tr>\n<td>Step 2000</td>\n<td>0.4631</td>\n<td><strong>0.7924</strong></td>\n<td>0.7561</td>\n<td>0.6813</td>\n</tr>\n<tr>\n<td>Step 4000</td>\n<td>0.4639</td>\n<td>0.7902</td>\n<td><strong>0.7583</strong></td>\n<td>0.6812</td>\n</tr>\n<tr>\n<td>Step 6000 (final)</td>\n<td><strong>0.4680</strong></td>\n<td>0.7891</td>\n<td>0.7575</td>\n<td>0.6818</td>\n</tr>\n<tr>\n<td>Merged model<br>(all 3 stored checkpoints)</td>\n<td>0.4669</td>\n<td>0.7910</td>\n<td>0.7579</td>\n<td><strong>0.6823</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>以前のチェックポイントとのマージは、一般的に、個々のベンチマークまたは使用された3つのベンチマークのいずれかのバッテリーで、保存されたチェックポイントの中で最高のパフォーマンスを発揮するものよりも優れたパフォーマンスを発揮するモデルを生成しませんでした。ただし、すべてのベンチマークをまとめて平均すると、最高のモデルが生成されました。</p><p>個々のベンチマークでは、マージされたモデルと最高のパフォーマンスを発揮するチェックポイントの違いは、すべての場合で0.01未満です。これは、上記の表の平均だけでなく、個々のテストにも当てはまります。</p><p>これは、異なるトレーニングチェックポイントをマージすると、パフォーマンスコストをほとんどかけずに、より堅牢なモデルを生成できることを示しています。</p><p>さらに、異なるチェックポイントをマージすることで、過学習を効果的に防ぐことができます。過学習は、最近ニューラルネットワークで重要なトピックになっています。（<a href=\"https://arxiv.org/abs/2503.19206v2\">Springer et al., 2025</a>）ネットワークは、さらに微調整した後で、より困難になり、パフォーマンスが低下するような方法でトレーニングできます。</p><p>私たちの実験で最高のパフォーマンスを発揮するチェックポイントが最後のものではないことが多いため、6,000回のトレーニングステップでモデルを過学習させた可能性があります。マージされたモデルは、すべてのテストで最高のチェックポイントのパフォーマンスに非常に近く、過学習の欠陥を取り除きます。</p><h3 id=\"experiment-2-averaging-models-trained-for-different-tasks\">実験2：異なるタスクでトレーニングされたモデルの平均化</h3><p>この実験では、それぞれ異なる一般的な埋め込みタスク用に3つのモデルをトレーニングしました。</p><ul><li><strong>意味的類似性</strong>：2つのテキスト間の意味の相対的な重複または類似性を測定します。通常、長さは同程度です。</li><li><strong>テキストクエリに基づくドキュメント検索</strong>：クエリに最も適したドキュメントを見つけること。クエリは一般的に、マッチングするドキュメントよりもはるかに短いテキストです。</li><li><strong>質問応答</strong>：自然言語の質問に最もよく答えるドキュメントを見つけること。質問も一般的に、マッチングするテキストよりもはるかに短いものです。</li></ul><p>3つのタスクすべてに対して同時にモデルをトレーニングすることは、目標が非常に異なるため非常に困難であり、モデルスープがそのプロセスを改善することを期待しています。</p><p>これまでの経験から、各タスクで異なるトレーニングエポック数が必要であることを知っていました。トレーニングを以下にまとめます。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>タスク</th>\n<th>トレーニングステップ<br>（batchsize = 1,024）</th>\n<th>トレーニングデータセットサイズ<br>（アイテム数）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>質問応答（QA）</td>\n<td>2,000</td>\n<td>256,000</td>\n</tr>\n<tr>\n<td>ドキュメント検索</td>\n<td>3,000</td>\n<td>384,000</td>\n</tr>\n<tr>\n<td>意味的類似性（STS）</td>\n<td>1,000</td>\n<td>128,000</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>これにより3つのモデルが生成され、それらを1つのモデルにマージしました。結果として得られたモデルを、それらの3つのタスクに関連するMMTEBベンチマークセットの部分（<a href=\"https://project-miracl.github.io/\">MIRACL</a>、<a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a>、STSEval（MMTEBの英語および多言語部分））に対してテストしました。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>（平均6言語）</th>\n<th>NanoBEIR<br>（平均13ベンチマーク）</th>\n<th>MMTEB-STS 英語<br>（平均9ベンチマーク）</th>\n<th>MMTEB-STS 多言語<br>（平均6ベンチマーク）</th>\n<th>平均34ベンチマーク</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>トリプレットトレーニングなし</td>\n<td>0.3163</td>\n<td>0.5089</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.5876</td>\n</tr>\n<tr>\n<td>QAトレーニング</td>\n<td><strong>0.4489</strong></td>\n<td>0.5332</td>\n<td>0.7843</td>\n<td>0.7535</td>\n<td>0.6237</td>\n</tr>\n<tr>\n<td>検索トレーニング</td>\n<td>0.4272</td>\n<td><strong>0.5360</strong></td>\n<td>0.7766</td>\n<td>0.7340</td>\n<td>0.6154</td>\n</tr>\n<tr>\n<td>STSトレーニング</td>\n<td>0.1779</td>\n<td>0.4519</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.5508</td>\n</tr>\n<tr>\n<td>マージされたモデル</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td><strong>0.6240</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>ここでは、タスク固有のトレーニングを受けたモデルが各タスクで最高のパフォーマンスを発揮していることがわかります。MIRACLは、検索と呼ばれていますが、主に質問応答ベンチマークであり、QAトレーニングを受けたモデルは、マージされたモデルを含む他のすべてのモデルよりも優れています。NanoBEIRは、より従来の情報検索ベンチマークセットであり、検索トレーニングを受けたモデルが最も優れたパフォーマンスを発揮していることがわかります。意味的類似性（STS）モデルは、これらのベンチマークでは非常に低いスコアですが、明示的なSTSタスクでは他のモデルを上回っています。カテゴリごとに、マージされたモデルは、単一タスクのトレーニングを受けたモデルよりもパフォーマンスが低くなります。</p><p>ただし、すべてのベンチマークで平均すると、マージされたモデルは他のモデルよりも優れていますが、そのスコアはQAトレーニングを受けたモデルよりもごくわずかな改善を表しているだけであり、STSタスクでは非常にパフォーマンスが低くなっています。</p><p>また、QAモデルと検索モデルのみをマージし、同じベンチマークで結果として得られたモデルをスコアリングしました。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>（平均6言語）</th>\n<th>NanoBEIR<br>（平均13ベンチマーク）</th>\n<th>MMTEB-STS 英語<br>（平均9ベンチマーク）</th>\n<th>MMTEB-STS 多言語<br>（平均6ベンチマーク）</th>\n<th>平均34テスト</th>\n<th>平均<br>QA＆IR<br>（19テスト）</th>\n<th>平均STS<br>（15テスト）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最高のタスクトレーニングモデル</td>\n<td>0.4489</td>\n<td>0.5360</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.6237</td>\n<td>0.5066</td>\n<td><strong>0.7857</strong></td>\n</tr>\n<tr>\n<td>マージされたモデル</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td>0.6240</td>\n<td>0.4973</td>\n<td>0.7845</td>\n</tr>\n<tr>\n<td>QA +検索マージされたモデル</td>\n<td><strong>0.4610</strong></td>\n<td><strong>0.5404</strong></td>\n<td>0.7878</td>\n<td>0.7498</td>\n<td><strong>0.6288</strong></td>\n<td><strong>0.5153</strong></td>\n<td>0.7726</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>ここでは、2つのタスク用にトレーニングされたモデルをマージすることで、質問応答と検索の両方でパフォーマンスを向上させることができますが、STSトレーニングを受けたモデルを追加すると、すべてのカテゴリでタスク固有のパフォーマンスが低下することがわかります。これは、意味的類似性が、いくつかの重要な点で、QAおよび検索とは異なり、STSトレーニングを受けたモデルは、他の2つとマージするのに適していないことを示唆しています。</p><p>これはおそらく、質問応答と検索には、短いテキスト（質問とクエリ）と長いドキュメントのマッチングが含まれるのに対し、意味的類似性には、より類似した長さのドキュメントの比較が含まれるためです。</p><p><a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. （2022）</a>は、「貪欲」マージと呼ばれる平均化への選択的なアプローチについて説明しています。これには、1つのモデル（通常は一連のモデルの中で最高のパフォーマンスを発揮するモデル）を取得し、パフォーマンスを個別に向上させるモデルのみを追加することが含まれます。モデルが3つしかない場合、この実験で貪欲なマージを使用する意味はほとんどありませんでした。ただし、より多くのモデルがあり、タスク間の類似性の程度を判断するための基礎としてこのような手法を使用することを想像できます。ここでは、意味的類似性が他の2つとは異なることがわかりました。次に、1つのモデルが多くのタスクを実行できる場合と、別のモデルを使用する方が費用対効果が高い場合を評価できます。</p><h2 id=\"soup%E2%80%99s-on\">スープはいかがですか！</h2><p>モデルスープは、多様性をそれらの部分の合計よりも大きなものにブレンドします。このアプローチの価値は、トレーニングコストを追加することなく、より優れた一貫性、堅牢性を提供し、過剰トレーニングに対するセーフガードとして機能する能力にあります。私たちの実験では、チェックポイントまたはタスクに特化したモデルをマージすると、タスク固有のピークを犠牲にすることがあっても、全体的なパフォーマンスが向上する可能性があることが示されています。</p><p>結局のところ、モデルスープは、より適応性の高いモデルを構築するための実用的で非常に簡単な方法を提供しますが、いくつかの注意点があります。万能薬ではなく、モデルがすでに非常に類似している場合にのみ適用できます。</p><p>インターネットで言われているように、<em>Your Mileage May Vary</em>。ただし、モデルをトレーニングするときにモデルスープが役立つかどうかを調べるのは安価で簡単です。</p>",
  "comment_id": "681b63a077c406000104263b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/05/Heading--6-.jpg",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-05-07T15:44:00.000+02:00",
  "updated_at": "2025-05-07T19:56:02.000+02:00",
  "published_at": "2025-05-07T18:43:10.000+02:00",
  "custom_excerpt": "Boost robustness and performance with model soups: averaging weights. No extra cost, better results.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/model-soups-recipe-for-embeddings/",
  "excerpt": "モデルスープでロバスト性とパフォーマンスを向上：重みを平均化します。追加コストなしで、より良い結果が得られます。",
  "reading_time": 9,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}