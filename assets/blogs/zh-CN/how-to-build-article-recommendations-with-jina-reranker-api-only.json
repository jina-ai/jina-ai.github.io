{
  "slug": "how-to-build-article-recommendations-with-jina-reranker-api-only",
  "id": "65f53dc48ff065000146db23",
  "uuid": "70844a2b-50c2-458a-a609-a5bb11530451",
  "title": "如何仅使用 Jina Reranker API 构建文章推荐",
  "html": "<p>两周前，我们推出了 <a href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\">Reranker API</a>，将其确立为市场上领先的重排序解决方案。Jina Reranker 在各项基准测试中的表现优于流行的基线，<a href=\"https://jina.ai/news/maximizing-search-relevancy-and-rag-accuracy-with-jina-reranker?ref=jina-ai-gmbh.ghost.io\">相比 BM25 结果，命中率提高了高达 33%</a>。虽然性能令人印象深刻，但真正让我兴奋的是 Reranker API 的潜力。其简单的接口允许输入查询-文档列表，并直接输出重排序后的 top-k 结果。这意味着，理论上可以仅使用 Reranker 构建搜索或推荐系统——无需 BM25、embeddings、向量数据库或任何管道，从而实现端到端的功能。</p><p>这个概念让我非常感兴趣，以至于我忍不住想要尝试。所以就这样：现在当你浏览我们网站上的任何新闻页面（如你正在阅读的这一页），按下 <code><strong>@</strong></code> 键并点击\"get top 5 related articles\"按钮，你将在大约 5 秒内收到与当前文章最相关的五篇文章，使用 <code>jina-reranker-v1</code> 模型（使用 <code>jina-colbert-v1</code> 模型时略长一些）。所有计算都在线进行，完全由 Reranker API 管理。以下是展示其工作原理的视频：</p><figure class=\"kg-card kg-video-card kg-width-regular kg-card-hascaption\" data-kg-thumbnail=\"https://jina-ai-gmbh.ghost.io/content/media/2024/03/recommender_thumb.jpg\" data-kg-custom-thumbnail=\"\">\n            <div class=\"kg-video-container\">\n                <video src=\"https://jina-ai-gmbh.ghost.io/content/media/2024/03/recommender.mp4\" poster=\"https://img.spacergif.org/v1/1174x796/0a/spacer.png\" width=\"1174\" height=\"796\" playsinline=\"\" preload=\"metadata\" style=\"background: transparent url('https://jina-ai-gmbh.ghost.io/content/media/2024/03/recommender_thumb.jpg') 50% 50% / cover no-repeat;\"></video>\n                <div class=\"kg-video-overlay\">\n                    <button class=\"kg-video-large-play-icon\" aria-label=\"Play video\">\n                        <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                            <path d=\"M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z\"></path>\n                        </svg>\n                    </button>\n                </div>\n                <div class=\"kg-video-player-container\">\n                    <div class=\"kg-video-player\">\n                        <button class=\"kg-video-play-icon\" aria-label=\"Play video\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <path d=\"M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z\"></path>\n                            </svg>\n                        </button>\n                        <button class=\"kg-video-pause-icon kg-video-hide\" aria-label=\"Pause video\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <rect x=\"3\" y=\"1\" width=\"7\" height=\"22\" rx=\"1.5\" ry=\"1.5\"></rect>\n                                <rect x=\"14\" y=\"1\" width=\"7\" height=\"22\" rx=\"1.5\" ry=\"1.5\"></rect>\n                            </svg>\n                        </button>\n                        <span class=\"kg-video-current-time\">0:00</span>\n                        <div class=\"kg-video-time\">\n                            /<span class=\"kg-video-duration\">0:33</span>\n                        </div>\n                        <input type=\"range\" class=\"kg-video-seek-slider\" max=\"100\" value=\"0\">\n                        <button class=\"kg-video-playback-rate\" aria-label=\"Adjust playback speed\">1×</button>\n                        <button class=\"kg-video-unmute-icon\" aria-label=\"Unmute\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <path d=\"M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z\"></path>\n                            </svg>\n                        </button>\n                        <button class=\"kg-video-mute-icon kg-video-hide\" aria-label=\"Mute\">\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n                                <path d=\"M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z\"></path>\n                            </svg>\n                        </button>\n                        <input type=\"range\" class=\"kg-video-volume-slider\" max=\"100\" value=\"100\">\n                    </div>\n                </div>\n            </div>\n            <figcaption><p><span style=\"white-space: pre-wrap;\">要运行这个演示，你需要一个具有足够 token 额度的 API 密钥。如果你的配额用完无法运行演示，可以在 </span><a href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\" target=\"_new\"><span style=\"white-space: pre-wrap;\">https://jina.ai/reranker</span></a><span style=\"white-space: pre-wrap;\"> 生成新的密钥。每个新密钥都有 100 万个免费 token。</span></p></figcaption>\n        </figure><h2 id=\"implementation\">实现</h2><p>实现非常简单：为了找到 <code>jina.ai/news/</code> 上给定文章的最相关文章，我们使用当前正在阅读的文章<strong>作为查询</strong>，并将我们新闻网站上的其他 230+ 篇文章（使用它们的全文！）<strong>作为文档</strong>，当然要排除当前这篇。然后我们将这个 $(q, d_1, d_2, \\cdots, d_{230})$ 作为负载发送给 Reranker API。收到响应后，我们使用排序后的文档索引来显示结果。因此，底层代码如下：</p><pre><code class=\"language-js\">const getRecommendedArticles = async () =&gt; {\n  \n  const query = `${currentNews.title} ${currentNews.excerpt}`;\n  const docs = newsStore.allBlogs.filter((item) =&gt; item.slug !== currentNews.slug);\n  \n  const data = {\n    model: modelName,\n    query: query,\n    documents: docs,\n    top_n: 5,\n  }\n\n  const rerankUrl = 'https://api.jina.ai/v1/rerank';\n  const headers = {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${apiKey}`,\n  };\n  const modelName = 'jina-reranker-v1-base-en';\n  \n  const res = await fetch(rerankUrl, {\n    method: 'POST',\n    headers: headers,\n    body: JSON.stringify(data),\n  });\n\n  const resp = await res.json();\n\n  const topKList = resp.results.map((item) =&gt; {\n    return docs[item.index];\n  });\n\n  console.log(topKList);\n}</code></pre><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">Maximize the search relevancy and RAG accuracy at ease</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">要获取 API 密钥，只需访问我们的 Reranker API 页面并导航到 API 部分。如果你已经拥有我们 Embedding API 的 API 密钥，可以在这里重复使用。</span></p></figcaption></figure><p>就这样，你会看到结果，对于第一次迭代来说这些结果相当不错，特别是考虑到实现过程只花了大约 10 分钟。</p><p>虽然读者可能对这个实现有所担忧，但有些批评可能想得过多，而其他的可能是有效的：</p><ul><li><strong>关于全文过长和分块必要性的担忧可能想得过多</strong>：<code>jina-reranker-v1</code> 模型可以处理长度最多 512 的查询和任意长度的文档，而 <code>jina-colbert-v1</code> 模型可以处理最多 8192 长度的查询和文档。因此，将全文输入到 Reranker API 可能是不必要的。这两个模型都能高效处理长上下文，所以无需担心。分块，虽然可能是 embedding-vector-search-rerank 管道中最繁琐和启发式的部分，在这里却不是问题。然而，更长的上下文确实会消耗更多的 token，这是我们 API 的付费用户可能需要考虑的。在这个例子中，因为我们使用了所有 233 篇文章的全文，一次重排序查询消耗超过 30 万个 token。</li><li><strong>原始数据与清洗后数据对质量的影响</strong>。添加数据清洗确实可能带来改进。例如，我们观察到仅仅移除 HTML 标签（即 <code>docs.map(item =&gt; item.html.replace(/&lt;[^&gt;]*&gt;?/gm, '')</code>）就能显著提高 <code>jina-reranker-v1</code> 模型的推荐质量，尽管对 <code>jina-colbert-v1</code> 模型的效果不太明显。这表明我们的 ColBERT 模型在训练时比 <code>jina-reranker-v1</code> 模型对嘈杂文本的容忍度更高。</li><li><strong>不同查询构造对质量的影响</strong>。在上述实现中，我们直接使用当前文章的标题和摘要作为查询。这是构造查询的最佳方法吗？添加诸如 <code>\"What is the most related article to...\"</code> 这样的前缀或<code>\"如果你推荐最好的文章，我给你 20 美元小费，\"</code>类似于大语言模型中使用的提示，会有帮助吗？这提出了一个有趣的问题，可能与模型的训练数据分布有关，我们计划进一步探讨这一点。</li><li>基于之前关于查询构建的观点，进一步研究查询的组合能力会很有意思，比如使用用户最近的浏览历史来进行个性化推荐。特别有趣的是考虑系统是否不仅能理解查询中的正面例子，<strong>还能理解负面例子，</strong>例如 <code>NOT_LIKE</code> 操作、<code>\"不要推荐这样的文章\"</code>或<code>\"我想看到更少这样的\"</code>。我们将在下一节中深入探讨这一点。</li></ul><h2 id=\"empirical-study-on-query-writing\">查询编写的实证研究</h2><p>在我们使用 Jina Reranker API 探索不同查询编写方式时，我们聚焦于前 10 个结果，通过人工标注（即由我们自己评估）进行了定性评估，这很合理，因为我们完全了解我们网站上发布的所有内容。我们研究的查询编写策略包括：</p><ul><li>使用文章的标题、摘要以及标题 + 摘要的组合。</li><li>采用\"提示\"式指令，如\"更多类似的\"、\"不要类似的\"和\"最相关的文章是什么？\"</li></ul><p>为了测试重排序器的效果，我们选择了两篇非平凡的文章作为查询主题，目标是在我们超过 200+ 篇文章的庞大目录中找出最相关的文章——这个挑战的灵感来自于 LLMs 中的\"大海捞针\"。下面，我们用绿色突出显示了这些\"针\"以便清晰展示。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/image.png\" class=\"kg-image\" alt=\"Screenshot of a table ranking articles on search technology relevance, featuring titles, excerpts, and 'More Like' or 'Not Li\" loading=\"lazy\" width=\"2000\" height=\"758\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/image.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/03/image.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2024/03/image.png 2400w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">我们研究的完整结果详见</span><a href=\"https://docs.google.com/spreadsheets/d/1XDOXjP6IVK1hXk3gKkng_cOpTrmS9Hm1UKCGvW1wMxU/edit?usp=sharing&ref=jina-ai-gmbh.ghost.io\"><span style=\"white-space: pre-wrap;\">这份电子表格</span></a><span style=\"white-space: pre-wrap;\">。</span></figcaption></figure><h2 id=\"summary\">总结</h2><p>基于测试结果，我们得出了一些观察和总结：</p><ol><li>结合标题和摘要可以获得最佳的重排序结果，其中摘要在提升重排序质量方面发挥了重要作用。</li><li>加入\"提示\"式指令并没有带来任何改进。</li><li>重排序模型目前无法有效处理正面或负面限定词。诸如\"更多类似\"、\"更少类似\"或\"不要类似\"这样的术语，重排序器无法理解。</li></ol><p>第 2 点和第 3 点的见解为重排序器的未来改进提供了有趣的方向。我们认为，通过启用即时提示来改变排序逻辑，可以显著扩展重排序器的功能，从而开启个性化内容策划/推荐等新的潜在应用。</p>",
  "comment_id": "65f53dc48ff065000146db23",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--1-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-03-16T07:35:48.000+01:00",
  "updated_at": "2024-03-17T19:26:09.000+01:00",
  "published_at": "2024-03-17T06:38:36.000+01:00",
  "custom_excerpt": "You can build an article recommendation system with just the Jina Reranker API—no pipeline, no embeddings, no vector search, only reranking. Find out how in 20 lines of code.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "1",
      "name": "Engineering Group",
      "slug": "engineering",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/1.png",
      "cover_image": null,
      "bio": "We do opensource, we do neural search, we do creative AI, we do MLOps. We do we.",
      "website": "https://github.com/jina-ai",
      "location": "Berlin, Germany",
      "facebook": null,
      "twitter": "@jinaai_",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/engineering/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "1",
    "name": "Engineering Group",
    "slug": "engineering",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/1.png",
    "cover_image": null,
    "bio": "We do opensource, we do neural search, we do creative AI, we do MLOps. We do we.",
    "website": "https://github.com/jina-ai",
    "location": "Berlin, Germany",
    "facebook": null,
    "twitter": "@jinaai_",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/engineering/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/how-to-build-article-recommendations-with-jina-reranker-api-only/",
  "excerpt": "只需使用 Jina Reranker API，你就能构建一个文章推荐系统——无需流水线、无需嵌入、无需向量搜索，仅通过重排序即可。用 20 行代码了解如何实现。",
  "reading_time": 5,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Black background with a grid, multiple smiley faces, and a cursor pointing to one of them.",
  "feature_image_caption": null
}