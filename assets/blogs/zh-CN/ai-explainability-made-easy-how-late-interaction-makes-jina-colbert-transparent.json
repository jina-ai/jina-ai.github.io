{
  "slug": "ai-explainability-made-easy-how-late-interaction-makes-jina-colbert-transparent",
  "id": "6672af263ce1950001eed6a7",
  "uuid": "44371108-082d-4fb0-a28d-4f86fc02ac14",
  "title": "AI 可解释性变得简单：延迟交互如何使 Jina-ColBERT 变得透明",
  "html": "<p>人工智能模型长期存在的一个问题是，神经网络无法解释它们是如何产生输出的。这对人工智能来说到底是不是一个真正的问题并不总是很清楚。当我们要求人类解释他们的推理过程时，他们经常会进行合理化解释，通常完全不知道自己在这样做，给出看似最合理的解释，而没有任何迹象表明他们脑子里真正在想什么。</p><p>我们已经知道如何让 AI 模型做出合理的回答。也许在这方面，人工智能比我们愿意承认的更像人类。</p><p>五十年前，美国哲学家托马斯·内格尔（Thomas Nagel）写了一篇很有影响力的文章，叫作《做一只蝙蝠是什么感觉？》。他认为，做一只蝙蝠一定有某种感觉：像蝙蝠那样看世界，以蝙蝠的方式感知存在。然而，按照内格尔的说法，即使我们知道关于蝙蝠大脑、蝙蝠感官和蝙蝠身体如何工作的所有可知事实，我们仍然不会知道做一只蝙蝠是什么感觉。</p><p>AI 可解释性是同样的问题。我们知道关于特定 AI 模型的所有事实。它不过是一系列矩阵中排列的有限精度数字。我们可以轻松验证每个模型输出都是正确算术运算的结果，但这些信息作为解释是毫无用处的。</p><p>对于这个问题，无论是 AI 还是人类都没有普遍的解决方案。然而，ColBERT 架构，特别是当它作为重排模型使用\"后期交互\"时，能够让你从模型中获得有意义的见解，了解它在特定情况下给出具体结果的原因。</p><p>本文将向你展示后期交互如何实现可解释性，使用的是 Jina-ColBERT 模型 <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\"><code>jina-colbert-v1-en</code></a> 和 <a href=\"https://matplotlib.org/?ref=jina-ai-gmbh.ghost.io\">Matplotlib Python 库</a>。</p><h2 id=\"a-brief-overview-of-colbert\">ColBERT 简介</h2><p>ColBERT 由 <a href=\"https://doi.org/10.1145/3397271.3401075?ref=jina-ai-gmbh.ghost.io\">Khattab & Zaharia (2020)</a> 引入，是对谷歌在 2018 年首次提出的 <a href=\"https://doi.org/10.18653/v1/N19-1423?ref=jina-ai-gmbh.ghost.io\">BERT 模型</a>的扩展。<a href=\"https://jina.ai/news/what-is-colbert-and-late-interaction-and-why-they-matter-in-search/?ref=jina-ai-gmbh.ghost.io\">Jina AI 的 Jina-ColBERT</a> 模型借鉴了这项工作以及 <a href=\"https://arxiv.org/abs/2112.01488?ref=jina-ai-gmbh.ghost.io\">Santhanam 等人 (2021)</a> 后来提出的 ColBERT v2 架构。ColBERT 类型的模型可以用来创建嵌入，但当用作重排模型时它们还有一些额外的特性。主要优势是\"后期交互\"，这是一种与标准嵌入模型不同的语义文本相似度问题结构化方法。</p><h3 id=\"embedding-models\">嵌入模型</h3><p>在传统的嵌入模型中，我们通过为两段文本生成称为\"嵌入\"的代表性向量来比较它们，然后通过余弦或汉明距离等距离度量来比较这些嵌入。量化两段文本的语义相似度通常遵循一个共同的程序。</p><p>首先，我们分别为两段文本创建嵌入。对于任何一段文本：</p><ol><li>分词器将文本分解成大致是词大小的块。</li><li>每个标记映射到一个向量。</li><li>标记向量通过注意力系统和卷积层相互作用，为每个标记的表示添加上下文信息。</li><li>池化层将这些修改后的标记向量转换成单个嵌入向量。</li></ol><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Embeddings_pooling_dark_small-1.png\" class=\"kg-image\" alt=\"Diagram of text classification model with convolutional, attention, pooling layers, and text tokens on a black background.\" loading=\"lazy\" width=\"550\" height=\"900\"><figcaption><span style=\"white-space: pre-wrap;\">为文本创建单个嵌入的示意模型图。</span></figcaption></figure><p>然后，当每个文本都有了嵌入后，我们比较它们，通常使用余弦度量或汉明距离。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Embeddings2_simpler_dark_small.png\" class=\"kg-image\" alt=\"Flowchart describing a text similarity calculation process with tokenization, embedding models, and scoring.\" loading=\"lazy\" width=\"775\" height=\"825\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Embeddings2_simpler_dark_small.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/Embeddings2_simpler_dark_small.png 775w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">在传统嵌入模型中，通过直接比较文档的嵌入来比较文档。</span></figcaption></figure><p>评分是通过比较两个完整的嵌入来进行的，不包含任何关于标记的具体信息。所有标记之间的交互都是\"早期的\"，因为它发生在两段文本相互比较之前。</p><h3 id=\"reranking-models\">重排模型</h3><p>重排模型的工作方式不同。</p><p>首先，它不是为任何文本创建嵌入，而是取一段文本（称为\"查询\"）和一组其他文本（我们称之为\"目标文档\"），然后根据查询文本对每个目标文档进行评分。这些数字没有归一化，也不像比较嵌入，但它们是可排序的。根据模型，相对于查询得分最高的目标文档是与查询语义最相关的文本。</p><p>让我们使用 Jina Reranker API 和 Python，具体看看这在 <code>jina-colbert-v1-en</code> 重排模型中是如何工作的。</p><p>以下代码也在一个笔记本中，你可以<a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/heatmaps/colbert_heatmaps.ipynb?ref=jina-ai-gmbh.ghost.io\">下载</a>或在 <a href=\"https://colab.research.google.com/github/jina-ai/workshops/blob/main/notebooks/heatmaps/colbert_heatmaps.ipynb?ref=jina-ai-gmbh.ghost.io\">Google Colab</a> 中运行。</p><p>首先，你应该在你的 Python 环境中安装最新版本的 <code>requests</code> 库。你可以使用以下命令：</p><pre><code class=\"language-bash\">pip install requests -U\n</code></pre><p>接下来，访问 <a href=\"https://jina.ai/reranker/?ref=jina-ai-gmbh.ghost.io#apiform\">Jina Reranker API 页面</a>并获取一个免费的 API token，可用于处理最多一百万个文本标记。如下图所示，从页面底部复制 API token：</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/jina_reranker_api.png\" class=\"kg-image\" alt=\"Screenshot of Reranker API's interface with explanatory text and red-highlighted code segment for search optimization.\" loading=\"lazy\" width=\"1650\" height=\"1800\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/jina_reranker_api.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/06/jina_reranker_api.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/06/jina_reranker_api.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/jina_reranker_api.png 1650w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">如何从 Jina Reranker API 页面获取个人 API key。</span></figcaption></figure><p>我们将使用以下查询文本：</p><ul><li>\"Elephants eat 150 kg of food per day.\"</li></ul><p>并将这个查询与三段文本进行比较：</p><ul><li>\"Elephants eat 150 kg of food per day.\"</li><li>\"Every day, the average elephant consumes roughly 150 kg of plants.\"</li><li>\"The rain in Spain falls mainly on the plain.\"</li></ul><p>第一个文档与查询完全相同，第二个是第一个的改写，最后一个文本则完全无关。</p><p>使用以下 Python 代码获取分数，将你的 Jina Reranker API token 赋值给变量 <code>jina_api_key</code>：</p><pre><code class=\"language-Python\">import requests\n\nurl = \"&lt;https://api.jina.ai/v1/rerank&gt;\"\njina_api_key = \"&lt;YOUR JINA RERANKER API TOKEN HERE&gt;\"\n\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": f\"Bearer {jina_api_key}\"\n}\ndata = {\n    \"model\": \"jina-colbert-v1-en\",\n    \"query\": \"Elephants eat 150 kg of food per day.\",\n    \"documents\": [\n        \"Elephants eat 150 kg of food per day.\",\n        \"Every day, the average elephant consumes roughly 150 kg of food.\",\n        \"The rain in Spain falls mainly on the plain.\",\n    ],\n    \"top_n\": 3\n}\n\nresponse = requests.post(url, headers=headers, json=data)\nfor item in response.json()['results']:\n    print(f\"{item['relevance_score']} : {item['document']['text']}\")\n</code></pre><p>在 Python 文件或笔记本中运行这段代码应该产生以下结果：</p><pre><code class=\"language-Text\">11.15625 : Elephants eat 150 kg of food per day.\n9.6328125 : Every day, the average elephant consumes roughly 150 kg of food.\n1.568359375 : The rain in Spain falls mainly on the plain.\n</code></pre><p>正如我们所期望的，完全匹配的文本得分最高，改写版本得分第二高，而完全无关的文本得分要低得多。</p><h3 id=\"scoring-using-colbert\">使用 ColBERT 进行评分</h3><p>ColBERT 重排与基于嵌入的评分的不同之处在于，两段文本的标记在评分过程中会相互比较。两段文本永远不会有自己的嵌入。</p><p>首先，我们使用与嵌入模型相同的架构，为每个标记创建包含文本上下文信息的新表示。然后，我们比较查询中的每个标记与文档中的每个标记。</p><p>对于查询中的每个标记，我们识别出文档中与之交互最强的标记，并对这些交互分数求和以计算最终的数值。</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/ColBERT_dual_dark_small.png\" class=\"kg-image\" alt=\"Detailed diagram showing computational model with tokens, scored and categorized into &quot;Early&quot; and &quot;Late&quot; interactions.\" loading=\"lazy\" width=\"1325\" height=\"1200\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/ColBERT_dual_dark_small.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/06/ColBERT_dual_dark_small.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/ColBERT_dual_dark_small.png 1325w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>这种交互是\"后期\"的：当我们比较两个文本时，词元之间会相互交互。但请记住，\"后期\"交互并不排除\"早期\"交互。被比较的词元向量对已经包含了它们各自上下文的信息。</p><p>这种后期交互方案保留了词元级别的信息，即使这些信息是上下文相关的。这使我们能够部分看到 ColBERT 模型是如何计算得分的，因为我们可以识别出哪些上下文化词元对对最终得分有贡献。</p><h2 id=\"explaining-rankings-with-heat-maps\">使用热力图解释排名</h2><p>热力图是一种可视化技术，用于查看 Jina-ColBERT 创建评分时的内部运作。在本节中，我们将使用 <a href=\"https://seaborn.pydata.org/?ref=jina-ai-gmbh.ghost.io\"><code>seaborn</code></a> 和 <a href=\"https://matplotlib.org/?ref=jina-ai-gmbh.ghost.io\"><code>matplotlib</code></a> 库从 <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\"><code>jina-colbert-v1-en</code></a> 的后期交互层创建热力图，展示查询词元如何与目标文本词元交互。</p><h3 id=\"set-up\">设置</h3><p>我们创建了一个 Python 库文件，其中包含用于访问 <code>jina-colbert-v1-en</code> 模型并使用 <code>seaborn</code>、<code>matplotlib</code> 和 <code>Pillow</code> 创建热力图的代码。你可以<a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/heatmaps/jina_colbert_heatmaps.py?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">直接从 GitHub 下载这个库</a>，或者在你自己的系统上<a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/heatmaps/colbert_heatmaps.ipynb?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">使用提供的 notebook</a>，或者在 <a href=\"https://colab.research.google.com/github/jina-ai/workshops/blob/main/notebooks/heatmaps/colbert_heatmaps.ipynb?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Google Colab</a> 上使用。</p><p>首先，安装所需依赖。你需要在 Python 环境中安装最新版本的 <code>requests</code> 库。如果你还没有安装，请运行：</p><pre><code class=\"language-bash\">pip install requests -U \n</code></pre><p>然后，安装核心库：</p><pre><code class=\"language-bash\">pip install matplotlib seaborn torch Pillow\n</code></pre><p>接下来，从 GitHub 下载 <code>jina_colbert_heatmaps.py</code>。你可以<a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/heatmaps/jina_colbert_heatmaps.py?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">通过网页浏览器</a>下载，或者如果安装了 <code>wget</code>，可以在命令行中下载：</p><pre><code class=\"language-bash\">wget https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/heatmaps/jina_colbert_heatmaps.py\n</code></pre><p>准备好库文件后，我们只需要为本文的其余部分声明一个函数：</p><pre><code class=\"language-Python\">from jina_colbert_heatmaps import JinaColbertHeatmapMaker\n\ndef create_heatmap(query, document, figsize=None):\n    heat_map_maker = JinaColbertHeatmapMaker(jina_api_key=jina_api_key)\n    # get token embeddings for the query\n    query_emb = heat_map_maker.embed(query, is_query=True)\n    # get token embeddings for the target document\n    document_emb = heat_map_maker.embed(document, is_query=False)\n    return heat_map_maker.compute_heatmap(document_emb[0], query_emb[0], figsize)\n</code></pre><h3 id=\"results\">结果</h3><p>现在我们可以创建热力图了，让我们制作一些热力图并看看它们告诉我们什么。</p><p>在 Python 中运行以下命令：</p><pre><code class=\"language-Python\">create_heatmap(\"Elephants eat 150 kg of food per day.\", \"Elephants eat 150 kg of food per day.\")</code></pre><p>结果将是一个如下所示的热力图：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--68-.png\" class=\"kg-image\" alt=\"Heatmap visualizing relationships between phrases like &quot;elephants eat 150 kg of food per day&quot; with color gradients indicating\" loading=\"lazy\" width=\"640\" height=\"480\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Untitled--68-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--68-.png 640w\"></figure><p>这是比较两个相同文本时词元对之间激活水平的热力图。每个方格显示来自两个文本的一对词元之间的交互。额外的词元 <code>[CLS]</code> 和 <code>[SEP]</code> 分别表示文本的开始和结束，而 <code>q</code> 和 <code>d</code> 分别在查询和目标文档的 <code>[CLS]</code> 词元之后插入。这不仅允许模型考虑词元与文本开始和结束之间的交互，还允许词元表示对它们是在查询中还是在目标文档中保持敏感。</p><p>方格越亮，两个词元之间的交互越强，表明它们在语义上相关。每对词元的交互分数范围是 -1.0 到 1.0。红框突出显示的方格是对最终得分有贡献的：对于查询中的每个词元，它与任何文档词元的最高交互水平就是计入的值。</p><p>最佳匹配——最亮的点——和红框标记的最大值几乎都恰好在对角线上，并且它们有很强的交互。唯一的例外是\"技术性\"词元 <code>[CLS]</code>、<code>q</code> 和 <code>d</code>，以及英语中高频的\"停用词\" \"of\"，这些词携带的独立信息很少。</p><p>让我们看一个结构相似的句子——\"Cats eat 50 g of food per day.\"——看看它的词元如何交互：</p><pre><code class=\"language-Python\">create_heatmap(\"Elephants eat 150 kg of food per day.\", \"Cats eat 50 g of food per day.\")</code></pre><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/download.png\" class=\"kg-image\" alt=\"Heatmap visualizing the relevance of keywords like &quot;elephants&quot;, &quot;food&quot;, and &quot;kg&quot; with varying intensity colors, indicating da\" loading=\"lazy\" width=\"640\" height=\"480\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/download.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/download.png 640w\"></figure><p>再一次，最佳匹配主要在对角线上，因为大多数词是相同的，且句子结构几乎相同。即使是\"cats\"和\"elephants\"也因为它们的共同上下文而匹配，尽管匹配程度不是很高。</p><p>上下文越不相似，匹配程度就越差。考虑文本\"Employees eat at the company canteen.\"</p><pre><code class=\"language-Python\">create_heatmap(\"Elephants eat 150 kg of food per day.\", \"Employees eat at the company canteen.\")</code></pre><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--69-.png\" class=\"kg-image\" alt=\"Heatmap visualization showing word correlations from news articles, including topics like food, elephants, and work environme\" loading=\"lazy\" width=\"640\" height=\"480\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Untitled--69-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--69-.png 640w\"></figure><p>尽管结构相似，这里唯一的强匹配是两个\"eat\"之间。主题上，这些句子非常不同，即使它们的结构高度平行。</p><p>通过查看红框中方格的颜色深浅，我们可以看出模型会如何将它们作为\"Elephants eat 150 kg of food per day\"的匹配进行排名，<code>jina-colbert-v1-en</code> 证实了这种直觉：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Score</th>\n<th>Text</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11.15625</td>\n<td>Elephants eat 150 kg of food per day.</td>\n</tr>\n<tr>\n<td>8.3671875</td>\n<td>Cats eat 50 g of food per day.</td>\n</tr>\n<tr>\n<td>3.734375</td>\n<td>Employees eat at the company canteen.</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>现在，让我们将\"Elephants eat 150 kg of food per day.\"与一个本质上含义相同但表述不同的句子进行比较：\"Every day, the average elephant consumes roughly 150 kg of food.\"</p><pre><code class=\"language-Python\">create_heatmap(\"Elephants eat 150 kg of food per day.\", \"Every day, the average elephant consumes roughly 150 kg of food.\")</code></pre><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--70-.png\" class=\"kg-image\" alt=\"Colorful heatmap visualizing the relationship between elephant consumption metrics and other variables.\" loading=\"lazy\" width=\"640\" height=\"480\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Untitled--70-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--70-.png 640w\"></figure><p>请注意第一句中的\"eat\"和第二句中的\"consume\"之间的强关联。尽管词汇不同，Jina-ColBERT 仍能识别出它们的共同含义。</p><p>另外，\"every day\"与\"per day\"有很强的匹配度，尽管它们在句子中的位置完全不同。只有低值词\"of\"显示出异常的不匹配。</p><p>现在，让我们将相同的查询与一个完全无关的文本进行比较：\"The rain in Spain falls mainly on the plain.\"</p><pre><code class=\"language-Python\">create_heatmap(\"Elephants eat 150 kg of food per day.\", \"The rain in Spain falls mainly on the plain.\")</code></pre><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/download-1.png\" class=\"kg-image\" alt=\"Seaborn heatmap visualizing frequencies of topic discussions over months, shaded from red to dark blue.\" loading=\"lazy\" width=\"640\" height=\"480\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/download-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/download-1.png 640w\"></figure><p>你可以看到，这对文本的\"最佳匹配\"互动得分要低得多，两段文本中的任何词之间几乎都没有互动。从直观上来说，与\"Every day, the average elephant consumes roughly 150 kg of food\"相比，我们预期它的得分会很低，而 <code>jina-colbert-v1-en</code> 也证实了这一点：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Score</th>\n<th>Text</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>9.6328125</td>\n<td>Every day, the average elephant consumes roughly 150 kg of food.</td>\n</tr>\n<tr>\n<td>1.568359375</td>\n<td>The rain in Spain falls mainly on the plain.</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h3 id=\"long-texts\">长文本</h3><p>这些是用来演示 ColBERT 式重排序模型工作原理的简单示例。在信息检索场景中，如检索增强生成，查询通常是短文本，而匹配的候选文档往往更长，通常与模型的输入上下文窗口一样长。</p><p>Jina-ColBERT 模型都支持 8192 个 token 的输入上下文，相当于大约 16 页标准单倍行距的文本。</p><p>我们也可以为这些不对称的情况生成热图。例如，让我们看看<a href=\"https://en.wikipedia.org/wiki/Indian_elephant?ref=jina-ai-gmbh.ghost.io\">印度象维基百科页面</a>的第一部分：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Screenshot-2024-06-13-at-14.12.36--1-.png\" class=\"kg-image\" alt=\"Screenshot of Wikipedia page on Indian elephants, featuring articles, three elephant images, and conservation status.\" loading=\"lazy\" width=\"2000\" height=\"1870\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Screenshot-2024-06-13-at-14.12.36--1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/06/Screenshot-2024-06-13-at-14.12.36--1-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/06/Screenshot-2024-06-13-at-14.12.36--1-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/Screenshot-2024-06-13-at-14.12.36--1-.png 2188w\" sizes=\"(min-width: 720px) 720px\"></figure><p>要查看传递给 <code>jina-colbert-v1-en</code> 的纯文本，请点击<a href=\"https://raw.githubusercontent.com/jina-ai/workshops/docs-heatmaps/notebooks/heatmaps/wikipedia_indian_elephant.txt?ref=jina-ai-gmbh.ghost.io\">此链接</a>。</p><p>这段文本有 364 个词，所以我们的热图看起来不会很方正：</p><pre><code class=\"language-Python\">create_heatmap(\"Elephants eat 150 kg of food per day.\", wikipedia_elephants, figsize=(50,7))</code></pre><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--71--2.png\" class=\"kg-image\" alt=\"Graphical heatmap displaying genetic data, with red and orange dots indicating varying expression levels across base pairs an\" loading=\"lazy\" width=\"2000\" height=\"378\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Untitled--71--2.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/06/Untitled--71--2.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/06/Untitled--71--2.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2024/06/Untitled--71--2.png 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>我们可以看到\"elephants\"在文本中多处匹配。在一篇关于大象的文章中，这并不令人意外。但我们也可以看到一个互动强度特别高的区域：</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--72--1.png\" class=\"kg-image\" alt=\"Genomic heatmap with red and black patterns, axis labeled 'XNTY', and highlighted regions indicating data points.\" loading=\"lazy\" width=\"2000\" height=\"443\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Untitled--72--1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/06/Untitled--72--1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/06/Untitled--72--1.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2024/06/Untitled--72--1.png 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>这里发生了什么？通过 Jina-ColBERT，我们可以找到长文本中对应的部分。原来是第二段的第四句话：</p><blockquote>该物种被归类为巨型食草动物，每天能消耗高达 150 kg (330 lb) 的植物。</blockquote><p>这重述了查询文本中的相同信息。如果我们只看这句话的热图，就能看到强匹配：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--74-.png\" class=\"kg-image\" alt=\"Heatmap displaying word co-occurrence with a focus on &quot;elephants,&quot; &quot;food,&quot; and &quot;day,&quot; with color intensity indicating the str\" loading=\"lazy\" width=\"640\" height=\"480\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/06/Untitled--74-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/06/Untitled--74-.png 640w\"></figure><p>Jina-ColBERT 让你能够准确看到长文本中哪些部分导致了它与查询的匹配。这不仅有助于调试，还能提供更好的可解释性。查看匹配是如何形成的并不需要太多技术含量。</p><h2 id=\"explaining-ai-outcomes-with-jina-colbert\">用 Jina-ColBERT 解释 AI 输出结果</h2><p>嵌入是现代 AI 中的核心技术。我们所做的几乎一切都基于这样一个理念：输入数据中的复杂、可学习的关系可以在高维空间的几何中表达。然而，对于普通人来说，理解数千到数百万维度的空间关系非常困难。</p><p>ColBERT 是从这种抽象层次退后了一步。它不是解释 AI 模型行为问题的完整答案，但它直接指向了我们的结果中哪些数据部分起到了作用。</p><p>有时候，AI 必须是一个黑盒子。完成所有重要工作的巨型矩阵太大，任何人都无法完全理解。但 ColBERT 架构为这个黑盒子投射了一点光明，展示了更多可能性。</p><p>Jina-ColBERT 模型目前仅支持英语（<code>jina-colbert-v1-en</code>），但更多语言和使用场景正在开发中。这一系列模型不仅能执行最先进的信息检索，还能告诉你为什么会产生匹配，这体现了 Jina AI 致力于使 AI 技术既易于使用又实用的承诺。</p>",
  "comment_id": "6672af263ce1950001eed6a7",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/06/Search-acc--3-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-06-19T12:12:54.000+02:00",
  "updated_at": "2024-07-08T21:08:21.000+02:00",
  "published_at": "2024-06-19T16:01:36.000+02:00",
  "custom_excerpt": "AI explainability and transparency are hot topics. How can we trust AI if we can't see how it works? Jina-ColBERT shows you how, with the right model architecture, you can easily make your AI spill its secrets.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "6360e8495e0f6e004d70bd9e",
      "name": "Maximilian Werk",
      "slug": "maximilian",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/Profile-Picture.jpg",
      "cover_image": null,
      "bio": "I love bringing business value with ML powered solutions as well as broad strategic and deep technical discussions. I also care a lot about our company culture and enjoy pair programming.",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/maximilian/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "6360e8495e0f6e004d70bd9e",
    "name": "Maximilian Werk",
    "slug": "maximilian",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/Profile-Picture.jpg",
    "cover_image": null,
    "bio": "I love bringing business value with ML powered solutions as well as broad strategic and deep technical discussions. I also care a lot about our company culture and enjoy pair programming.",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/maximilian/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/ai-explainability-made-easy-how-late-interaction-makes-jina-colbert-transparent/",
  "excerpt": "AI 的可解释性和透明度是热门话题。如果我们看不到 AI 是如何运作的，我们又怎么能信任它呢？Jina-ColBERT 向你展示了，只要有合适的模型架构，就能轻松地让 AI 揭示其内部的秘密。",
  "reading_time": 11,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Digital representation of a golden building seen through a blue and yellow mesh pattern, evoking a technological vibe.",
  "feature_image_caption": null
}