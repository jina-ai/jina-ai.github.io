{
  "slug": "what-late-chunking-really-is-and-what-its-not-part-ii",
  "id": "66fe70236ca44300014cabe4",
  "uuid": "a27b0f3c-a533-422c-9d37-3ed3e2130539",
  "title": "深入理解延迟分块：实质与误解（第二部分）",
  "html": "<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">强烈建议先<a href=\"https://jina.ai/news/late-chunking-in-long-context-embedding-models?ref=jina-ai-gmbh.ghost.io\">阅读第一部分</a>，因为本文提供了更深入的视角，重点关注常见误解和对比。<b><strong style=\"white-space: pre-wrap;\">推荐阅读顺序：</strong></b><a href=\"https://jina.ai/news/late-chunking-in-long-context-embedding-models/?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">第一部分</strong></b></a><b><strong style=\"white-space: pre-wrap;\">、第二部分、</strong></b><a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">研究论文</strong></b></a><b><strong style=\"white-space: pre-wrap;\">。</strong></b></div></div><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Late Chunking：使用长上下文嵌入模型的上下文分块嵌入</div><div class=\"kg-bookmark-description\">许多用例需要检索较小的文本片段，并且基于密集向量的检索系统通常在处理较短文本段时表现更好，因为语义在嵌入中不太可能被过度压缩。因此，实践者通常将文本文档分割成更小的块并分别编码。然而，以这种方式创建的块嵌入可能会丢失周围块的上下文信息，导致次优的表示。在本文中，我们介绍了一种称为 late chunking 的新方法，该方法首先嵌入长文本的所有标记，在转换器模型之后且在平均池化之前才进行分块——因此在命名中使用\"late\"一词。产生的块嵌入捕获了完整的上下文信息，在各种检索任务中都能取得更好的结果。该方法具有足够的通用性，可以应用于各种长上下文嵌入模型，且无需额外训练。为了进一步提高 late chunking 的效果，我们提出了一种专门的嵌入模型微调方法。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/apple-touch-icon-1.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Michael Günther</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/arxiv-logo-fb.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>对长文档进行分块存在两个问题：首先是<strong>确定断点</strong>——即如何对文档进行分段。你可能会考虑固定的 token 长度、固定数量的句子，或更高级的技术，如<a href=\"https://jina.ai/segmenter?ref=jina-ai-gmbh.ghost.io\">正则表达式或语义分割模型</a>。准确的块边界不仅可以提高搜索结果的可读性，还能确保输入到 LLM 的 RAG 系统中的块是精确和充分的——不多不少。</p><p>第二个问题是每个块内的<strong>上下文丢失</strong>。一旦文档被分段，大多数人的下一个逻辑步骤就是在批处理过程中分别嵌入每个块。然而，这会导致原始文档的全局上下文丢失。许多之前的工作首先解决第一个问题，认为更好的边界检测可以改善语义表示。例如，\"语义分块\"在嵌入空间中将具有高余弦相似度的句子分组，以最小化语义单元的中断。</p><p>从我们的观点来看，这两个问题<em>几乎</em>是正交的，可以分开处理。如果必须要优先处理，<strong>我们认为第二个问题更为关键。</strong></p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th style=\"text-align:center\">问题 2：<b>上下文信息</b></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td style=\"text-align:center\">已保留</td>\n<td>已丢失</td>\n</tr>\n<tr>\n<td><b>问题 1：断点</b></td>\n<td>好</td>\n<td style=\"text-align:center\">理想场景</td>\n<td>搜索结果差</td>\n</tr>\n<tr>\n<td></td>\n<td>差</td>\n<td style=\"text-align:center\">搜索结果好，但结果可能不便于人类阅读或 LLM 推理</td>\n<td>最坏情况</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"late-chunking-for-context-loss\">Late Chunking 解决上下文丢失</h2><p><strong>Late chunking</strong> 首先解决第二个问题：<strong>上下文丢失</strong>。它<em>不是</em>关于寻找理想的断点或语义边界。你仍然需要使用正则表达式、启发式方法或其他技术将长文档分割成小块。但是，late chunking 不是在分割后立即嵌入每个块，而是先在一个上下文窗口中编码整个文档（对于 <code>jina-embeddings-v3</code> 是 8192-token）。然后，它根据边界提示对每个块应用平均池化——这就是 late chunking 中\"late\"的由来。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/Diagram--Blog-images--6-.svg\" class=\"kg-image\" alt=\"Diagram comparing &quot;Naive Chunking&quot; and &quot;Late Chunking&quot; methods for processing long documents with labeled steps.\" loading=\"lazy\" width=\"1200\" height=\"865\"><figcaption><span style=\"white-space: pre-wrap;\">Late chunking 仍然需要边界提示，但关键区别在于这些提示的使用时机。在 late chunking 中，只有在整个文档被嵌入后才应用这些提示，并用于确定池化范围。</span></figcaption></figure><h2 id=\"late-chunking-is-resilient-to-poor-boundary-cues\">Late Chunking 对糟糕的边界提示具有韧性</h2><p>真正有趣的是，实验表明 late chunking 消除了对完美语义边界的需求，这部分解决了上述的第一个问题。事实上，应用于固定 token 边界的 late chunking 的表现优于具有语义边界提示的朴素分块。当与 late chunking 配对时，像使用固定长度边界这样的简单分割模型，其性能与高级边界检测算法相当。我们测试了三种不同大小的嵌入模型，结果表明它们在所有测试数据集上都持续受益于 late chunking。也就是说，嵌入模型本身仍然是性能最重要的因素——<strong>没有任何一个使用 late chunking 的较弱模型能够超越不使用它的较强模型。</strong></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/plot--7-.svg\" class=\"kg-image\" alt=\"Scatter plot chart showing the percentage of relative improvements across various models against a baseline, with a vertical \" loading=\"lazy\" width=\"950\" height=\"756\"><figcaption><span style=\"white-space: pre-wrap;\">相对于基准线的检索改进（即使用固定 token 长度边界提示和朴素分块的 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-small</span></code><span style=\"white-space: pre-wrap;\">）。作为消融研究的一部分，我们测试了使用不同边界提示（固定 token 长度、句子边界和语义边界）和不同模型（</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-small</span></code><span style=\"white-space: pre-wrap;\">、</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>nomic-v1</span></code><span style=\"white-space: pre-wrap;\">和 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\">）的 late chunking。根据它们在 MTEB 上的表现，这三个嵌入模型的排名是：</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-small</span></code><span style=\"white-space: pre-wrap;\"> &lt; </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>nomic-v1</span></code><span style=\"white-space: pre-wrap;\"> &lt; </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code>。但是，这个实验的重点不在于评估嵌入模型本身的性能，而是要理解一个更好的嵌入模型如何与迟分技术和边界提示进行互动。关于实验的详细信息，请查看我们的研究论文。</figcaption></figure>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Combo</th>\n<th>SciFact</th>\n<th>NFCorpus</th>\n<th>FiQA</th>\n<th>TRECCOVID</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Baseline</td>\n<td>64.2</td>\n<td>23.5</td>\n<td>33.3</td>\n<td>63.4</td>\n</tr>\n<tr>\n<td>Late</td>\n<td>66.1</td>\n<td>30.0</td>\n<td>33.8</td>\n<td>64.7</td>\n</tr>\n<tr>\n<td>Nomic</td>\n<td>70.7</td>\n<td>35.3</td>\n<td>37.0</td>\n<td>72.9</td>\n</tr>\n<tr>\n<td>Jv3</td>\n<td>71.8</td>\n<td>35.6</td>\n<td>46.3</td>\n<td>73.0</td>\n</tr>\n<tr>\n<td>Late + Nomic</td>\n<td>70.6</td>\n<td>35.3</td>\n<td>38.3</td>\n<td>75.0</td>\n</tr>\n<tr>\n<td>Late + Jv3</td>\n<td><strong>73.2</strong></td>\n<td><strong>36.7</strong></td>\n<td><strong>47.6</strong></td>\n<td><strong>77.2</strong></td>\n</tr>\n<tr>\n<td>SentBound</td>\n<td>64.7</td>\n<td>28.3</td>\n<td>30.4</td>\n<td>66.5</td>\n</tr>\n<tr>\n<td>Late + SentBound</td>\n<td>65.2</td>\n<td>30.0</td>\n<td>33.9</td>\n<td>66.6</td>\n</tr>\n<tr>\n<td>Nomic + SentBound</td>\n<td>70.4</td>\n<td>35.3</td>\n<td>34.8</td>\n<td>74.3</td>\n</tr>\n<tr>\n<td>Jv3 + SentBound</td>\n<td>71.4</td>\n<td>35.8</td>\n<td>43.7</td>\n<td>72.4</td>\n</tr>\n<tr>\n<td>Late + Nomic + SentBound</td>\n<td>70.5</td>\n<td>35.3</td>\n<td>36.9</td>\n<td>76.1</td>\n</tr>\n<tr>\n<td>Late + Jv3 + SentBound</td>\n<td>72.4</td>\n<td>36.6</td>\n<td>47.6</td>\n<td>76.2</td>\n</tr>\n<tr>\n<td>SemanticBound</td>\n<td>64.3</td>\n<td>27.4</td>\n<td>30.3</td>\n<td>66.2</td>\n</tr>\n<tr>\n<td>Late + SemanticBound</td>\n<td>65.0</td>\n<td>29.3</td>\n<td>33.7</td>\n<td>66.3</td>\n</tr>\n<tr>\n<td>Nomic + SemanticBound</td>\n<td>70.4</td>\n<td>35.3</td>\n<td>34.8</td>\n<td>74.3</td>\n</tr>\n<tr>\n<td>Jv3 + SemanticBound</td>\n<td>71.2</td>\n<td>36.1</td>\n<td>44.0</td>\n<td>74.7</td>\n</tr>\n<tr>\n<td>Late + Nomic + SemanticBound</td>\n<td>70.5</td>\n<td>36.9</td>\n<td>36.9</td>\n<td>76.1</td>\n</tr>\n<tr>\n<td>Late + Jv3 + SemanticBound</td>\n<td>72.4</td>\n<td>36.6</td>\n<td>47.6</td>\n<td>76.2</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>需要注意的是，对不良边界具有弹性并不意味着我们可以忽视它们——它们对人类和 LLM 的可读性仍然很重要。我们是这样看待的：在优化分段时（即上述第一个问题），我们可以完全专注于可读性，而不用担心语义/上下文的丢失。迟分技术可以处理好的或坏的断点，所以你只需要关注可读性。</p><h2 id=\"late-chunking-is-bidirectional\">迟分技术是双向的</h2><p>关于迟分技术的另一个常见误解是，它的条件分块嵌入只依赖于前面的分块而不\"向前看\"。这是不正确的。**迟分技术中的条件依赖实际上是双向的**，而不是单向的。这是因为嵌入模型（一个仅编码器的 transformer）中的注意力矩阵是完全连接的，不像自回归模型中使用的掩码三角矩阵。形式上，分块 $k$ 的嵌入 $v_k \\sim Q(c_k|D)$，而不是 $v_k \\sim Q(c_k | c_1, c_2, \\cdots, c_{k-1})$，其中 $Q$ 表示语言模型的分解。这也解释了为什么迟分技术不依赖于精确的边界位置。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/Heading--27-.svg\" class=\"kg-image\" alt=\"Diagrams of a transformer model with detailed encoder on the left and decoder on the right, labeled with tokens, embeddings, \" loading=\"lazy\" width=\"1033\" height=\"560\"><figcaption><span style=\"white-space: pre-wrap;\">与使用掩码自注意力的仅解码器模型不同，嵌入模型通常是仅编码器的，具有完整的注意力矩阵。这意味着每个 token 嵌入都依赖于同一上下文窗口内的所有其他 token，在 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\"> 的情况下，包括最多 8191 个其他 token。因此，分块嵌入在两个方向上都携带全局上下文信息。</span></figcaption></figure><h2 id=\"late-chunking-can-be-trained\">迟分技术可以被训练</h2><p>迟分技术不需要对嵌入模型进行额外的训练。它可以应用于任何使用平均池化的长上下文嵌入模型，这使得它对实践者来说非常有吸引力。也就是说，如果你在处理问答或查询-文档检索等任务，通过一些微调仍然可以进一步提高性能。具体来说，训练数据包含以下元组：</p><ul><li>一个**查询**（例如，问题或搜索词）。</li><li>一个包含相关信息以回答查询的**文档**。</li><li>文档内的一个**相关片段**，即直接回答查询的特定文本块。</li></ul><p>模型通过将查询与其相关片段配对来训练，使用 InfoNCE 等对比损失函数。这确保相关片段在嵌入空间中与查询紧密对齐，而不相关的片段则被推得更远。因此，模型在生成分块嵌入时学会关注文档中最相关的部分。<a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\">更多详细信息，请参阅我们的研究论文。</a></p><h2 id=\"late-chunking-vs-contextual-retrieval\">迟分技术 vs 上下文检索</h2><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://www.anthropic.com/news/contextual-retrieval?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Introducing Contextual Retrieval</div><div class=\"kg-bookmark-description\">Anthropic is an AI safety and research company that's working to build reliable, interpretable, and steerable AI systems.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/apple-touch-icon-2.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/519f63e0ea393f33e56c2e812713d65dcf27a79a-2880x1620.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>在迟分技术推出后不久，Anthropic 引入了一个称为**上下文检索**的独立策略。Anthropic 的方法是一种解决上下文丢失问题的暴力方法，其工作原理如下：</p><ol><li>每个分块都与完整文档一起发送给 LLM。</li><li>LLM 为每个分块添加相关上下文。</li><li>这会产生更丰富、更有信息量的嵌入。</li></ol><p>在我们看来，这本质上是**上下文丰富化**，其中使用 LLM 将全局上下文显式硬编码到每个分块中，这在**成本**、**时间**和**存储**方面都很昂贵。此外，目前尚不清楚这种方法是否对分块边界具有弹性，因为 LLM 依赖准确且可读的分块来有效丰富上下文。相比之下，如上所示，迟分技术对边界提示具有很强的弹性。由于嵌入大小保持不变，它不需要额外的存储。尽管利用了嵌入模型的完整上下文长度，<a href=\"https://jina.ai/news/jina-embeddings-v3-a-frontier-multilingual-embedding-model/?ref=jina-ai-gmbh.ghost.io#parameter-latechunking\">它仍然比使用 LLM 生成丰富化要快得多</a>。在我们研究论文的定性研究中，<a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\">我们展示了 Anthropic 的上下文检索与迟分技术表现相似</a>。然而，迟分技术通过利用仅编码器 transformer 的固有机制，提供了一个更底层、更通用和更自然的解决方案。</p><h2 id=\"which-embedding-models-support-late-chunking\">哪些嵌入模型支持迟分技术？</h2><p>迟分技术并不是 <code>jina-embeddings-v3</code> 或 <code>v2</code> 独有的。它是一种相当通用的方法，可以应用于任何使用平均池化的长上下文嵌入模型。例如，在这篇文章中，我们展示了 <code>nomic-v1</code> 也支持它。我们热烈欢迎所有嵌入提供商在他们的解决方案中实现对迟分技术的支持。</p><p>作为模型用户，在评估新的嵌入模型或 API 时，你可以按照以下步骤检查它是否可能支持迟分技术：</p><ol><li><strong>单一输出</strong>：模型/API 是否仅为每个句子生成一个最终的 embedding 而不是词级别的 embeddings？如果是，那它可能就不支持后置分块（尤其是那些网络 API）。</li><li><strong>长文本支持</strong>：模型/API 是否能处理至少 8192 个 tokens 的上下文？如果不能，后置分块就不适用——或者更准确地说，为短上下文模型采用后置分块是没有意义的。如果支持，请确保它在处理长文本时真的表现良好，而不仅仅是声称支持。你通常可以在模型的技术报告中找到这些信息，比如在 LongMTEB 或其他长文本基准测试上的评估结果。</li><li><strong>平均池化</strong>：对于可自托管的模型或提供池化前词级 embeddings 的 API，检查默认的池化方法是否为平均池化。使用 CLS 或最大池化的模型与后置分块不兼容。</li></ol><p>总的来说，如果一个 embedding 模型支持长文本且默认使用平均池化，它就可以轻松支持后置分块。查看我们的 <a href=\"https://github.com/jina-ai/late-chunking/issues/?ref=jina-ai-gmbh.ghost.io\">GitHub 仓库了解实现细节和更多讨论</a>。</p><h2 id=\"conclusion\">结论</h2><p>那么，什么是后置分块？后置分块是一种使用长文本 embedding 模型生成块级 embeddings 的直接方法。它速度快、对边界提示具有弹性且非常有效。它不是一种启发式方法或过度工程——而是基于对 transformer 机制深入理解的精心设计。</p><p>如今，围绕 LLMs 的炒作无可否认。在许多情况下，原本可以由 BERT 等较小模型高效解决的问题，却因为人们对更大、更复杂解决方案的追捧而交给了 LLMs。大型 LLM 提供商推动其模型的更广泛采用，而 embedding 提供商则推广 embeddings，这并不令人意外——他们都在发挥各自的商业优势。但最终，重要的不是炒作，而是行动，是什么真正有效。让社区、行业，最重要的是时间来揭示哪种方法才是真正精简、高效且经得起考验的。</p><p>请务必阅读<a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\">我们的研究论文</a>，我们也鼓励你在各种场景下对后置分块进行基准测试，并与我们分享你的反馈。</p>",
  "comment_id": "66fe70236ca44300014cabe4",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/10/lc2.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-10-03T12:21:23.000+02:00",
  "updated_at": "2024-10-07T15:29:00.000+02:00",
  "published_at": "2024-10-03T19:19:16.000+02:00",
  "custom_excerpt": "Part 2 of our exploration of Late Chunking, a deep dive into why it is the best method for chunk embeddings and improving search/RAG performance.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/what-late-chunking-really-is-and-what-its-not-part-ii/",
  "excerpt": "Late Chunking 探索的第二部分，深入了解为什么它是进行文本块嵌入和提升搜索/RAG 性能的最佳方法。",
  "reading_time": 9,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Slide depicting the \"Late Chunking\" process, with flow charts and a model highlighting the transition from a \"Long Document\" ",
  "feature_image_caption": null
}