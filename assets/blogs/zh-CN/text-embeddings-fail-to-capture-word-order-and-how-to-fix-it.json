{
  "slug": "text-embeddings-fail-to-capture-word-order-and-how-to-fix-it",
  "id": "6761676f2defad0001fb5d8a",
  "uuid": "d09f5014-80fc-4f97-a6a3-d903b0a5c105",
  "title": "文本嵌入无法捕捉词序问题及其解决方案",
  "html": "<p>最近，<a href=\"https://laion.ai/team/?ref=jina-ai-gmbh.ghost.io\">LAION AI</a> 的创始人 Christoph Schuhmann 分享了一个关于文本嵌入模型的有趣观察：</p><blockquote>当句子中的词语被随机打乱时，其文本嵌入与原始句子的余弦相似度仍然保持着出人意料的高值。</blockquote><p>例如，让我们看两个句子：<code>Berlin is the capital of Germany</code> 和 <code>the Germany Berlin is capital of</code>。尽管第二个句子毫无意义，但文本嵌入模型却难以区分它们。使用 <code>jina-embeddings-v3</code>，这两个句子的余弦相似度高达 0.9295。</p><p>词序并不是嵌入模型唯一不够敏感的方面。语法变换可以彻底改变句子的含义，但对嵌入距离的影响却很小。例如，<code>She ate dinner before watching the movie</code> 和 <code>She watched the movie before eating dinner</code> 的余弦相似度为 0.9833，尽管它们描述的动作顺序完全相反。</p><p>如果没有<a href=\"https://jina.ai/news/training-smarter-not-harder-slimming-sentence-embeddings/?ref=jina-ai-gmbh.ghost.io#triplet-training-targets-specificity\">特殊训练</a>，否定词的一致性嵌入也是出了名的困难 — <code>This is a useful model</code> 和 <code>This is not a useful model</code> 在嵌入空间中看起来几乎一样。通常，将文本中的词替换为同类词，比如把\"today\"改成\"yesterday\"，或改变动词时态，对嵌入的影响也不如预期的那么大。</p><p>这带来了严重的问题。考虑两个搜索查询：<code>Flight from Berlin to Amsterdam</code> 和 <code>Flight from Amsterdam to Berlin</code>。它们的嵌入几乎完全相同，<code>jina-embeddings-v3</code> 给出的余弦相似度为 0.9884。对于旅行搜索或物流等实际应用来说，这个缺陷是致命的。</p><p>在本文中，我们将探讨嵌入模型面临的挑战，研究它们在词序和词选择方面持续存在的问题。我们分析了各种语言类别中的关键失效模式——包括方向性、时间性、因果关系、比较和否定语境——同时探索提升模型性能的策略。</p><h2 id=\"why-do-shuffled-sentences-have-surprisingly-close-cosine-scores\">为什么打乱的句子会有惊人的相近余弦分数？</h2><p>起初，我们认为这可能与模型如何组合词义有关 - 它为每个词（我们上面例子中的每个句子有 6-7 个词）创建一个嵌入，然后通过平均池化将这些嵌入平均在一起。这意味着最终的嵌入几乎不包含词序信息。平均值无论值的顺序如何都是相同的。</p><p>然而，即使是使用 CLS 池化的模型（通过查看特殊的第一个词来理解整个句子，理应对词序更敏感）也存在同样的问题。例如，<code>bge-1.5-base-en</code> 对句子 <code>Berlin is the capital of Germany</code> 和 <code>the Germany Berlin is capital of</code> 仍给出 0.9304 的余弦相似度分数。</p><p>这指向了嵌入模型训练方式的一个局限。虽然语言模型在预训练期间最初学习了句子结构，但在对比训练（创建嵌入模型的过程）中似乎失去了部分这种理解。</p><h2 id=\"how-do-text-length-and-word-order-impact-embedding-similarity\">文本长度和词序如何影响嵌入相似度？</h2><p>为什么模型一开始就难以处理词序？首先想到的是文本的长度（以标记计）。当文本被送入编码函数时，模型首先生成标记嵌入列表（即，每个标记化的词都有一个专门的向量表示其含义），然后对它们取平均值。</p><p>为了了解文本长度和词序如何影响嵌入相似度，我们生成了一个<a href=\"https://huggingface.co/datasets/bwang0911/word-orders-triplet-random-shuffle?ref=jina-ai-gmbh.ghost.io\">包含 180 个不同长度合成句子的数据集</a>，长度分别为 3、5、10、15、20 和 30 个标记。我们还随机打乱了每个句子的标记来形成变体：</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/datasets/bwang0911/word-orders-triplet-random-shuffle?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">bwang0911/word-orders-triplet-random-shuffle · Datasets at Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-16.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/word-orders-triplet-random-shuffle.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>以下是一些例子：</p>\n<!--kg-card-begin: html-->\n<table id=\"f455664c-d258-4c55-9a8f-a9bcc5203c74\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"54abe148-ee87-470f-a05e-4c2bec2feafd\"><th id=\"s~RQ\" class=\"simple-table-header-color simple-table-header\">长度（标记）</th><th id=\"usZ}\" class=\"simple-table-header-color simple-table-header\">原始句子</th><th id=\"ju?f\" class=\"simple-table-header-color simple-table-header\">打乱的句子</th></tr></thead><tbody><tr id=\"fc9b17e6-8ce4-43c8-aee9-d2fbee6290f6\"><th id=\"s~RQ\" class=\"simple-table-header-color simple-table-header\">3</th><td id=\"usZ}\" class=\"\">The cat sleeps</td><td id=\"ju?f\" class=\"\">cat The sleeps</td></tr><tr id=\"cbd662b9-b080-4269-929e-b4308c506002\"><th id=\"s~RQ\" class=\"simple-table-header-color simple-table-header\">5</th><td id=\"usZ}\" class=\"\">He drives his car carefully</td><td id=\"ju?f\" class=\"\">drives car his carefully He</td></tr><tr id=\"aea07e66-d0e5-4eec-ad1f-a987438fc448\"><th id=\"s~RQ\" class=\"simple-table-header-color simple-table-header\">15</th><td id=\"usZ}\" class=\"\">The talented musicians performed beautiful classical music at the grand concert hall yesterday</td><td id=\"ju?f\" class=\"\">in talented now grand classical yesterday The performed musicians at hall concert the music</td></tr><tr id=\"f59d8da8-7ed5-49cd-9077-77aac31c2398\"><th id=\"s~RQ\" class=\"simple-table-header-color simple-table-header\">30</th><td id=\"usZ}\" class=\"\">The passionate group of educational experts collaboratively designed and implemented innovative teaching methodologies to improve learning outcomes in diverse classroom environments worldwide</td><td id=\"ju?f\" class=\"\">group teaching through implemented collaboratively outcomes of methodologies across worldwide diverse with passionate and in experts educational classroom for environments now by learning to at improve from innovative The designed</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>我们将使用我们自己的 <code>jina-embeddings-v3</code> 模型和开源模型 <code>bge-base-en-v1.5</code> 对数据集进行编码，然后计算原始句子和打乱句子之间的余弦相似度：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>长度（标记）</th>\n<th>平均余弦相似度</th>\n<th>余弦相似度标准差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3</td>\n<td>0.947</td>\n<td>0.053</td>\n</tr>\n<tr>\n<td>5</td>\n<td>0.909</td>\n<td>0.052</td>\n</tr>\n<tr>\n<td>10</td>\n<td>0.924</td>\n<td>0.031</td>\n</tr>\n<tr>\n<td>15</td>\n<td>0.918</td>\n<td>0.019</td>\n</tr>\n<tr>\n<td>20</td>\n<td>0.899</td>\n<td>0.021</td>\n</tr>\n<tr>\n<td>30</td>\n<td>0.874</td>\n<td>0.025</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>现在我们可以生成一个箱线图，这使得余弦相似度的趋势更加清晰：</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--22-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1183\" height=\"589\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/image--22-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/12/image--22-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--22-.png 1183w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 1：使用 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\"> 和 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>bge-base-en-1.5</span></code><span style=\"white-space: pre-wrap;\">（未微调）的打乱句子按句子长度的相似度分布</span></figcaption></figure><p>正如我们所见，嵌入的平均余弦相似度存在明显的线性关系。文本越长，原始句子和随机打乱句子之间的平均余弦相似度分数越低。这很可能是由于\"词位移\"造成的，即词在随机打乱后离开原始位置的距离。在较短的文本中，标记能够被打乱到的\"位置\"simply 更少，因此不能移动太远，而较长的文本有更多的潜在排列组合，词可以移动更远的距离。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/Copy-of-Sharing-Chunking-Blog-Post-Images--2-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"866\" height=\"452\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/Copy-of-Sharing-Chunking-Blog-Post-Images--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/Copy-of-Sharing-Chunking-Blog-Post-Images--2-.png 866w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 2：按词数划分的句子组合</span></figcaption></figure><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">我们在这里停止表格统计，因为组合数是词数的阶乘。当我们达到三十个词时，会得到 265 非亿（2.652528598 E+32）种组合。</div></div><p>如下图所示（余弦相似度与平均词位移关系图），文本越长，词位移越大：</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--23-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1183\" height=\"593\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/image--23-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/12/image--23-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--23-.png 1183w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 3：使用打乱句子数据集展示的余弦相似度与平均词位移的关系，显示了平均词位移和余弦不相似度之间的相关性。</span></figcaption></figure><p>Token 嵌入依赖于局部上下文，即最接近它们的词。在短文本中，重新排列词不会大幅改变上下文。然而，对于较长的文本，一个词可能会被移到离其原始上下文很远的位置，这可能会显著改变其 token 嵌入。因此，打乱较长文本中的词会产生比短文本更远的嵌入距离。上图显示，无论是使用均值池化的 <code>jina-embeddings-v3</code>，还是使用 CLS 池化的 <code>bge-base-en-v1.5</code>，都遵循相同的规律：打乱较长的文本并使词位移更远会导致更小的相似度分数。</p><h2 id=\"do-bigger-models-solve-the-problem\">更大的模型能解决这个问题吗？</h2><p>通常，当我们面对这类问题时，一个常见的策略是使用更大的模型。但更大的文本嵌入模型真的能更有效地捕捉词序信息吗？根据文本嵌入模型的扩展定律（<a href=\"https://jina.ai/news/jina-embeddings-v3-a-frontier-multilingual-embedding-model/?ref=jina-ai-gmbh.ghost.io\">在我们的 <code>jina-embeddings-v3</code> 发布文章中提到</a>），更大的模型通常提供更好的性能：</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--24-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"2003\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/image--24-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/12/image--24-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/12/image--24-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--24-.png 2045w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 4：嵌入模型的扩展定律，显示 MTEB 性能随参数数量的扩展。</span></figcaption></figure><p>但更大的模型真的能更有效地捕捉词序信息吗？我们测试了 BGE 模型的三种变体：<a href=\"https://huggingface.co/BAAI/bge-small-en-v1.5?ref=jina-ai-gmbh.ghost.io\"><code>bge-small-en-v1.5</code></a>、<a href=\"https://huggingface.co/BAAI/bge-base-en-v1.5?ref=jina-ai-gmbh.ghost.io\"><code>bge-base-en-v1.5</code></a> 和 <a href=\"https://huggingface.co/BAAI/bge-large-en-v1.5?ref=jina-ai-gmbh.ghost.io\"><code>bge-large-en-v1.5</code></a>，参数量分别为 3300 万、1.1 亿和 3.35 亿。</p><p>我们将使用与之前相同的 180 个句子，但不考虑长度信息。我们将使用这三个模型变体对原始句子及其随机打乱后的句子进行编码，并绘制平均余弦相似度：</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/size.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1484\" height=\"584\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/size.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/12/size.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/size.png 1484w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 5：使用打乱句子数据集，比较 </span><a href=\"https://huggingface.co/BAAI/bge-small-en-v1.5?ref=jina-ai-gmbh.ghost.io\"><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>bge-small-en-v1.5</span></code></a><span style=\"white-space: pre-wrap;\">、</span><a href=\"https://huggingface.co/BAAI/bge-base-en-v1.5?ref=jina-ai-gmbh.ghost.io\"><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>bge-base-en-v1.5</span></code></a><span style=\"white-space: pre-wrap;\">和 </span><a href=\"https://huggingface.co/BAAI/bge-large-en-v1.5?ref=jina-ai-gmbh.ghost.io\"><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>bge-large-en-v1.5</span></code></a><span style=\"white-space: pre-wrap;\">的模型大小对词序敏感度的影响。</span></figcaption></figure><p>虽然我们可以看到更大的模型对词序变化更敏感，但差异很小。即使是大得多的 <code>bge-large-en-v1.5</code> 在区分打乱和未打乱的句子方面也仅仅略微更好一些。其他因素在决定嵌入模型对词序重排的敏感度方面也起着作用，特别是训练方案的差异。此外，余弦相似度是衡量模型区分能力的一个很有限的工具。然而，我们可以看到模型大小并不是一个主要考虑因素。我们不能简单地通过增大模型来解决这个问题。</p><h2 id=\"word-order-and-word-choice-in-the-real-world\">现实世界中的词序和词选择</h2><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">在本文的大部分内容中，我们使用的是 <a href=\"https://jina.ai/news/jina-ai-launches-worlds-first-open-source-8k-text-embedding-rivaling-openai/?ref=jina-ai-gmbh.ghost.io\"><code spellcheck=\"false\" style=\"white-space: pre-wrap;\">jina-embeddings-v2</code></a>（<i><em class=\"italic\" style=\"white-space: pre-wrap;\">不是</em></i>我们最新的 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">jina-embeddings-v3</code> 模型），因为 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">v2</code> 要小得多，因此在我们的本地 GPU 上实验更快，其参数量为 1.37 亿，而 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">v3</code> 为 5.8 亿。</div></div><p>正如我们在引言中提到的，词序并不是嵌入模型唯一面临的挑战。在现实世界中，更现实的挑战是关于词的<em>选择</em>。有很多方式可以改变句子中的词——而这些改变在嵌入中并没有得到很好的反映。我们可以把\"她从巴黎飞到东京\"改成\"她从东京开车到巴黎\"，但嵌入仍然保持相似。我们已经将这些改变划分为几个类别：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>示例 - 左</th>\n<th>示例 - 右</th>\n<th>余弦相似度 (<code>jina</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方向性</td>\n<td>She flew from Paris to Tokyo</td>\n<td>She drove from Tokyo to Paris</td>\n<td>0.9439</td>\n</tr>\n<tr>\n<td>时间性</td>\n<td>She ate dinner before watching the movie</td>\n<td>She watched the movie before eating dinner</td>\n<td>0.9833</td>\n</tr>\n<tr>\n<td>因果关系</td>\n<td>The rising temperature melted the snow</td>\n<td>The melting snow cooled the temperature</td>\n<td>0.8998</td>\n</tr>\n<tr>\n<td>比较关系</td>\n<td>Coffee tastes better than tea</td>\n<td>Tea tastes better than coffee</td>\n<td>0.9457</td>\n</tr>\n<tr>\n<td>否定关系</td>\n<td>He is standing by the table</td>\n<td>He is standing far from the table</td>\n<td>0.9116</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">注意，这些是我们在工作中观察到的常见情况，并不一定代表一个完整的分类体系。</div></div><p>上表展示了一系列文本嵌入模型在捕捉细微词语变化方面失败的\"失败案例\"。这符合我们的预期：文本嵌入模型缺乏推理能力。例如，模型并不理解\"from\"和\"to\"之间的关系。文本嵌入模型执行语义匹配，语义通常在词元级别捕获，然后在池化后压缩成单个密集向量。相比之下，<a href=\"https://arxiv.org/abs/2206.07682?ref=jina-ai-gmbh.ghost.io\">在万亿词元规模的更大数据集上训练的 LLM（自回归模型）开始展现出推理的涌现能力</a>。</p><p>这让我们思考，我们能否通过使用三元组进行对比学习来微调嵌入模型，使查询和正样本更接近，同时推开查询和负样本？</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/Copy-of-Sharing-Chunking-Blog-Post-Images--1---1-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"960\" height=\"540\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/Copy-of-Sharing-Chunking-Blog-Post-Images--1---1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/Copy-of-Sharing-Chunking-Blog-Post-Images--1---1-.png 960w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 6：对比学习的效果：使查询和正样本更接近，负样本更远离。</span></figcaption></figure><p>例如，\"Flight from Amsterdam to Berlin\"可以被视为\"Flight from Berlin to Amsterdam\"的负面对。事实上，在 <a href=\"https://arxiv.org/pdf/2307.11224?ref=jina-ai-gmbh.ghost.io\"><code>jina-embeddings-v1</code> 技术报告</a>（Michael Guenther 等人）中，我们已经小规模地解决了这个问题：我们在一个由大型语言模型生成的包含 10,000 个示例的<a href=\"https://huggingface.co/datasets/jinaai/negation-dataset?ref=jina-ai-gmbh.ghost.io\">否定数据集</a>上微调了 <code>jina-embeddings-v1</code> 模型。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/datasets/jinaai/negation-dataset?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/negation-dataset · Datasets at Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-17.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/negation-dataset.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>上述报告中的结果令人鼓舞：</p><blockquote>我们观察到，在所有模型尺寸中，在三元组数据（包括我们的否定训练数据集）上进行微调都显著提高了性能，特别是在 HardNegation 任务上。</blockquote><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--25-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1333\" height=\"616\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/image--25-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/12/image--25-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--25-.png 1333w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 7：表格显示了不同大小的 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings</span></code><span style=\"white-space: pre-wrap;\"> 模型在配对训练和组合三元组/配对训练下的 EasyNegation 和 HardNegation 分数。</span></figcaption></figure><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/graph-big.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1550\" height=\"949\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/graph-big.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/12/graph-big.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/graph-big.png 1550w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 8：不同版本 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings</span></code><span style=\"white-space: pre-wrap;\"> 训练策略的性能比较。</span></figcaption></figure><h2 id=\"fine-tuning-text-embedding-models-with-curated-datasets\">使用精选数据集微调文本嵌入模型</h2><p>在前面的部分，我们探讨了关于文本嵌入的几个关键观察：</p><ol><li>较短的文本更容易在捕捉词序方面出错。</li><li>增加文本嵌入模型的规模并不一定能改善词序理解。</li><li>对比学习可能为这些问题提供潜在的解决方案。</li></ol><p>基于这些认识，我们在否定和词序数据集（总共约 11,000 个训练样本）上微调了 <code>jina-embeddings-v2-base-en</code> 和 <code>bge-base-en-1.5</code>：</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/bwang0911/word-order-jina?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">bwang0911/word-order-jina · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-18.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/word-order-jina.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/bwang0911/word-order-bge?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">bwang0911/word-order-bge · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-19.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/word-order-bge.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>为了帮助评估微调效果，我们生成了一个包含 1,000 个三元组的<a href=\"https://huggingface.co/datasets/bwang0911/word-orders-triplet?ref=jina-ai-gmbh.ghost.io\">数据集</a>，每个三元组包含一个 <code>query</code>、<code>positive (pos)</code> 和 <code>negative (neg)</code> 案例：</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/datasets/bwang0911/word-orders-triplet?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">bwang0911/word-orders-triplet · Datasets at Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-20.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/word-orders-triplet.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>以下是一个示例行：</p>\n<!--kg-card-begin: html-->\n<table>\n<tbody>\n<tr>\n<td>Anchor</td>\n<td><code>The river flows from the mountains to the sea</code></td>\n</tr>\n<tr>\n<td>Positive</td>\n<td><code>Water travels from mountain peaks to ocean</code></td>\n</tr>\n<tr>\n<td>Negative</td>\n<td><code>The river flows from the sea to the mountains</code></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>这些三元组设计用于覆盖各种失败案例，包括由于词序变化导致的<strong>方向性</strong>、<strong>时间性</strong>和<strong>因果性</strong>意义变化。</p><p>现在我们可以在三个不同的评估集上评估模型：</p><ol><li>180 个合成句子集（来自本文前面部分）的随机打乱。</li><li>5 个手动检查的示例（来自上面方向性/因果性等表格）。</li><li>来自我们刚刚生成的<a href=\"https://huggingface.co/datasets/bwang0911/word-orders-triplet?ref=jina-ai-gmbh.ghost.io\">三元组数据集</a>的 94 个精选三元组。</li></ol><p>以下是微调前后打乱句子的差异：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>句子长度（词元数）</th>\n<th>余弦相似度均值（<code>jina</code>）</th>\n<th>余弦相似度均值（<code>jina-ft</code>）</th>\n<th>余弦相似度均值（<code>bge</code>）</th>\n<th>余弦相似度均值（<code>bge-ft</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3</td>\n<td>0.970</td>\n<td>0.927</td>\n<td>0.929</td>\n<td>0.899</td>\n</tr>\n<tr>\n<td>5</td>\n<td>0.958</td>\n<td>0.910</td>\n<td>0.940</td>\n<td>0.916</td>\n</tr>\n<tr>\n<td>10</td>\n<td>0.953</td>\n<td>0.890</td>\n<td>0.934</td>\n<td>0.910</td>\n</tr>\n<tr>\n<td>15</td>\n<td>0.930</td>\n<td>0.830</td>\n<td>0.912</td>\n<td>0.875</td>\n</tr>\n<tr>\n<td>20</td>\n<td>0.916</td>\n<td>0.815</td>\n<td>0.901</td>\n<td>0.879</td>\n</tr>\n<tr>\n<td>30</td>\n<td>0.927</td>\n<td>0.819</td>\n<td>0.877</td>\n<td>0.852</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>结果似乎很明显：尽管微调过程只花了五分钟，我们在随机打乱句子的数据集上看到了显著的性能提升：</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--26-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1184\" height=\"784\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/12/image--26-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/12/image--26-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/12/image--26-.png 1184w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 9：使用 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\"> 和 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>bge-base-en-1.5</span></code><span style=\"white-space: pre-wrap;\">（经过微调）对打乱句子的相似度分布。</span></figcaption></figure><p>我们在方向性、时序、因果和比较性案例上也看到了提升。模型表现出显著的性能提升，这反映在平均余弦相似度的下降上。最大的性能提升出现在否定案例上，这是因为我们的微调数据集包含了 10,000 个否定训练样例。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>示例 - 左</th>\n<th>示例 - 右</th>\n<th>平均余弦相似度 (<code>jina</code>)</th>\n<th>平均余弦相似度 (<code>jina-ft</code>)</th>\n<th>平均余弦相似度 (<code>bge</code>)</th>\n<th>平均余弦相似度 (<code>bge-ft</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方向性</td>\n<td>She flew from Paris to Tokyo.</td>\n<td>She drove from Tokyo to Paris</td>\n<td>0.9439</td>\n<td>0.8650</td>\n<td>0.9319</td>\n<td>0.8674</td>\n</tr>\n<tr>\n<td>时序</td>\n<td>She ate dinner before watching the movie</td>\n<td>She watched the movie before eating dinner</td>\n<td>0.9833</td>\n<td>0.9263</td>\n<td>0.9683</td>\n<td>0.9331</td>\n</tr>\n<tr>\n<td>因果</td>\n<td>The rising temperature melted the snow</td>\n<td>The melting snow cooled the temperature</td>\n<td>0.8998</td>\n<td>0.7937</td>\n<td>0.8874</td>\n<td>0.8371</td>\n</tr>\n<tr>\n<td>比较</td>\n<td>Coffee tastes better than tea</td>\n<td>Tea tastes better than coffee</td>\n<td>0.9457</td>\n<td>0.8759</td>\n<td>0.9723</td>\n<td>0.9030</td>\n</tr>\n<tr>\n<td>否定</td>\n<td>He is standing by the table</td>\n<td>He is standing far from the table</td>\n<td>0.9116</td>\n<td>0.4478</td>\n<td>0.8329</td>\n<td>0.4329</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"conclusion\">结论</h2><p>在这篇文章中，我们深入探讨了文本嵌入模型面临的挑战，特别是它们在有效处理词序方面的困难。具体来说，我们识别出了五种主要的失败类型：<strong>方向性</strong>、<strong>时序</strong>、<strong>因果</strong>、<strong>比较</strong>和<strong>否定</strong>。这些是词序真正重要的查询类型，如果你的使用场景涉及其中任何一种，了解这些模型的局限性是很有价值的。</p><p>我们还进行了一个快速实验，将以否定为重点的数据集扩展到覆盖所有五种失败类别。结果令人鼓舞：通过精心选择的\"难否定样例\"进行微调，使模型更好地识别哪些项目应该归类在一起，哪些不应该。话虽如此，还有更多工作要做。未来的步骤包括深入研究数据集的大小和质量如何影响性能。</p>",
  "comment_id": "6761676f2defad0001fb5d8a",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/12/banner-order.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-12-17T12:58:39.000+01:00",
  "updated_at": "2024-12-17T16:30:27.000+01:00",
  "published_at": "2024-12-17T16:30:27.000+01:00",
  "custom_excerpt": "Text embedding models struggle with capturing subtle linguistic nuances like word order, directional relationships, temporal sequences, causal connections, comparisons, and negation. Understanding these challenges is key to improving model performance.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "632ade4a3e4e55003d525971",
      "name": "Alex C-G",
      "slug": "alexcg",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/09/alex.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/twitter_banner.jpg",
      "bio": "Open-source Evangelist @ Jina AI. Old, grim, and full of Vim",
      "website": null,
      "location": "Berlin, Germany",
      "facebook": null,
      "twitter": "@alexcg",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/alexcg/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/text-embeddings-fail-to-capture-word-order-and-how-to-fix-it/",
  "excerpt": "文本嵌入模型在捕捉细微的语言细节方面仍存在困难，例如词序、方向关系、时间序列、因果关系、比较关系以及否定语义。理解这些挑战对于提升模型性能至关重要。",
  "reading_time": 12,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}