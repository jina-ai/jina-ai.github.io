{
  "slug": "a-deep-dive-into-tokenization",
  "id": "65afb3ee8da8040001e17061",
  "uuid": "02d119e4-ed5f-4edf-8b66-65aea1386d96",
  "title": "深入理解 Tokenization",
  "html": "<p>在实施 AI 流程的过程中，理解 AI 模型存在许多障碍，其中一些是相当大的障碍。但很多人首先遇到的障碍是理解我们在谈论 <strong>tokens</strong> 时究竟是什么意思。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/tokenizer?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Tokenizer API</div><div class=\"kg-bookmark-description\">Free API to tokenize texts, count and get first/last-N tokens.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-tokenize-api.png\" alt=\"\"></div></a></figure><p>在选择 AI 语言模型时，最重要的实用参数之一是其上下文窗口的大小——即最大输入文本大小——它是以 token 为单位的，而不是以词、字符或任何其他自动可识别的单位。</p><p>此外，嵌入服务通常是按\"每个 token\"计费的，这意味着要理解你的账单，tokens 很重要。</p><p>如果你不清楚什么是 token，这可能会让人非常困惑。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png\" class=\"kg-image\" alt=\"Jina Embeddings 当前价格表（2024 年 2 月）。\" loading=\"lazy\" width=\"2000\" height=\"1036\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png 2000w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Jina Embeddings 当前价格表（2024 年 2 月）。注意价格是按\"每百万 tokens\"计算的。</span></figcaption></figure><p>但在现代 AI 的所有令人困惑的方面中，tokens 可能是最不复杂的。本文将试图解释什么是 tokenization，它做什么，以及为什么我们要这样做。</p><h2 id=\"tldr\">简要总结</h2><p>对于那些想要或需要快速了解从 Jina Embeddings 购买多少 tokens，或估算需要购买多少的人来说，以下统计数据是您需要了解的。</p><h3 id=\"tokens-per-english-word\">每个英语单词的 Tokens</h3><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">对英语模型调用 Jina Embeddings v2 API 时，将使用<b><strong style=\"white-space: pre-wrap;\">大约比文本中的单词数多 10% 的 tokens，再加上每个嵌入两个 tokens</strong></b>。</div></div><p>在本文后面描述的经验测试中，使用 Jina Embeddings 英语专用模型时，各种英语文本转换为 tokens 的比率大约比单词数多 10%。这个结果相当稳定。</p><p>Jina Embeddings v2 模型的上下文窗口为 8192 个 tokens。这意味着如果您传递给 Jina 模型一个超过 7,400 个单词的英语文本，很可能会被截断。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">Jina Embeddings v2 英语版</strong></b>的最大输入大小约为<b><strong style=\"white-space: pre-wrap;\">7,400 个单词</strong></b>。</div></div><h3 id=\"tokens-per-chinese-character\">每个中文字符的 Tokens</h3><p>对于中文，结果更加变化多样。根据文本类型的不同，每个汉字的 tokens 比率从 0.6 到 0.75 不等。输入给 Jina Embeddings v2 中文版的英语文本产生的 tokens 数量与 Jina Embeddings v2 英语版大致相同：比单词数多大约 10%。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">对于<b><strong style=\"white-space: pre-wrap;\">Jina Embeddings v2 中英双语版</strong></b>，中文输入的最大大小约为<b><strong style=\"white-space: pre-wrap;\">10,500 个字符</strong></b>（<b><strong style=\"white-space: pre-wrap;\">字数</strong></b>），或者说<b><strong style=\"white-space: pre-wrap;\">每个汉字 0.6 到 0.75 个 tokens，外加每个嵌入两个 tokens</strong></b>。</div></div><h3 id=\"tokens-per-german-word\">每个德语单词的 Tokens</h3><p>德语的单词到 token 的比率比英语更多变，但比中文少。根据文本类型的不同，平均比单词多 20% 到 30% 的 tokens。将英语文本输入到 Jina Embeddings v2 德英双语版时，使用的 tokens 比仅英语和中英模型多一些：比单词多 12% 到 15% 的 tokens。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Jina Embeddings v2 德英双语版将计算<b><strong style=\"white-space: pre-wrap;\">比单词多 20% 到 30% 的 tokens，外加每个嵌入两个 tokens</strong></b>。输入上下文的最大大小约为<b><strong style=\"white-space: pre-wrap;\">6,300 个德语单词</strong></b>。</div></div><h3 id=\"caution\">注意事项</h3><p>这些是简单的计算，但对于大多数自然语言文本和大多数用户来说应该是近似正确的。最终，我们只能承诺 tokens 的数量永远不会超过文本中的字符数加二。实际上它通常会比这少得多，但我们不能事先承诺任何具体的数量。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">实际情况可能有所不同！</strong></b><br><br>这些是基于统计学上简单计算的估计。我们不能保证任何特定请求会使用多少 tokens。</div></div><p>如果你只需要有关购买多少 Jina Embeddings tokens 的建议，可以在这里停止阅读。其他公司的嵌入模型可能与 Jina 模型的单词到 token 和汉字到 token 的比率不同，但总体上不会有太大差异。</p><p>如果你想了解原因，本文的其余部分将深入探讨语言模型的 tokenization。</p><h2 id=\"words-tokens-numbers\">单词、Tokens、数字</h2><p>Tokenization 在现代 AI 模型存在之前就已经是自然语言处理的一部分了。</p><p>说计算机中的一切都只是数字可能有点陈词滥调，但这基本上是事实。然而，语言本质上并不只是一堆数字。它可能是由声波组成的语音，或是纸上的标记，甚至是印刷文本的图像或手语视频。但大多数情况下，当我们谈论使用计算机处理自然语言时，我们指的是由字符序列组成的文本：字母（a、b、c 等）、数字（0、1、2...）、标点符号和空格，使用不同的语言和文本编码。</p><p>计算机工程师称这些为\"字符串\"。</p><p>AI 语言模型接受数字序列作为输入。所以，你可能写了这样一个句子：</p><blockquote><em>What is today's weather in Berlin?</em></blockquote><p>但经过 tokenization 后，AI 模型得到的输入是：</p><pre><code class=\"language-python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>Tokenization 是将输入字符串转换为 AI 模型可以理解的特定数字序列的过程。</p><p>当你通过按 token 收费的 web API 使用 AI 模型时，每个请求都会被转换成像上面那样的数字序列。请求中的 token 数量就是该数字序列的长度。因此，请求 Jina Embeddings v2 英语版为\"<em>What is today's weather in Berlin?</em>\"生成嵌入将花费你 11 个 tokens，因为它在传递给 AI 模型之前将该句子转换成了 11 个数字的序列。</p><p>基于 <a href=\"https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)?ref=jina-ai-gmbh.ghost.io\">Transformer 架构</a>的 AI 模型具有固定大小的<strong>上下文窗口</strong>，其大小以 tokens 为单位。有时这被称为\"输入窗口\"、\"上下文大小\"或\"序列长度\"（特别是在 <a href=\"https://huggingface.co/spaces/mteb/leaderboard?ref=jina-ai-gmbh.ghost.io\">Hugging Face MTEB 排行榜</a>上）。它表示模型一次可以看到的最大文本大小。</p><p>所以，如果你想使用嵌入模型，这就是允许的最大输入大小。</p><p>Jina Embeddings v2 模型的上下文窗口都是 8,192 个 tokens。其他模型会有不同的（通常更小的）上下文窗口。这意味着无论你输入多少文本，与该 Jina Embeddings 模型相关的分词器必须将其转换为不超过 8,192 个 tokens。</p><h2 id=\"mapping-language-to-numbers\">将语言映射到数字</h2><p>解释 tokens 逻辑最简单的方式是：</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Token 是代表字符串一部分的数字。</div></div><p>对于自然语言模型来说，token 代表的字符串部分可以是一个词、词的一部分或标点符号。空格通常在分词器输出中没有明确的表示。</p><p>Tokenization 是自然语言处理中称为<a href=\"https://en.wikipedia.org/wiki/Text_segmentation?ref=jina-ai-gmbh.ghost.io\"><em>文本分割</em></a>的一组技术的一部分，执行 tokenization 的模块很符合逻辑地被称为<strong>分词器</strong>。</p><p>为了展示 tokenization 是如何工作的，我们将使用 Jina Embeddings v2 英语版最小的模型：<code>jina-embeddings-v2-small-en</code>。Jina Embeddings 的其他英语专用模型 —— <code>jina-embeddings-v2-base-en</code> —— 使用相同的分词器，所以没有必要下载我们在本文中不会使用的额外的 AI 模型。</p><p>首先，在你的 Python 环境或笔记本中安装 <code>transformers</code> 模块。使用使用 <code>-U</code> 标记确保升级到最新版本，因为此模型无法在某些旧版本上运行：</p><pre><code class=\"language-bash\">pip install -U transformers\n</code></pre><p>然后，使用 <code>AutoModel.from_pretrained</code> 下载 <a href=\"https://huggingface.co/jinaai/jina-embeddings-v2-small-en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\"><code>jina-embeddings-v2-small-en</code></a>：</p><pre><code class=\"language-Python\">from transformers import AutoModel\n\nmodel = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-small-en', trust_remote_code=True)\n</code></pre><p>要对字符串进行分词，使用模型的 <code>tokenizer</code> 成员对象的 <code>encode</code> 方法：</p><pre><code class=\"language-Python\">model.tokenizer.encode(\"What is today's weather in Berlin?\")\n</code></pre><p>结果是一串数字：</p><pre><code class=\"language-Python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>要将这些数字转换回字符串形式，使用 <code>tokenizer</code> 对象的 <code>convert_ids_to_tokens</code> 方法：</p><pre><code class=\"language-Python\">model.tokenizer.convert_ids_to_tokens([101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102])\n</code></pre><p>结果是一个字符串列表：</p><pre><code class=\"language-Python\">['[CLS]', 'what', 'is', 'today', \"'\", 's', 'weather', 'in',\n 'berlin', '?', '[SEP]']\n</code></pre><p>注意模型的分词器有如下特点：</p><ol><li>在开头添加了 <code>[CLS]</code>，在结尾添加了 <code>[SEP]</code>。这是出于技术原因必需的，意味着**每个嵌入请求都会额外消耗两个词符**，超出文本本身所需的词符数量。</li><li>将标点符号从单词中分离，将\"<em>Berlin?</em>\"转换为：<code>berlin</code> 和 <code>?</code>，将\"<em>today's</em>\"转换为 <code>today</code>、<code>'</code> 和 <code>s</code>。</li><li>将所有内容转换为小写。并非所有模型都这样做，但在使用英语时这有助于训练。在大小写有不同含义的语言中，这可能帮助不大。</li></ol><p>不同程序中的不同词数统计算法可能会对这个句子的词数有不同的计数。OpenOffice 将其计为六个词。Unicode 文本分段算法（<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode Standard Annex #29</a>）计为七个词。其他软件可能会得出其他数字，这取决于它们如何处理标点符号和\"'s\"这样的附着词。</p><p>这个模型的分词器为那六或七个词产生了九个词符，加上每个请求都需要的两个额外词符。</p><p>现在，让我们尝试一个比柏林不太常见的地名：</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"I live in Kinshasa.\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>结果如下：</p><pre><code class=\"language-Python\">['[CLS]', 'i', 'live', 'in', 'kin', '##sha', '##sa', '.', '[SEP]']\n</code></pre><p>\"Kinshasa\"这个名字被分成了三个词符：<code>kin</code>、<code>##sha</code> 和 <code>##sa</code>。<code>##</code> 表示这个词符不是词的开头。</p><p>如果我们给分词器一个完全陌生的词，词符数量相对于词数的比例会进一步增加：</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"Klaatu barada nikto\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n\n['[CLS]', 'k', '##la', '##at', '##u', 'bar', '##ada', 'nik', '##to', '[SEP]']\n</code></pre><p>三个词被分成了八个词符，再加上 <code>[CLS]</code> 和 <code>[SEP]</code> 词符。</p><p>德语的分词方式类似。使用 <a href=\"https://jina.ai/news/ich-bin-ein-berliner-german-english-bilingual-embeddings-with-8k-token-length/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Jina Embeddings v2 for German</a> 模型，我们可以用与英语模型相同的方式对\"What is today's weather in Berlin?\"的德语翻译进行分词。</p><pre><code class=\"language-Python\">german_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-de', trust_remote_code=True)\ntoken_ids = german_model.tokenizer.encode(\"Wie wird das Wetter heute in Berlin?\")\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>结果如下：</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Wie', 'wird', 'das', 'Wetter', 'heute', 'in', 'Berlin', '?', '&lt;/s&gt;']\n</code></pre><p>这个分词器与英语的有些不同，它使用 <code>&lt;s&gt;</code> 和 <code>&lt;/s&gt;</code> 代替了 <code>[CLS]</code> 和 <code>[SEP]</code>，但功能相同。另外，文本没有进行大小写标准化——保持原有的大小写形式——因为在德语中，大小写的意义与英语不同。</p><p>（为了简化说明，我删除了表示词开头的特殊字符。）</p><p>现在，让我们尝试一个来自<a href=\"https://www.welt.de/politik/deutschland/plus249565102/Proteste-der-Landwirte-Die-Krux-mit-den-Foerdermitteln.html?ref=jina-ai-gmbh.ghost.io\">报纸文章</a>的更复杂的句子：</p><blockquote>Ein Großteil der milliardenschweren Bauern-Subventionen bleibt liegen – zu genervt sind die Landwirte von bürokratischen Gängelungen und Regelwahn.</blockquote><pre><code>sentence = \"\"\"\nEin Großteil der milliardenschweren Bauern-Subventionen\nbleibt liegen – zu genervt sind die Landwirte von \nbürokratischen Gängelungen und Regelwahn.\n\"\"\"\ntoken_ids = german_model.tokenizer.encode(sentence)\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)</code></pre><p>分词结果：</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Ein', 'Großteil', 'der', 'mill', 'iarden', 'schwer', \n 'en', 'Bauern', '-', 'Sub', 'ventionen', 'bleibt', 'liegen', \n '–', 'zu', 'gen', 'ervt', 'sind', 'die', 'Landwirte', 'von', \n 'büro', 'krat', 'ischen', 'Gän', 'gel', 'ungen', 'und', 'Regel', \n 'wahn', '.', '&lt;/s&gt;']\n</code></pre><p>在这里，你可以看到许多德语词被分解成了更小的片段，而且不一定按照德语语法规则来分。这导致一个在词数统计器中只算作一个词的长德语词，在 Jina 的 AI 模型中可能被分成任意数量的词符。</p><p>让我们用中文做同样的事，把\"What is today's weather in Berlin?\"翻译为：</p><blockquote>柏林今天的天气怎么样？</blockquote><pre><code>chinese_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-zh', trust_remote_code=True)\ntoken_ids = chinese_model.tokenizer.encode(\"柏林今天的天气怎么样？\")\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>分词结果：</p><pre><code class=\"language-Python\">['&lt;s&gt;', '柏林', '今天的', '天气', '怎么样', '？', '&lt;/s&gt;']\n</code></pre><p>在中文中，书面文本通常没有词间空格，但 Jina Embeddings 分词器经常会将多个汉字组合在一起：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Token string</th>\n<th>Pinyin</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>柏林</td>\n<td>Bólín</td>\n<td>Berlin</td>\n</tr>\n<tr>\n<td>今天的</td>\n<td>jīntiān de</td>\n<td>today's</td>\n</tr>\n<tr>\n<td>天气</td>\n<td>tiānqì</td>\n<td>weather</td>\n</tr>\n<tr>\n<td>怎么样</td>\n<td>zěnmeyàng</td>\n<td>how</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>让我们使用一个来自<a href=\"https://news.mingpao.com/pns/%e6%b8%af%e8%81%9e/article/20240116/s00002/1705335848777/%e7%81%a3%e5%8d%80%e7%86%b1%e6%90%9c-%e7%a9%97%e5%9c%b0%e9%90%b5%e6%8e%a8%e6%89%8b%e6%a9%9f%e3%80%8c%e9%9d%9c%e9%9f%b3%e4%bb%a4%e3%80%8d-%e7%84%a1%e7%bd%b0%e5%89%87-%e5%b8%82%e6%b0%91%e6%9c%89%e7%a8%b1%e5%85%b7%e8%ad%a6%e7%a4%ba%e4%bd%9c%e7%94%a8-%e6%9c%89%e6%84%9f%e5%af%a6%e6%95%88%e4%b8%8d%e5%a4%a7?ref=jina-ai-gmbh.ghost.io\">香港报纸</a>的更复杂的句子：</p><pre><code class=\"language-Python\">sentence = \"\"\"\n新規定執行首日，記者在下班高峰前的下午5時來到廣州地鐵3號線，\n從繁忙的珠江新城站啟程，向機場北方向出發。\n\"\"\"\ntoken_ids = chinese_model.tokenizer.encode(sentence)\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>（翻译：<em>\"新规定实施的第一天，记者在下午 5 点高峰期到达广州地铁 3 号线，从珠江新城站出发，向机场北方向驶去。\"</em>）</p><p>结果：</p><pre><code class=\"language-python\">['&lt;s&gt;', '新', '規定', '執行', '首', '日', '，', '記者', '在下', '班', \n '高峰', '前的', '下午', '5', '時', '來到', '廣州', '地', '鐵', '3', \n '號', '線', '，', '從', '繁忙', '的', '珠江', '新城', '站', '啟', \n '程', '，', '向', '機場', '北', '方向', '出發', '。', '&lt;/s&gt;']\n</code></pre><p>这些标记并不映射到任何具体的中文词典。例如，\"啟程\" — <em>qǐchéng</em>（启程、出发）通常会被归类为一个词，但这里被分成了两个独立的字符。同样，\"在下班\"通常被认为是两个词，其中\"在\" — <em>zài</em>（在、当）和\"下班\" — <em>xiàbān</em>（下班、下班时间）是分开的，而不是像分词器这样把它分成\"在下\"和\"班\"。</p><p>在这三种语言中，分词器切分文本的位置与人类读者会划分的逻辑位置并不直接相关。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">分词器算法并不使用传统的、具有语言感知能力的词典，所以它的行为方式与人类计数词语的方式并不匹配。</div></div><p>这并不是 Jina Embeddings 模型的特定特征。这种分词方法在 AI 模型开发中几乎是普遍存在的。虽然两个不同的 AI 模型可能没有完全相同的分词器，但在当前的开发状态下，它们实际上都会使用具有这种行为特征的分词器。</p><p>下一部分将讨论分词使用的具体算法及其背后的逻辑。</p><h2 id=\"why-do-we-tokenize-and-why-this-way\">为什么要分词？为什么要用这种方式？</h2><p>AI 语言模型接收代表文本序列的数字序列作为输入，但在运行底层神经网络和创建嵌入之前还会发生一些其他处理。当面对表示小文本序列的数字列表时，模型会在其内部字典中查找每个数字，该字典为每个数字存储唯一的向量。然后将它们组合起来，作为神经网络的输入。</p><p>这意味着分词器<strong>必须</strong>能够将我们提供的<strong><em>任何</em></strong>输入文本转换为出现在模型的标记向量字典中的标记。如果我们使用传统词典中的标记，那么当我们遇到第一个拼写错误或罕见的专有名词或外来词时，整个模型就会停止。它将无法处理该输入。</p><p>在自然语言处理中，这被称为词汇表外（OOV）问题，它在所有文本类型和所有语言中都普遍存在。解决 OOV 问题有几种策略：</p><ol><li>忽略它。用\"未知\"标记替换字典中没有的所有内容。</li><li>绕过它。不使用将文本序列映射到向量的字典，而是使用将<em>单个字符</em>映射到向量的字典。英语大多数时候只使用 26 个字母，所以这必须比任何词典都更小，而且对 OOV 问题的抵抗力更强。</li><li>在文本中找到频繁出现的子序列，将它们放入字典，并对剩余部分使用字符（单字母标记）。</li></ol><p>第一种策略意味着大量重要信息会丢失。如果数据采用的形式不在字典中，模型甚至无法学习它所见到的数据。普通文本中的很多内容即使在最大的字典中也找不到。</p><p>第二种策略是可能的，研究人员也对此进行了研究。但是，这意味着模型必须接受更多的输入，必须学习更多的内容。这意味着需要更大的模型和更多的训练数据，而结果从未被证明比第三种策略更好。</p><p>AI 语言模型几乎都以某种形式实现第三种策略。大多数使用某种变体的 <a href=\"https://huggingface.co/learn/nlp-course/chapter6/6?ref=jina-ai-gmbh.ghost.io\">Wordpiece 算法</a> <a href=\"https://ieeexplore.ieee.org/document/6289079?ref=jina-ai-gmbh.ghost.io\">[Schuster and Nakajima 2012]</a> 或类似的技术，称为 <a href=\"https://en.wikipedia.org/wiki/Byte_pair_encoding?ref=jina-ai-gmbh.ghost.io\">字节对编码</a>（BPE）。[<a href=\"https://www.drdobbs.com/a-new-algorithm-for-data-compression/184402829?ref=jina-ai-gmbh.ghost.io\">Gage 1994</a>, <a href=\"https://aclanthology.org/P16-1162/?ref=jina-ai-gmbh.ghost.io\">Senrich et al. 2016</a>] 这些算法是<em>与语言无关的</em>。这意味着它们对所有书面语言的工作方式都相同，除了可能的字符的完整列表之外不需要任何知识。它们是为像 Google 的 BERT 这样的多语言模型设计的，这些模型可以接受从互联网抓取的任何输入 — 数百种语言和计算机程序等非人类语言的文本 — 这样它们就可以在不进行复杂语言学处理的情况下进行训练。</p><p>一些研究表明，使用更具语言特异性和语言感知的分词器可以带来显著的改进。[<a href=\"https://aclanthology.org/2021.acl-long.243/?ref=jina-ai-gmbh.ghost.io\">Rust et al. 2021</a>] 但是以这种方式构建分词器需要时间、金钱和专业知识。实施像 BPE 或 Wordpiece 这样的通用策略要便宜和容易得多。</p><p>然而，因此，除了通过分词器运行文本然后计算输出的标记数量之外，没有其他方法可以知道特定文本代表多少标记。因为文本的最小可能子序列是一个字母，所以你可以确定标记的数量不会大于字符数（减去空格）加二。</p><p>要获得良好的估计，我们需要向分词器输入大量文本，并根据经验计算我们获得的标记数量与输入的单词或字符数量的平均比较。在下一节中，我们将对目前可用的所有 Jina Embeddings v2 模型进行一些不太系统的经验测量。</p><h2 id=\"empirical-estimates-of-token-output-sizes\">标记输出大小的经验估计</h2><p>对于英语和德语，我使用了 Unicode 文本分段算法（<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode 标准附件 #29</a>）来获取文本的词数。当你双击某些内容时，这个算法被广泛用于选择文本片段。它是最接近通用客观词数计数器的存在。</p><p>我在 Python 中安装了实现这个文本分段器的 <a href=\"https://pypi.org/project/polyglot/?ref=jina-ai-gmbh.ghost.io\">polyglot 库</a>：</p><pre><code class=\"language-bash\">pip install -U polyglot\n</code></pre><p>要获取文本的词数，你可以使用这样的代码片段：</p><pre><code class=\"language-python\">from polyglot.text import Text\n\ntxt = \"What is today's weather in Berlin?\"\nprint(len(Text(txt).words))\n</code></pre><p>结果应该是 <code>7</code>。</p><p>要获得标记计数，将文本片段传递给各种 Jina Embeddings 模型的分词器，如下所述，每次我都从返回的标记数量中减去二。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\">这里列出的标记计数<b><strong style=\"white-space: pre-wrap;\">不包括</strong></b>每个分词文本开头和结尾的额外两个标记。</div></div><h3 id=\"english-jina-embeddings-v2-small-en-and-jina-embeddings-v2-base-en\">英语<br>（<code>jina-embeddings-v2-small-en</code> 和 <code>jina-embeddings-v2-base-en</code>）</h3><p>为了计算平均值，我从 <a href=\"https://wortschatz.uni-leipzig.de/en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Wortschatz Leipzig</a> 下载了两个英语文本语料库，这是莱比锡大学主办的一系列可自由下载的语料库：</p><ul><li>2020 年的一百万句英语新闻数据语料库（<code>eng_news_2020_1M</code>）</li><li>2016 年的一百万句 <a href=\"https://en.wikipedia.org/?ref=jina-ai-gmbh.ghost.io\">英语维基百科</a> 数据语料库（<code>eng_wikipedia_2016_1M</code>）</li></ul><p>两者都可以在<a href=\"https://wortschatz.uni-leipzig.de/en/download/English?ref=jina-ai-gmbh.ghost.io\">他们的英语下载页面</a>找到。</p><p>为了增加多样性，我还从 Project Gutenberg 下载了 <a href=\"https://www.gutenberg.org/ebooks/135?ref=jina-ai-gmbh.ghost.io\">Hapgood 翻译的维克多·雨果的《悲惨世界》</a>，以及 1611 年译成英语的《钦定版圣经》的副本。</p><p>对于所有四个文本，我使用 <code>polyglot</code> 实现的 Unicode 分段器计算单词数，然后计算 <code>jina-embeddings-v2-small-en</code> 生成的标记数，每次分词请求减去两个标记。结果如下：</p>\n<!--kg-card-begin: html-->\n<table id=\"6f07d5d4-ca08-466e-92fc-e784a932e4d0\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"4b8c4003-8ef9-4ac5-8df3-ef7662ab4d3b\"><th id=\"wvl`\" class=\"simple-table-header-color simple-table-header\">文本</th><th id=\"|<X;\" class=\"simple-table-header-color simple-table-header\">词数<br>（Unicode 分段器）<br></th><th id=\"GHal\" class=\"simple-table-header-color simple-table-header\">标记数<br>（Jina Embeddings v2<br>英语版）<br></th><th id=\"h]mu\" class=\"simple-table-header-color simple-table-header\">标记与词的比率<br>（保留 3 位小数）<br></th></tr></thead><tbody><tr id=\"7e9eda1b-54b6-40f3-be6f-b233f161e2b5\"><td id=\"wvl`\" class=\"\"><code>eng_news_2020_1M</code></td><td id=\"|<X;\" class=\"\">22,825,712</td><td id=\"GHal\" class=\"\">25,270,581</td><td id=\"h]mu\" class=\"\">1.107</td></tr><tr id=\"a81dfe1d-9143-4306-9bf3-4891ca8fb019\"><td id=\"wvl`\" class=\"\"><code>eng_wikipedia_2016_1M</code></td><td id=\"|<X;\" class=\"\">24,243,607</td><td id=\"GHal\" class=\"\">26,813,877</td><td id=\"h]mu\" class=\"\">1.106</td></tr><tr id=\"d2fff413-6e0d-4ab2-9626-4d618d99af91\"><td id=\"wvl`\" class=\"\"><code>les_miserables_en</code></td><td id=\"|<X;\" class=\"\">688,911</td><td id=\"GHal\" class=\"\">764,121</td><td id=\"h]mu\" class=\"\">1.109</td></tr><tr id=\"eb304e43-4fd3-4e02-9993-13fb0307f544\"><td id=\"wvl`\" class=\"\"><code>kjv_bible</code></td><td id=\"|<X;\" class=\"\">1,007,651</td><td id=\"GHal\" class=\"\">1,099,335</td><td id=\"h]mu\" class=\"\">1.091</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>使用精确数字并不意味着这是一个精确的结果。如此不同类型的文档都具有比单词多 9% 到 11% 的词元，这表明根据 Unicode 分词器的测量，你可能会得到比单词多大约 10% 的词元。文字处理软件通常不计算标点符号，而 Unicode 分词器会计算，所以办公软件的字数统计不一定与此相符。</p><h3 id=\"german-jina-embeddings-v2-base-de\">德语<br>(<code>jina-embeddings-v2-base-de</code>)</h3><p>对于德语，我从 <a href=\"https://wortschatz.uni-leipzig.de/en/download/German?ref=jina-ai-gmbh.ghost.io\">Wortschatz Leipzig 的德语页面</a>下载了三个语料库：</p><ul><li><code>deu_mixed-typical_2011_1M</code> — 2011 年的一百万个句子，来自不同类型的文本的平衡混合。</li><li><code>deu_newscrawl-public_2019_1M</code> — 2019 年的一百万个新闻文本句子。</li><li><code>deu_wikipedia_2021_1M</code> — 2021 年从德语维基百科提取的一百万个句子。</li></ul><p>为了增加多样性，我还从 <a href=\"https://www.deutschestextarchiv.de/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">德语文本档案馆</a>下载了<a href=\"https://deutschestextarchiv.de/search?q=Kapital&in=metadata&ref=jina-ai-gmbh.ghost.io\">马克思《资本论》的全部三卷</a>。</p><p>然后我按照与英语相同的程序进行处理：</p>\n<!--kg-card-begin: html-->\n<table id=\"ad695a91-f35b-4215-bd4d-5d1415bb9812\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"7786decb-f68d-433d-8f58-3861d0350027\"><th id=\"UGp`\" class=\"simple-table-header-color simple-table-header\" style=\"width:234.2265625px\">文本</th><th id=\"|qln\" class=\"simple-table-header-color simple-table-header\">词数<br>(Unicode 分词器)<br></th><th id=\"YXZX\" class=\"simple-table-header-color simple-table-header\">词元数<br>(Jina Embeddings v2 <br>德语和英语版)<br></th><th id=\"oEoQ\" class=\"simple-table-header-color simple-table-header\">词元与词的比率<br>(保留 3 位小数)<br></th></tr></thead><tbody><tr id=\"9cb48640-64db-4783-8bfe-c78412022a21\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_mixed-typical_2011_1M</code></td><td id=\"|qln\" class=\"\">7,924,024</td><td id=\"YXZX\" class=\"\">9,772,652</td><td id=\"oEoQ\" class=\"\">1.234</td></tr><tr id=\"32fee905-17dc-4c2c-a32d-5e6508b033bc\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_newscrawl-public_2019_1M</code></td><td id=\"|qln\" class=\"\">17,949,120</td><td id=\"YXZX\" class=\"\">21,711,555</td><td id=\"oEoQ\" class=\"\">1.210</td></tr><tr id=\"35d0c8c4-7912-4d61-829a-bb39b643aa1c\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_wikipedia_2021_1M</code></td><td id=\"|qln\" class=\"\">17,999,482</td><td id=\"YXZX\" class=\"\">22,654,901</td><td id=\"oEoQ\" class=\"\">1.259</td></tr><tr id=\"19e10367-e070-4dcc-8cbe-cfc75c43e0f9\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>marx_kapital</code></td><td id=\"|qln\" class=\"\">784,336</td><td id=\"YXZX\" class=\"\">1,011,377</td><td id=\"oEoQ\" class=\"\">1.289</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>这些结果的分布范围比纯英语模型更大，但仍然表明德语文本平均会产生比词数多 20% 到 30% 的词元数。</p><p>用德语-英语分词器处理英语文本会比纯英语分词器产生更多的词元：</p>\n<!--kg-card-begin: html-->\n<table id=\"c31b2079-e921-4e06-a24b-8ed60ae63d8d\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"fe722fdd-ab88-44b4-9f3b-43c62eb3ccb5\"><th id=\"Nc<l\" class=\"simple-table-header-color simple-table-header\" style=\"width:187.78125px\">文本</th><th id=\"R@A^\" class=\"simple-table-header-color simple-table-header\">词数<br>(Unicode 分词器)<br></th><th id=\"UUfl\" class=\"simple-table-header-color simple-table-header\">词元数<br>(Jina Embeddings v2 <br>德语和英语版)<br></th><th id=\"iTZS\" class=\"simple-table-header-color simple-table-header\">词元与词的比率<br>(保留 3 位小数)<br></th></tr></thead><tbody><tr id=\"3461fd8c-ca39-4670-8f0e-e38a4958464a\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_news_2020_1M</code></td><td id=\"R@A^\" class=\"\">24243607</td><td id=\"UUfl\" class=\"\">27758535</td><td id=\"iTZS\" class=\"\">1.145</td></tr><tr id=\"48770d4d-5855-4f5f-934f-5b2900aa56c3\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"R@A^\" class=\"\">22825712</td><td id=\"UUfl\" class=\"\">25566921</td><td id=\"iTZS\" class=\"\">1.120</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>用双语德语/英语模型嵌入英语文本时，你应该预期需要比单词多 12% 到 15% 的词元，相比纯英语模型会更多。</p><h3 id=\"chinese-jina-embeddings-v2-base-zh\">中文<br>(<code>jina-embeddings-v2-base-zh</code>)</h3><p>中文通常不使用空格书写，在 20 世纪之前也没有传统意义上的\"词\"的概念。因此，中文文本的大小通常以字数来衡量。所以，我没有使用 Unicode 分词器，而是通过删除所有空格然后直接获取字符长度来测量文本长度。</p><p>我从 <a href=\"https://wortschatz.uni-leipzig.de/en/download/Chinese?ref=jina-ai-gmbh.ghost.io\">Wortschatz Leipzig 的中文语料库页面</a>下载了三个语料库：</p><ul><li><code>zho_wikipedia_2018_1M</code> — 2018 年从中文维基百科提取的一百万个句子。</li><li><code>zho_news_2007-2009_1M</code> — 2007 年至 2009 年收集的一百万个中文新闻来源句子。</li><li><code>zho-trad_newscrawl_2011_1M</code> — 来自专门使用繁体字的新闻来源的一百万个句子。</li></ul><p>此外，为了增加多样性，我还使用了鲁迅在 20 世纪 20 年代初写的中篇小说《阿 Q 正传》。我从 <a href=\"https://www.gutenberg.org/ebooks/25332?ref=jina-ai-gmbh.ghost.io\">古登堡计划</a>下载了繁体字版本。</p>\n<!--kg-card-begin: html-->\n<table id=\"dace0ca3-97c0-481e-98e2-d2724b7bbe66\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"adc6e6ff-8afd-4915-8884-0894546a13dc\"><th id=\"bCvb\" class=\"simple-table-header-color simple-table-header\" style=\"width:223.6953125px\">文本</th><th id=\"CaUc\" class=\"simple-table-header-color simple-table-header\">字数<br></th><th id=\"CQ{d\" class=\"simple-table-header-color simple-table-header\">词元数<br>(Jina Embeddings v2 <br>中文和英语版)<br></th><th id=\"_};C\" class=\"simple-table-header-color simple-table-header\">词元与字数的比率<br>(保留 3 位小数)<br></th></tr></thead><tbody><tr id=\"e75154ce-a33e-4af1-a983-4c4213f93c0e\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_wikipedia_2018_1M</code></td><td id=\"CaUc\" class=\"\">45,116,182</td><td id=\"CQ{d\" class=\"\">29,193,028</td><td id=\"_};C\" class=\"\">0.647</td></tr><tr id=\"605560a8-5c77-4add-a3e4-4615779b571a\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_news_2007-2009_1M</code></td><td id=\"CaUc\" class=\"\">44,295,314</td><td id=\"CQ{d\" class=\"\">28,108,090</td><td id=\"_};C\" class=\"\">0.635</td></tr><tr id=\"6e23944e-a480-4978-8550-a83404b218c4\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho-trad_newscrawl_2011_1M</code></td><td id=\"CaUc\" class=\"\">54,585,819</td><td id=\"CQ{d\" class=\"\">40,290,982</td><td id=\"_};C\" class=\"\">0.738</td></tr><tr id=\"50abbb96-06f7-4308-9c66-7c18f2a67721\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>Ah_Q</code></td><td id=\"CaUc\" class=\"\">41,268</td><td id=\"CQ{d\" class=\"\">25,346</td><td id=\"_};C\" class=\"\">0.614</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>这种标记数量与字符数量比率的差异出乎意料，特别是繁体字语料库的异常值值得进一步研究。尽管如此，我们可以得出结论，对于中文，您需要的标记数量会<em>少于</em>文本中的字符数量。根据您的内容，预计可以减少 25% 到 40%。</p><p>在 Jina Embeddings v2 中文和英文版本中的英文文本产生的标记数量与纯英文模型大致相同：</p>\n<!--kg-card-begin: html-->\n<table id=\"061e7c3f-d109-476d-85fb-db3b369e4f35\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"1200d074-3353-4815-ab66-a90e93ec349d\"><th id=\"v\\xv\" class=\"simple-table-header-color simple-table-header\" style=\"width:184.53125px\">Text</th><th id=\"qlUV\" class=\"simple-table-header-color simple-table-header\" style=\"width:165.3125px\">Word count<br>(Unicode Segmenter)<br></th><th id=\"=]?F\" class=\"simple-table-header-color simple-table-header\">Token count<br>(Jina Embeddings v2 for Chinese and English)<br></th><th id=\"<rlw\" class=\"simple-table-header-color simple-table-header\">Ratio of tokens to words<br>(to 3 decimal places)<br></th></tr></thead><tbody><tr id=\"2fe4e02d-94fd-4513-bfcb-7f85d66b6883\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_news_2020_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">24,243,607</td><td id=\"=]?F\" class=\"\">26,890,176</td><td id=\"<rlw\" class=\"\">1.109</td></tr><tr id=\"e7f937f4-b156-4f5d-9e0b-3041d07b1b20\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">22,825,712</td><td id=\"=]?F\" class=\"\">25,060,352</td><td id=\"<rlw\" class=\"\">1.097</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<h2 id=\"taking-tokens-seriously\">认真对待标记</h2><p>标记是 AI 语言模型的重要支撑框架，这一领域的研究仍在持续进行。</p><p>AI 模型革命性的一个表现是它们对嘈杂数据的强大鲁棒性。即使特定模型没有使用最优的分词策略，只要网络足够大，有足够的数据，并经过充分训练，它就可以从不完美的输入中学会正确的处理方法。</p><p>因此，相比其他领域，在改进分词方面投入的精力要少得多，但这种情况可能会改变。</p><p>作为通过<a href=\"https://jina.ai/embeddings/?ref=jina-ai-gmbh.ghost.io\">Jina Embeddings 这样的 API</a> 购买嵌入的用户，您无法准确知道特定任务需要多少标记，可能需要自己进行一些测试才能得到准确的数字。不过，这里提供的估算——英语约为词数的 110%，德语约为词数的 125%，中文约为字符数的 70%——应该足以满足基本预算需求。</p>",
  "comment_id": "65afb3ee8da8040001e17061",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/01/Untitled-design--25-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-01-23T13:41:18.000+01:00",
  "updated_at": "2024-08-14T11:38:01.000+02:00",
  "published_at": "2024-01-31T16:10:14.000+01:00",
  "custom_excerpt": "Tokenization, in LLMs, means chopping input texts up into smaller parts for processing. So why are embeddings billed by the token?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "632ae7353e4e55003d52598e",
    "name": "Scott Martens",
    "slug": "scott",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
    "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
    "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
    "website": "https://jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/a-deep-dive-into-tokenization/",
  "excerpt": "在 LLM 中，Tokenization 指的是将输入文本切分成更小的部分以进行处理。那么为什么嵌入计费是按 token 收费的呢？",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Colorful speckled grid pattern with a mix of small multicolored dots on a black background, creating a mosaic effect.",
  "feature_image_caption": null
}