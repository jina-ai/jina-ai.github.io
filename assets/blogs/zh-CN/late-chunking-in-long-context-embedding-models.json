{
  "slug": "late-chunking-in-long-context-embedding-models",
  "id": "66c72e30da9a33000146d836",
  "uuid": "9eda87e2-a799-4360-bac9-6a1cd0193349",
  "title": "长文本表征模型中的迟分技术",
  "html": "<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Late Chunking 现已在 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">jina-embeddings-v3</code> API 中可用。<b><strong style=\"white-space: pre-wrap;\">建议阅读顺序：第一部分、</strong></b><a href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii/?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">第二部分</strong></b></a><b><strong style=\"white-space: pre-wrap;\">、</strong></b><a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">研究论文</strong></b></a><b><strong style=\"white-space: pre-wrap;\">。</strong></b></div></div><p></p><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">什么是 Late Chunking 及其误解：第二部分</div><div class=\"kg-bookmark-description\">我们探索 Late Chunking 的第二部分，深入探讨为什么它是生成文本块嵌入和提升搜索/RAG 性能的最佳方法。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-128x128-4.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/lc2.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">最新！第二部分：深入探讨边界提示和误解。</span></p></figcaption></figure><p>大约一年前，在 2023 年 10 月，我们发布了<a href=\"https://jina.ai/news/jina-ai-launches-worlds-first-open-source-8k-text-embedding-rivaling-openai?ref=jina-ai-gmbh.ghost.io\">全球首个具有 8K 上下文长度的开源嵌入模型</a>，<code>jina-embeddings-v2-base-en</code>。从那时起，关于嵌入模型中长上下文的实用性一直存在争议。对于许多应用来说，将数千词的文档编码为单个嵌入表示并不理想。许多用例需要检索文本的较小部分，而基于密集向量的检索系统通常在处理较小文本段时表现更好，因为语义在嵌入向量中不太可能被\"过度压缩\"。</p><p>检索增强生成（RAG）是最著名的应用之一，它需要将文档分割成较小的文本块（比如在 512 个 token 以内）。这些文本块通常存储在向量数据库中，其向量表示由文本嵌入模型生成。在运行时，同样的嵌入模型将查询编码为向量表示，然后用于识别相关的存储文本块。这些文本块随后传递给大型语言模型（LLM），后者基于检索到的文本合成对查询的响应。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/Diagram--Blog-images--1-.svg\" class=\"kg-image\" alt=\"Flowchart detailing a query processing system, starting from &quot;Query&quot; to &quot;Document Chunks&quot; and &quot;Embedding Model,&quot; then to &quot;Vec\" loading=\"lazy\" width=\"1458\" height=\"307\"><figcaption><span style=\"white-space: pre-wrap;\">典型的 RAG 流程：分块-嵌入-检索-生成。</span></figcaption></figure><p>简而言之，嵌入较小的文本块似乎更可取，部分原因是下游 LLM 的输入大小限制，还因为<strong>人们担心长上下文中的重要上下文信息在压缩成单个向量时可能会被稀释。</strong></p><p>但如果行业只需要 512 上下文长度的嵌入模型，<em>那训练 8192 上下文长度的模型又有什么意义呢？</em></p><p>在本文中，我们通过探索 RAG 中简单分块-嵌入流程的局限性，重新审视这个重要但令人不适的问题。我们引入了一种名为<strong>\"Late Chunking\"</strong>的新方法，它利用 8192 长度嵌入模型提供的丰富上下文信息来更有效地嵌入文本块。</p><h2 id=\"the-lost-context-problem\">丢失上下文问题</h2><p>简单的分块-嵌入-检索-生成的 RAG 流程并非没有挑战。具体来说，<strong>这个过程可能会破坏远距离上下文依赖关系。</strong>换句话说，当相关信息分散在多个文本块中时，将文本段从上下文中分离出来可能会使它们失效，使这种方法特别成问题。</p><p>在下图中，一篇维基百科文章被分成句子块。你可以看到像\"its\"和\"the city\"这样的短语都指代\"Berlin\"，而\"Berlin\"只在第一句中出现。这使得嵌入模型更难将这些引用与正确的实体联系起来，从而产生较低质量的向量表示。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/image-3.png\" class=\"kg-image\" alt=\"Comparative panels display Berlin's Wikipedia article and its chunked text to highlight clarity and readability benefits.\" loading=\"lazy\" width=\"1774\" height=\"456\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/08/image-3.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/08/image-3.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/08/image-3.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/08/image-3.png 1774w\" sizes=\"(min-width: 720px) 720px\"></figure><p>这意味着，如果我们像上面的例子那样将长文章分成句子长度的块，RAG 系统可能难以回答\"柏林的人口是多少？\"这样的查询。因为城市名称和人口数字从未在同一个文本块中一起出现，而且在没有更大文档上下文的情况下，LLM 在面对这些块时无法解析像\"it\"或\"the city\"这样的照应指代。</p><p>有一些启发式方法可以缓解这个问题，比如使用滑动窗口重新采样、使用多个上下文窗口长度，以及执行多次文档扫描。然而，像所有启发式方法一样，这些方法也是可能有效可能无效的；它们在某些情况下可能有用，但没有理论保证其有效性。</p><h2 id=\"the-solution-late-chunking\">解决方案：Late Chunking</h2><p>朴素编码方法（如下图左侧所示）涉及使用句子、段落或最大长度限制来预先分割文本。之后，嵌入模型重复应用于这些生成的文本块。为了为每个块生成单个嵌入，许多嵌入模型使用<em>平均池化</em>处理这些 token 级别的嵌入，以输出单个嵌入向量。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/Diagram--Blog-images--4-.svg\" class=\"kg-image\" alt=\"Flowchart comparing naive and late chunking methods in document processing with labeled steps and embeddings.\" loading=\"lazy\" width=\"1020\" height=\"865\"><figcaption><span style=\"white-space: pre-wrap;\">朴素分块策略（左）和 Late Chunking 策略（右）的示意图。</span></figcaption></figure><p>相比之下，我们在本文中提出的\"Late Chunking\"方法首先将嵌入模型的 transformer 层应用于<em>整个文本</em>或尽可能多的文本。这会为每个 token 生成一个包含整个文本信息的向量表示序列。随后，对这个 token 向量序列的每个块应用平均池化，生成考虑了整个文本上下文的每个块的嵌入。与生成独立同分布（i.i.d.）块嵌入的朴素编码方法不同，<strong>Late Chunking 创建了一组块嵌入，其中每个嵌入都\"以\"前面的嵌入为条件，从而为每个块编码更多的上下文信息。</strong></p><p>显然，要有效地应用 Late Chunking，我们需要像 <code>jina-embeddings-v2-base-en</code> 这样支持最多 8192 个 token（大约十个标准页面的文本）的长上下文嵌入模型。这种长度的文本段不太可能有需要更长上下文才能解决的上下文依赖关系。</p><p>需要强调的是，Late Chunking 仍然需要边界提示，但这些提示仅在获得 token 级别的嵌入<em>之后</em>使用——这就是其名称中\"Late\"的由来。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>朴素分块</th>\n<th>Late Chunking</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>边界提示的需求</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>边界提示的使用</td>\n<td>直接在预处理中</td>\n<td>在从 transformer 层获得 token 级别的嵌入之后</td>\n</tr>\n<tr>\n<td>生成的块嵌入</td>\n<td>i.i.d.</td>\n<td>条件性</td>\n</tr>\n<tr>\n<td>邻近块的上下文信息</td>\n<td>丢失。一些启发式方法（如重叠采样）可以缓解这一问题</td>\n<td>通过长上下文嵌入模型得到很好的保留</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"implementation-and-qualitative-evaluation\">实现和定性评估</h2><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/15vNZb6AsU7byjYoaEtXuNu567JWNzXOz?usp=sharing&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://ssl.gstatic.com/colaboratory-static/common/4c9d6ee1a7679cb6c4c106e58fabaf56/img/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://colab.research.google.com/img/colab_favicon_256px.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Late Chunking 的实现可以在上面链接的 Google Colab 中找到。在这里，我们利用了最近在 Tokenizer API 中发布的功能，该功能利用所有可能的边界提示将长文档分割成有意义的块。关于这个功能背后的算法的更多讨论可以在 X 上找到。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/tokenizer/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Tokenizer API</div><div class=\"kg-bookmark-description\">免费 API，用于文本分词和将长文本分割成块。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-tokenize-api.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Based. Semantic chunking is overrated. Especially when you write a super regex that leverages all possible boundary cues and heuristics to segment text accurately without the need for complex language models. Just think about the speed and the hosting cost. This 50-line,… <a href=\"https://t.co/AtBCSrn7nI?ref=jina-ai-gmbh.ghost.io\">pic.twitter.com/AtBCSrn7nI</a></p>— Jina AI (@JinaAI_) <a href=\"https://twitter.com/JinaAI_/status/1823756993108304135?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">August 14, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><p>当对上述维基百科示例应用延迟分块时，你可以立即看到语义相似度的提升。例如，在维基百科文章中\"这座城市\"和\"柏林\"的情况下，表示\"这座城市\"的向量现在包含了将其链接到之前提到的\"柏林\"的信息，这使得它在涉及该城市名称的查询中能获得更好的匹配效果。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Query</th>\n<th>Chunk</th>\n<th>Sim. on naive chunking</th>\n<th>Sim. on late chunking</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Berlin</td>\n<td>Berlin is the capital and largest city of Germany, both by area and by population.</td>\n<td>0.849</td>\n<td>0.850</td>\n</tr>\n<tr>\n<td>Berlin</td>\n<td>Its more than 3.85 million inhabitants make it the European Union's most populous city, as measured by population within city limits.</td>\n<td>0.708</td>\n<td>0.825</td>\n</tr>\n<tr>\n<td>Berlin</td>\n<td>The city is also one of the states of Germany, and is the third smallest state in the country in terms of area.</td>\n<td>0.753</td>\n<td>0.850</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>你可以在上面的数值结果中观察到这一点，这些结果比较了\"Berlin\"这个词与使用余弦相似度计算的柏林文章中各个句子的嵌入。\"Sim. on IID chunk embeddings\"列显示了\"Berlin\"查询嵌入与使用<em>先验</em>分块的嵌入之间的相似度值，而\"Sim. under contextual chunk embedding\"代表了使用延迟分块方法的结果。</p><h2 id=\"quantitative-evaluation-on-beir\">在 BEIR 上的定量评估</h2><p>为了验证延迟分块在玩具示例之外的有效性，我们使用了来自 <a href=\"https://github.com/beir-cellar/beir?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\">BeIR</a> 的一些检索基准进行测试。这些检索任务包括一个查询集、一个文本文档语料库和一个 QRels 文件，该文件存储了与每个查询相关的文档 ID 信息。</p><p>为了识别与查询相关的文档，将文档分块、编码成嵌入索引，并使用 k-近邻（kNN）为每个查询嵌入确定最相似的块。由于每个块对应一个文档，块的 kNN 排名可以转换为文档的 kNN 排名（在排名中仅保留多次出现的文档的第一次出现）。然后将这个结果排名与地面真实 QRels 文件提供的排名进行比较，并计算 nDCG@10 等检索指标。下面描述了这个过程，评估脚本可在此仓库中找到以供复现。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/jina-ai/late-chunking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub - jina-ai/late-chunking：解释和评估延迟分块（chunked pooling）的代码</div><div class=\"kg-bookmark-description\">解释和评估延迟分块（chunked pooling）的代码 - jina-ai/late-chunking</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">jina-ai</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://opengraph.githubassets.com/bf0bb9d5ca928dc3fe25ae621398af0fdf5e34324e37cbeee6fa4189218c9b4d/jina-ai/late-chunking\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>我们在各种 BeIR 数据集上进行了这项评估，比较了朴素分块与我们的延迟分块方法。为了获取边界提示，我们使用了一个正则表达式，将文本分割成大约 256 个令牌长度的字符串。朴素分块和延迟分块评估都使用 <a href=\"https://huggingface.co/jinaai/jina-embeddings-v2-small-en?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\"><code>jina-embeddings-v2-small-en</code></a> 作为嵌入模型；这是 <code>v2-base-en</code> 模型的较小版本，仍然支持最多 8192 个令牌长度。结果可以在下表中找到。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>Avg. Document Length (characters)</th>\n<th>Naive Chunking (nDCG@10)</th>\n<th>Late Chunking (nDCG@10)</th>\n<th>No Chunking (nDCG@10)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SciFact</td>\n<td>1498.4</td>\n<td>64.20%</td>\n<td><strong>66.10%</strong></td>\n<td>63.89%</td>\n</tr>\n<tr>\n<td>TRECCOVID</td>\n<td>1116.7</td>\n<td>63.36%</td>\n<td>64.70%</td>\n<td><strong>65.18%</strong></td>\n</tr>\n<tr>\n<td>FiQA2018</td>\n<td>767.2</td>\n<td>33.25%</td>\n<td><strong>33.84%</strong></td>\n<td>33.43%</td>\n</tr>\n<tr>\n<td>NFCorpus</td>\n<td>1589.8</td>\n<td>23.46%</td>\n<td>29.98%</td>\n<td><strong>30.40%</strong></td>\n</tr>\n<tr>\n<td>Quora</td>\n<td>62.2</td>\n<td>87.19%</td>\n<td>87.19%</td>\n<td>87.19%</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>在所有情况下，延迟分块相比朴素方法都提高了分数。在某些情况下，它甚至优于将整个文档编码为单个嵌入的方法，而在其他数据集中，完全不进行分块反而产生了最佳结果（当然，不分块只在不需要对块进行排序时才有意义，这种情况在实践中很少见）。如果我们将朴素方法和延迟分块之间的性能差距与文档长度进行对比绘图，就会发现文档的平均长度与通过延迟分块获得的 nDCG 分数的改善程度呈相关性。换句话说，<strong>文档越长，延迟分块策略的效果就越好。</strong></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/chart--22-.svg\" class=\"kg-image\" alt=\"折线图显示相对改善程度随文档长度增加而下降，从 0 到 1500 个字符。\" loading=\"lazy\" width=\"582\" height=\"337\"><figcaption><span style=\"white-space: pre-wrap;\">延迟分块相对于朴素分块的改善程度与平均文档长度呈相关。</span></figcaption></figure><h2 id=\"conclusion\">结论</h2><p>在本文中，我们介绍了一种名为\"延迟分块\"的简单方法，通过利用长上下文嵌入模型的能力来嵌入短块。我们展示了传统的独立同分布块嵌入如何无法保留上下文信息，从而导致次优检索；以及延迟分块如何提供一个简单但高效的解决方案来维护和调节每个块内的上下文信息。延迟分块的效果在较长文档上变得越发显著——这种能力<em>只能</em>通过像 <code>jina-embeddings-v2-base-en</code> 这样的高级长上下文嵌入模型才能实现。我们希望这项工作不仅验证了长上下文嵌入模型的重要性，还能激发这个主题的进一步研究。</p><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">什么是延迟分块以及什么不是：第二部分</div><div class=\"kg-bookmark-description\">延迟分块探索的第 2 部分，深入探讨为什么它是块嵌入和改善搜索/RAG 性能的最佳方法。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-128x128-5.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/lc2-1.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">继续阅读第二部分：深入探讨边界提示和误解。</span></p></figcaption></figure>",
  "comment_id": "66c72e30da9a33000146d836",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/08/banner-late-chunking.jpg",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-08-22T14:25:20.000+02:00",
  "updated_at": "2024-10-06T16:29:02.000+02:00",
  "published_at": "2024-08-22T17:06:17.000+02:00",
  "custom_excerpt": "Chunking long documents while preserving contextual information is challenging. We introduce the \"Late Chunking\" that leverages long-context embedding models to generate contextual chunk embeddings for better retrieval applications.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "636409b554b68a003dfbdef8",
      "name": "Michael Günther",
      "slug": "michael",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/profile_low_quality.jpeg",
      "cover_image": null,
      "bio": "ML Scientist and Engineer @ Jina AI. Enthusiastic about open source and AI with particular interest in solving information retrieval problems.",
      "website": "https://github.com/guenthermi",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/michael/"
    },
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "636409b554b68a003dfbdef8",
    "name": "Michael Günther",
    "slug": "michael",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/profile_low_quality.jpeg",
    "cover_image": null,
    "bio": "ML Scientist and Engineer @ Jina AI. Enthusiastic about open source and AI with particular interest in solving information retrieval problems.",
    "website": "https://github.com/guenthermi",
    "location": "Berlin",
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/michael/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/late-chunking-in-long-context-embedding-models/",
  "excerpt": "在保留上下文信息的同时对长文档进行分块是一项挑战。我们介绍了\"Late Chunking\"，它利用长上下文嵌入模型生成上下文化的分块嵌入，以实现更好的检索应用。",
  "reading_time": 8,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Diagram illustrating the 'Late Chunking' and 'Long Document Model' processes in machine learning on a black background.",
  "feature_image_caption": null
}