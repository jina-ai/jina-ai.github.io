{
  "slug": "quantization-aware-training-of-jina-embeddings-v4",
  "id": "685d4b76f1bef30001fc5449",
  "uuid": "6b06b483-2d13-4f1d-8d9d-147fa6dffe4b",
  "title": "jina-embeddings-v4 的量化感知训练",
  "html": "<p> 量化是解决人工智能扩展问题的一种广泛使用的方法。 这个名字听起来很复杂，但它只是对数字进行四舍五入，以减少它们占用的空间。 这意味着更小的 向量模型 (Embeddings)，占用更少的内存和存储空间，并且由于比较向量所需的时间更少，因此信息检索速度更快。 量化是一种纯粹的数值技术，它不关心您的模型处理什么类型的数据或您有什么用例，因此它可以带来改进，而无需大量的昂贵的领域知识。</p><p> 人们可能认为，量化涉及权衡，而且没有什么是免费的——我们必须牺牲一些精度。 在本文中，我们将向您展示一种通过<em>量化感知训练</em> (QAT) <strong>使其无损</strong>的方法。 这项技术用于 <code>jina-embeddings-v4</code> 中，以提供空间关键型应用所需的小 向量模型 (Embeddings)。</p><h2 id=\"overview-of-quantization-techniques\"> 量化技术概述</h2><p> 模型量化通常意味着以下四件事之一：</p><ul><li> 训练后量化（<strong>PTQ</strong>）</li><li> 量化 向量模型 (Embeddings) 输出训练（<strong>Output QAT</strong>）</li><li> 完全量化模型训练（<strong>Full QAT</strong>）</li><li> 从现有非量化模型中提炼出一个新的量化模型</li></ul><p> 训练后量化（<strong>PTQ</strong>）接受经过训练的 向量模型 (Embeddings) 模型，并且不以任何方式修改它。 这只是丢弃模型产生的浮点值的最低有效数字的问题。 我们只是对数字进行四舍五入，有时还会将它们缩放到一个范围。</p><p> <strong>Output QAT</strong> 意味着微调 向量模型 (Embeddings) 模型以产生最佳的降低精度向量。 这意味着修改模型，但它不会改变模型权重的精度，因此不会减小其大小。 只是输出向量的大小减小了。</p><p> <strong>Full QAT</strong> 从一个完全训练好的、全精度的模型开始，降低模型权重的精度，然后微调这个修改后的模型的性能。 这会产生一个明显更小的模型以及更小的 向量模型 (Embeddings)，但代价是需要进行一些微调。</p><p> <strong>Distillation</strong> 是训练一个新模型以匹配现有模型性能的过程。 这意味着创建一个从头开始设计为量化的新模型，然后使用现有模型生成所需的尽可能多的训练数据来训练它，直到它的性能尽可能接近现有模型。</p><p> 下表总结了这四种方法的好处：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th> 方法</th>\n<th> 更紧凑的 向量模型 (Embeddings)？</th>\n<th> 需要训练？</th>\n<th> 模型压缩？</th>\n<th> 更快的推理？</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PTQ</strong></td>\n<td><strong>✓</strong></td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Output QAT</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Full QAT</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td><strong>Distillation</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>（到更小的模型）</em></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p> 所有这四种方法都产生更紧凑的 向量模型 (Embeddings)，但除了 PTQ 之外，所有方法都需要一些额外的训练，而只有 Full QAT 和 Distillation 产生新的、更快的模型。 Full QAT 和 Distillation 的实施成本要高得多，因为它们比 Output QAT 需要更多的训练。</p><p> 在本文中，我们只关注 PTQ 和 Output QAT，它们不会改变 向量模型 (Embeddings) 模型的大小或速度。</p><h2 id=\"experimental-setup\"> 实验设置</h2><p> 对于这些实验，我们的基线模型是带有检索适配器的 <code>jina-embeddings-v4</code>，它产生 2048 维的 32 位精度浮点 (FP32) 向量。 因此，每个 向量模型 (Embedding) 的大小为 8196 字节，即 8kB。</p><p> 我们使用来自 <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR benchmark</a> 套件的查询文档检索基准测试任务研究了几个实验条件。 检索过程使用向量之间的余弦相似度来查找和排序与查询最匹配的文档。</p><ul><li><strong>基线</strong>——没有任何量化的 <code>jina-embeddings-v4</code> 向量模型 (Embedding) 的性能。 这些实验都使用了该模型的测试版本，发布性能略好。</li><li><strong>PTQ</strong>——我们量化了输出向量为二进制向量，而没有更改模型。</li><li><strong>Output QAT</strong>——我们量化了输出向量，并对检索适配器进行了微调，以提高其在量化条件下的性能。</li></ul><h3 id=\"quantization-levels\"> 量化级别</h3><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"816\" height=\"636\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image.png 816w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 1：后量化 向量模型 (Embedding) 大小比较。</span></figcaption></figure><p> 我们试验了四个不同的量化级别。</p><ul><li><strong>8 位整数</strong>——FP32 值被缩减为 -128 到 127 范围内的整数，从而将 向量模型 (Embeddings) 缩小 4 倍至 <strong>2048 字节</strong>。</li><li><strong>4 位整数</strong>——与 4 位整数相同，但我们映射到 -8 到 7 的范围，将向量大小缩小 8 倍，至 <strong>1024 字节</strong>。</li><li><strong>三元量化——</strong>所有值都映射到三个值之一：-1、0、1。以最佳方式存储时，这会将每个维度减少到 1.6 位，从而将 向量模型 (Embedding) 的大小大致减少 40 倍至大约 <strong>230 字节</strong>。</li><li><strong>二进制量化</strong>——我们使用 <code>torch.sign</code> 数据类型将 FP32 标量值转换为一位，该数据类型仅提供两个值，占用一位来存储。 这会将 2048 维 向量模型 (Embedding) 从 8192 字节减少到 <strong>128 字节</strong>，减少了 64 倍。</li></ul><h3 id=\"scaling\"> 缩放</h3><p> 对于二进制量化，量化非常简单：如果向量值大于 0 或为正数，则映射为 1。 否则，它映射为 -1。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-1.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1159\" height=\"221\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-1.png 1159w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 2：二进制量化。 所有负值都变为 -1，所有其他值都变为 1。</span></figcaption></figure><p> 对于其他量化方案，我们将值归一化到一个范围，然后四舍五入到量化级别允许的最接近的值。 向量模型 (Embedding) 由 -∞ 和 +∞（或实际上，非常大的正数和负数）之间的比例数字组成。 我们使用两个数字 $max$ 和 $min$ 来缩放值以进行量化。</p><p> 对于三元量化，我们采用每个向量分量 $v$ 并按如下方式转换它：</p><ul><li> 如果 $v$ ≥ $max$，则 $v$ 变为 1。</li><li> 如果 $v$ ≤ $min$，则 $v$ 变为 -1。</li><li> 如果 $min$ &lt; $v$ &lt; $max$，则 $v$ 变为 0。</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-2.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1030\" height=\"220\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-2.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-2.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-2.png 1030w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 3：三元量化。 定义了一个区间，其中的值变为 0。 所有较低的值都变为 -1，所有较高的值都变为 1。</span></figcaption></figure><p> 对于 4 位整数：</p><ul><li> 如果 $v$ ≥ $max$，则 $v$ 变为 7。</li><li> 如果 $v$ ≤ $min$，则 $v$ 变为 -8。</li><li> 如果 $min$ &lt; $v$ &lt; $max$，则 $v$ 变为 $16*(v - min)/(max - min) - 8$，然后四舍五入到最接近的整数。 这会将值缩放到 $[-8,7]$ 范围。</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-3.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1023\" height=\"221\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-3.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-3.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-3.png 1023w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 4：4 位量化。 定义了一个区间，所有值都归一化到定义的范围 [-8,7]。</span></figcaption></figure><p></p><p> 对于 8 位整数：</p><ul><li> 如果 $v$ ≥ $max$，则 $v$ 变为 127。</li><li> 如果 $v$ ≤ $min$，则 $v$ 变为 -128。</li><li> 如果 $min$ &lt; $v$ &lt; $max$，则 $v$ 变为 $256*(v - min)/(max - min) - 128$，四舍五入到最接近的整数。 这会将值缩放到 $[-128,127]$ 范围。</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-4.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1023\" height=\"219\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-4.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-4.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-4.png 1023w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">图 5：8 位量化。 定义了一个区间，所有值都归一化到定义的范围 [-128,127]。</span></figcaption></figure><p> 为了计算 $max$ 和 $min$，我们使用了两种方法：</p><ul><li><strong>Min/Max</strong>——我们分批处理我们的数据，并且对于每一批，我们识别出最高和最低向量分量，将 $max$ 设置为最高，将 $min$ 设置为最低。</li><li><strong>批量滚动平均</strong>——对于每一批，我们计算向量分量的平均值和标准差。 当我们处理所有批次时，我们保持平均值和标准差的移动平均值。 如果 $avg$ 是批次平均值的当前移动平均值，而 $std$ 是标准差的当前移动平均值，那么对于每个批次：</li></ul><p> $max = avg + std$<br>$min = avg - std$</p><h3 id=\"qat-fine-tuning\"> QAT 微调</h3><p> 对于 PTQ 实验，我们按原样使用模型，并使用上述方法量化它产生的 向量模型 (Embeddings)。</p><p> 对于 Output QAT，我们使用<em>直接传递估计</em>微调模型。 这意味着我们反转量化过程，恢复值的完整精度，然后在计算损失（即误差）之前，然后我们使用该损失指标来微调模型。</p><p>在每种情况下，我们都进行了 10,000 步的微调，每 500 步保存一个检查点。 然后，我们保留了在 <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a> 基准测试中得分最高的检查点。</p><h3 id=\"asymmetric-quantization\">非对称量化</h3><p>PTQ 和 Output QAT 降低了向量模型 (Embeddings)的大小，但没有降低模型大小或推理速度；所有的节省都在于存储的文档向量模型 (Embeddings)的大小和检索速度。</p><p>因此，我们测试了量化查询向量和在检索时保持它们不量化这两种情况，因为无论哪种方式，它都不会改变存储的向量模型 (Embeddings)的大小。</p><h2 id=\"results\">结果</h2><p>我们总共测试了九种情况，总结在下表中：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>条件名称</th>\n<th>微调</th>\n<th>量化级别</th>\n<th>缩放策略</th>\n<th>量化查询</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基线</td>\n<td>❌</td>\n<td>不适用</td>\n<td>不适用</td>\n<td>不适用</td>\n</tr>\n<tr>\n<td>PTQ Both</td>\n<td>❌</td>\n<td>二值</td>\n<td>不适用</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>PTQ Docs Only</td>\n<td>❌</td>\n<td>二值</td>\n<td>不适用</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>QAT Binary</td>\n<td><strong>✓</strong></td>\n<td>二值</td>\n<td>不适用</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT Binary Docs Only</td>\n<td><strong>✓</strong></td>\n<td>二值</td>\n<td>不适用</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>QAT Trinary</td>\n<td><strong>✓</strong></td>\n<td>三值</td>\n<td>滚动平均</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 4-bits</td>\n<td><strong>✓</strong></td>\n<td>4-bits</td>\n<td>滚动平均</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 8-bits</td>\n<td><strong>✓</strong></td>\n<td>8-bits</td>\n<td>滚动平均</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 8-bits Min/Max</td>\n<td><strong>✓</strong></td>\n<td>8-bits</td>\n<td>Min/Max</td>\n<td><strong>✓</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p><em>表 2：实验条件</em></p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>条件名称</th>\n<th>平均得分</th>\n<th>与基线的差异</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基线</td>\n<td>60.10</td>\n<td>不适用</td>\n</tr>\n<tr>\n<td>PTQ Binary</td>\n<td>58.33</td>\n<td>-1.78</td>\n</tr>\n<tr>\n<td>PTQ Binary Docs Only</td>\n<td>59.08</td>\n<td>-1.02</td>\n</tr>\n<tr>\n<td>QAT Binary</td>\n<td>59.22</td>\n<td>-0.89</td>\n</tr>\n<tr>\n<td>QAT Binary Docs Only</td>\n<td>60.81</td>\n<td>+0.70</td>\n</tr>\n<tr>\n<td>QAT Trinary</td>\n<td>59.49</td>\n<td>-0.62</td>\n</tr>\n<tr>\n<td>QAT 4-bits</td>\n<td>61.73</td>\n<td>+1.62</td>\n</tr>\n<tr>\n<td>QAT 8-bits</td>\n<td>61.67</td>\n<td>+1.56</td>\n</tr>\n<tr>\n<td>QAT 8-bits Min/Max</td>\n<td>61.29</td>\n<td>+1.19</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p><em>表 3：每种条件在十二个 NanoBEIR 基准测试中的平均得分（以 % 正确率表示）。</em></p><p>从上表可以看出，为量化进行微调可以提高分数。 <strong>PTQ Binary</strong> 和 <strong>QAT Binary</strong> 条件之间的唯一区别是微调，并且分数差异显着。 同样，我们看到 <strong>PTQ Binary Docs Only</strong> 和 <strong>QAT Binary Docs Only</strong> 条件之间的分数提高了近 2%，它们的区别仅在于相同的微调。</p><p>不出所料，我们还看到分数通常会随着量化程度的降低而提高，4-bit 量化的得分高于三值量化，而三值量化又优于二值量化。 然而，进一步提高到 8-bits 似乎并没有改善任何东西。</p><p>我们只在二值情况下测试了保留未量化的查询，但这似乎提高了性能。</p><p>最后，我们的测试表明，滚动平均缩放方法优于简单的 min/max 方法。</p><h2 id=\"conclusion\">结论</h2><p>量化对于向量模型 (Embeddings)具有一些重要的操作优势，因为它显着减小了向量模型 (Embeddings)的大小并加速了信息检索。 虽然简单的训练后量化 (PTQ) 在内存和存储方面提供了立竿见影的好处，但我们的实验表明，量化感知训练 (QAT) 显着减轻了不可避免的精度损失。 微调始终产生更好的分数。</p><p>量化程度直接影响性能，这符合您对基于降低值精度的方法的预期。 较低程度的量化（例如，4-bit）通常优于较高程度的方法（例如，二值），但令人惊讶的是，8-bit 量化和 4-bit 量化之间的性能没有显着差异。 似乎在达到某个不精确的阈值之前，更大量化和更少量化之间几乎没有区别。</p><p>缩放策略也很重要，滚动平均方法显示出优于固定 min/max 方法的结果。 使用相对于数据的缩放值似乎效果更好，值得进一步探索。</p><p>量化可以让你以更少的成本从向量模型 (Embeddings)中获得更多。 尽管本文没有探讨量化的所有选项，但它探讨了两种易于访问的选项，它们具有真正的优势。 我们正在努力改进和完善量化策略，以便进一步降低用户的成本，并期望在不久的将来发布对 <code>jina-embeddings-v4</code> 的二值支持。</p>",
  "comment_id": "685d4b76f1bef30001fc5449",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/06/Heading---2025-06-30T114820.483.webp",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-06-26T15:30:30.000+02:00",
  "updated_at": "2025-06-30T21:14:36.000+02:00",
  "published_at": "2025-06-30T21:14:36.000+02:00",
  "custom_excerpt": "Quantization gives smaller embeddings. We show you fine-tuned quantization gives you even lossless embeddings.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "64ae64a4733bc60001949ca4",
      "name": "Andrei Ungureanu",
      "slug": "andrei",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2023/07/Me.jpg",
      "cover_image": null,
      "bio": "Software / AI Engineer, with a passion for content creation.",
      "website": null,
      "location": "Beijing, China",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/andrei/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/quantization-aware-training-of-jina-embeddings-v4/",
  "excerpt": "量化可以得到更小的向量模型 (Embeddings)。我们将向您展示经过微调的量化，甚至可以为您提供无损的向量模型 (Embeddings)。",
  "reading_time": 8,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}