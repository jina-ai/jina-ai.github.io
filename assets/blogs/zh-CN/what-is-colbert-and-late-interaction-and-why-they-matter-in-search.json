{
  "slug": "what-is-colbert-and-late-interaction-and-why-they-matter-in-search",
  "id": "65d3a2134a32310001f5b71b",
  "uuid": "726c942b-f6a7-4c89-a0ad-39aaad98d02f",
  "title": "什么是 ColBERT 和延迟交互？为什么它们在搜索中很重要？",
  "html": "<figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/jina-colbert-v2-multilingual-late-interaction-retriever-for-embedding-and-reranking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Jina ColBERT v2：用于嵌入和重排序的多语言后期交互检索器</div><div class=\"kg-bookmark-description\">Jina ColBERT v2 支持 89 种语言，具有卓越的检索性能、用户可控的输出维度以及 8192 的令牌长度。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/colbert-banner.jpg\" alt=\"\"></div></a><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">更新：在 2024 年 8 月 31 日，我们发布了 Jina-ColBERT 的第二个版本，具有更好的性能、支持 89 种语言以及灵活的输出维度。查看发布文章了解更多详情。</span></p></figcaption></figure><p>上周五，Jina AI 在 Hugging Face 上发布的 <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">ColBERT 模型</a>在 AI 社区引起了巨大轰动，尤其是在 Twitter/X 上。虽然许多人都熟悉开创性的 BERT 模型，但 ColBERT 引发的热议让一些人产生疑问：在信息检索技术领域，是什么让 ColBERT 如此出众？为什么 AI 社区对 8192 长度的 ColBERT 如此兴奋？本文将深入探讨 ColBERT 和 ColBERTv2 的细节，重点介绍它们的设计、改进以及 ColBERT 后期交互的惊人效果。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">轻松提升搜索相关性和 RAG 准确性</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a></figure><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Introducing jina-colbert-v1-en. It takes late interactions &amp; token-level embeddings of ColBERTv2 and has better zero-shot performance on many tasks (in and out-of-domain). Now on <a href=\"https://twitter.com/huggingface?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">@huggingface</a> under Apache 2.0 licence<a href=\"https://t.co/snVGgI753H?ref=jina-ai-gmbh.ghost.io\">https://t.co/snVGgI753H</a></p>— Jina AI (@JinaAI_) <a href=\"https://twitter.com/JinaAI_/status/1758503072999907825?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">February 16, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><h2 id=\"what-is-colbert\">什么是 ColBERT？</h2><p>\"ColBERT\" 代表\"基于 BERT 的上下文化后期交互\"（Contextualized Late Interaction over BERT），这是一个源自斯坦福大学的模型，它利用了 BERT 的深度语言理解能力，同时引入了一种新颖的交互机制。这种被称为\"后期交互\"的机制，通过在检索过程的最后阶段之前分别处理查询和文档，实现了高效和精确的检索。具体来说，该模型有两个版本：</p><ul><li><strong>ColBERT</strong>：最初的模型是 <a href=\"https://x.com/lateinteraction?s=20&ref=jina-ai-gmbh.ghost.io\"><strong>Omar Khattab</strong></a> <strong>和 Matei Zaharia</strong> 的创意，通过论文\"ColBERT：通过基于 BERT 的上下文化后期交互实现高效和有效的段落搜索\"提出了一种新颖的信息检索方法。该论文发表于 SIGIR 2020。</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2004.12832?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERT：通过基于 BERT 的上下文化后期交互实现高效和有效的段落搜索</div><div class=\"kg-bookmark-description\">自然语言理解（NLU）的最新进展正在推动信息检索（IR）的快速发展，这主要归功于针对文档排序的深度语言模型（LMs）的微调。虽然这些基于 LMs 的排序模型非常有效，但它们的计算成本比之前的方法高出几个数量级，特别是因为它们必须将每个查询-文档对通过一个庞大的神经网络来计算一个相关性分数。为了解决这个问题，我们提出了 ColBERT，这是一个新颖的排序模型，它使 BERT 等深度 LMs 能够进行高效检索。ColBERT 引入了一种后期交互架构，使用 BERT 独立编码查询和文档，然后采用一种经济但强大的交互步骤来模拟它们的细粒度相似性。通过延迟但保留这种细粒度交互，ColBERT 可以利用深度 LMs 的表达能力，同时获得离线预计算文档表示的能力，从而大大加快查询处理速度。除了降低重新排序由传统模型检索的文档的成本外，ColBERT 的易于剪枝的交互机制还能够利用向量相似性索引直接从大型文档集合中进行端到端检索。我们使用两个最新的段落搜索数据集对 ColBERT 进行了广泛评估。结果表明，ColBERT 的效果与现有的基于 BERT 的模型具有竞争力（并且优于所有非 BERT 基线），同时执行速度快两个数量级，每次查询所需的 FLOPs 少四个数量级。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Omar Khattab</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">原始 ColBERT 论文介绍了\"后期交互\"。</span></p></figcaption></figure><ul><li><strong>ColBERTv2</strong>：在基础工作的基础上，<strong>Omar Khattab</strong> 继续他的研究，与 <strong>Barlas Oguz、Matei Zaharia 和 Michael S. Bernstein</strong> 合作，在 SIGIR 2021 上提出了\"ColBERTv2：通过轻量级后期交互实现有效和高效的检索\"。ColBERT 的这一新版本解决了之前的局限性，并引入了关键改进，如<strong>去噪监督</strong>和<strong>残差压缩</strong>，提高了模型的检索效果和存储效率。</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2112.01488?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERTv2：通过轻量级后期交互实现有效和高效的检索</div><div class=\"kg-bookmark-description\">神经信息检索（IR）极大地推进了搜索和其他知识密集型语言任务的发展。虽然许多神经 IR 方法将查询和文档编码为单向量表示，但后期交互模型以每个令牌的粒度产生多向量表示，并将相关性建模分解为可扩展的令牌级计算。这种分解已被证明能使后期交互更有效，但它使这些模型的空间占用增加了一个数量级。在这项工作中，我们引入了 ColBERTv2，这是一个将积极的残差压缩机制与去噪监督策略相结合的检索器，可以同时提高后期交互的质量和减少空间占用。我们在广泛的基准测试中评估了 ColBERTv2，在训练领域内外建立了最先进的质量，同时将后期交互模型的空间占用减少了 6-10 倍。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Keshav Santhanam</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">ColBERTv2 添加了去噪监督和残差压缩，以提高训练数据质量并减少空间占用。</span></p></figcaption></figure><h2 id=\"understand-colberts-design\">理解 ColBERT 的设计</h2><p>鉴于 ColBERTv2 的架构与原始 ColBERT 非常相似，其主要创新在于训练技术和压缩机制，我们首先将深入探讨原始 ColBERT 的基本方面。</p><h3 id=\"what-is-late-interaction-in-colbert\">什么是 ColBERT 中的后期交互？</h3><p>\"交互\"指的是通过比较查询和文档的表示来评估它们之间相关性的过程。</p><p>\"<em>后期交互</em>\"是 ColBERT 的精髓。这个术语源自模型的架构和处理策略，其中查询和文档表示之间的交互发生在过程的后期，即在两者被独立编码之后。这与\"<em>早期交互</em>\"模型形成对比，在早期交互模型中，查询和文档嵌入在较早的阶段就进行交互，通常是在模型编码之前或期间。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>交互类型</th>\n<th>模型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>早期交互</td>\n<td>BERT, ANCE, DPR, Sentence-BERT, DRMM, KNRM, Conv-KNRM, etc.</td>\n</tr>\n<tr>\n<td>后期交互</td>\n<td>ColBERT, ColBERTv2</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>早期交互会增加计算复杂度，因为它需要考虑所有可能的查询-文档对，这使得它在大规模应用中效率较低。</p><p>像 ColBERT 这样的后期交互模型通过允许预计算文档表示并在最后采用更轻量级的交互步骤来优化效率和可扩展性，这种交互步骤专注于已编码的表示。这种设计选择使得检索时间更快，计算需求更低，更适合处理大型文档集合。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/colbert-blog-interaction.svg\" class=\"kg-image\" alt=\"Diagram illustrating query-document similarity with models for no, partial, and late interaction, including language mode rep\" loading=\"lazy\" width=\"300\" height=\"143\"><figcaption><span style=\"white-space: pre-wrap;\">示意图展示了神经 IR 中的查询-文档交互范式，其中最左侧为 ColBERT 的后期交互方式。</span></figcaption></figure><h3 id=\"no-interaction-cosine-similarity-of-document-and-query-embeddings\">无交互：文档和查询嵌入向量的余弦相似度</h3><p>许多实用的向量数据库和神经搜索解决方案都依赖于文档和查询嵌入向量之间的快速余弦相似度匹配。虽然这种方法在直观性和计算效率方面很有吸引力，但这种被称为\"无交互\"或\"非基于交互\"的方法与那些包含某种形式的查询和文档交互的模型相比，已被发现表现不佳。</p><p>\"无交互\"方法的核心限制在于其无法捕捉查询和文档术语之间的复杂细微差别和关系。信息检索的本质是理解并匹配查询背后的意图与文档中的内容。这个过程通常需要对相关术语进行深入的上下文理解，而单一的、聚合的文档和查询嵌入向量难以提供这种理解。</p><h2 id=\"query-and-document-encoders-in-colbert\">ColBERT 中的查询和文档编码器</h2><p>ColBERT 的编码策略基于以深度上下文语言理解而闻名的 BERT 模型。该模型为查询或文档中的每个 token 生成密集的向量表示，<strong>分别为查询和文档创建上下文化嵌入向量包。</strong>这为后期交互阶段的嵌入向量细致比较提供了基础。</p><h3 id=\"query-encoder-of-colbert\">ColBERT 的查询编码器</h3><p>对于包含 token ${q_1, q_2, ..., q_l}$ 的查询 $Q$，首先将 $Q$ 分词为基于 BERT 的 WordPiece token，并在前面添加特殊的 <code>[Q]</code> token。这个 <code>[Q]</code> token 位于 BERT 的 <code>[CLS]</code> token 之后，表示查询的开始。</p><p>如果查询短于预定义的 token 数量 $N_q$，则用 <code>[mask]</code> token 填充到 $N_q$；否则截断为前 $N_q$ 个 token。填充后的序列通过 BERT，然后经过 CNN（卷积神经网络）和标准化。输出是一组嵌入向量，在下面表示为 $\\mathbf{E}_q$：<br>$$\\mathbf{E}_q := \\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[Q]},q_0,q_1,\\ldots,q_l\\mathtt{[mask]},\\mathtt{[mask]},\\ldots,\\mathtt{[mask]}\\right)\\right)$$</p><h3 id=\"document-encoder-of-colbert\">ColBERT 的文档编码器</h3><p>类似地，对于包含 token ${d_1, d_2, ..., d_n}$ 的文档 $D$，在前面添加 <code>[D]</code> token 来表示文档的开始。这个序列无需填充，经过相同的处理过程，得到的嵌入向量集合表示为 $\\mathbf{E}_d$：<br>$$\\mathbf{E}_d := \\mathrm{Filter}\\left(\\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[D]},d_0,d_1,...,d_n\\right)\\right)\\right)$$</p><p>使用 <code>[mask]</code> token 填充查询（在论文中称为<strong>查询增强</strong>）确保了所有查询的长度一致，便于批处理。<code>[Q]</code> 和 <code>[D]</code> token 明确标记查询和文档的开始，帮助模型区分这两种输入类型。</p><h3 id=\"comparing-colbert-to-cross-encoders\">ColBERT 与交叉编码器的比较</h3><p>交叉编码器同时处理查询和文档对，使其具有很高的准确性，但由于需要评估每个可能的配对，在大规模任务中效率较低。它们在特定场景中表现出色，比如语义相似度任务或详细的内容比较，这些场景需要精确评分句子对。然而，这种设计限制了它们在需要从大型数据集中快速检索的情况下的应用，这种情况下预计算嵌入向量和高效的相似度计算至关重要。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/ce-vs-colbert.svg\" class=\"kg-image\" alt=\"Diagrams comparing &quot;Cross Encoder: Early all-to-all interaction&quot; and &quot;ColBERT: Late interaction&quot; with labeled Query and Docum\" loading=\"lazy\" width=\"210\" height=\"150\"></figure><p>相比之下，ColBERT 的后期交互模型允许预计算文档嵌入向量，在不影响语义分析深度的同时显著加快了检索过程。虽然与交叉编码器的直接方法相比这种方法看似反直觉，但它为实时和大规模信息检索任务提供了一个可扩展的解决方案。这代表了计算效率和交互建模质量之间的战略性妥协。</p><h2 id=\"finding-the-top-k-documents-using-colbert\">使用 ColBERT 查找 top-K 文档</h2><p>一旦我们获得了查询和文档的嵌入向量，查找最相关的 top-K 文档就变得直接了（但不像计算两个向量的余弦相似度那么直接）。</p><p>关键操作包括批量点积计算以计算词项间的相似度，在文档词项上进行最大池化以找到每个查询词项的最高相似度，以及对查询词项求和以得到总文档分数，然后根据这些分数对文档进行排序。伪 PyTorch 代码如下所示：</p><pre><code class=\"language-python\">import torch\n\ndef compute_relevance_scores(query_embeddings, document_embeddings, k):\n    \"\"\"\n    Compute relevance scores for top-k documents given a query.\n    \n    :param query_embeddings: Tensor representing the query embeddings, shape: [num_query_terms, embedding_dim]\n    :param document_embeddings: Tensor representing embeddings for k documents, shape: [k, max_doc_length, embedding_dim]\n    :param k: Number of top documents to re-rank\n    :return: Sorted document indices based on their relevance scores\n    \"\"\"\n    \n    # Ensure document_embeddings is a 3D tensor: [k, max_doc_length, embedding_dim]\n    # Pad the k documents to their maximum length for batch operations\n    # Note: Assuming document_embeddings is already padded and moved to GPU\n    \n    # Compute batch dot-product of Eq (query embeddings) and D (document embeddings)\n    # Resulting shape: [k, num_query_terms, max_doc_length]\n    scores = torch.matmul(query_embeddings.unsqueeze(0), document_embeddings.transpose(1, 2))\n    \n    # Apply max-pooling across document terms (dim=2) to find the max similarity per query term\n    # Shape after max-pool: [k, num_query_terms]\n    max_scores_per_query_term = scores.max(dim=2).values\n    \n    # Sum the scores across query terms to get the total score for each document\n    # Shape after sum: [k]\n    total_scores = max_scores_per_query_term.sum(dim=1)\n    \n    # Sort the documents based on their total scores\n    sorted_indices = total_scores.argsort(descending=True)\n    \n    return sorted_indices\n</code></pre><p>注意，这个过程在训练和推理时的重排序中都会使用。ColBERT 模型使用成对排序损失进行训练，其中训练数据由三元组 $(q, d^+, d^-)$ 组成，其中 $q$ 表示查询，$d^+$ 是查询的相关（正面）文档，$d^-$ 是不相关（负面）文档。模型的目标是学习表示，使得 $q$ 和 $d^+$ 之间的相似度分数高于 $q$ 和 $d^-$ 之间的分数。</p><p>训练目标可以数学表示为最小化以下损失函数：$$\\mathrm{Loss} = \\max(0, 1 - S(q, d^+) + S(q, d^-))$$</p><p>，其中 $S(q, d)$ 表示 ColBERT 计算的查询 $q$ 和文档 $d$ 之间的相似度分数。这个分数是通过聚合查询和文档之间最佳匹配嵌入向量的最大相似度分数获得的，遵循模型架构中描述的后期交互模式。这种方法确保模型被训练为区分给定查询的相关和不相关文档，通过鼓励正面和负面文档对的相似度分数之间有更大的差距。</p><h3 id=\"denoised-supervision-in-colbertv2\">ColBERTv2 中的去噪监督</h3><p>ColBERTv2 中的去噪监督通过选择具有挑战性的负样本和利用交叉编码器进行蒸馏来改进原始训练过程。这种改进训练数据质量的复杂方法包括以下几个步骤：</p><ol><li><strong>初始训练</strong>：利用 MS MARCO 数据集的官方三元组，包括查询、相关文档和不相关文档。</li><li><strong>索引和检索</strong>：使用 ColBERTv2 的压缩方法索引训练段落，然后为每个查询检索 top-k 段落。</li><li><strong>交叉编码器重排序</strong>：通过 MiniLM 交叉编码器重排序来改进段落选择，将其分数蒸馏到 ColBERTv2 中。</li><li><strong>形成训练元组</strong>：生成 w-way 元组用于训练，结合高排名和低排名的段落创建具有挑战性的样本。</li><li><strong>迭代改进</strong>：重复该过程以持续改进硬负样本的选择，从而提高模型性能。</li></ol><p>注意，这个过程代表了对 ColBERT 训练机制的复杂改进，而不是对其架构的根本改变。</p><h3 id=\"hyperparameters-of-colbert\">ColBERT 的超参数</h3><p>ColBERT 的超参数总结如下：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>超参数</th>\n<th>最佳选择</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>学习率</td>\n<td>3 x 10^{-6}</td>\n<td>为微调选择，确保模型更新稳定有效。</td>\n</tr>\n<tr>\n<td>批量大小</td>\n<td>32</td>\n<td>平衡计算效率和每次更新捕获足够信息的能力。</td>\n</tr>\n<tr>\n<td>每个查询的嵌入数量 (Nq)</td>\n<td>32</td>\n<td>固定值以确保查询间表示大小的一致性，有助于高效处理。</td>\n</tr>\n<tr>\n<td>嵌入维度 (m)</td>\n<td>128</td>\n<td>经证明可以在表示能力和计算效率之间提供良好平衡。</td>\n</tr>\n<tr>\n<td>训练迭代次数</td>\n<td>200k (MS MARCO)，125k (TREC CAR)</td>\n<td>选择以确保充分学习同时避免过拟合，根据数据集特征进行调整。</td>\n</tr>\n<tr>\n<td>每维度嵌入的字节数</td>\n<td>4（重排序），2（端到端排序）</td>\n<td>在精度和空间效率之间权衡，考虑应用场景（重排序与端到端）。</td>\n</tr>\n<tr>\n<td>向量相似度函数</td>\n<td>余弦（重排序），（平方）L2（端到端）</td>\n<td>基于各自检索场景的性能和效率选择。</td>\n</tr>\n<tr>\n<td>FAISS 索引分区 (P)</td>\n<td>2000</td>\n<td>决定搜索空间分区的粒度，影响搜索效率。</td>\n</tr>\n<tr>\n<td>搜索最近分区数 (p)</td>\n<td>10</td>\n<td>在搜索范围和计算效率之间取得平衡。</td>\n</tr>\n<tr>\n<td>每个嵌入的子向量数 (s)</td>\n<td>16</td>\n<td>影响量化的粒度，影响搜索速度和内存使用。</td>\n</tr>\n<tr>\n<td>索引每维度表示</td>\n<td>16 位值</td>\n<td>用于端到端检索的第二阶段，在准确性和空间之间取得平衡。</td>\n</tr>\n<tr>\n<td>编码器层数</td>\n<td>12 层 BERT</td>\n<td>上下文理解深度和计算效率之间的最佳平衡。</td>\n</tr>\n<tr>\n<td>最大查询长度</td>\n<td>128</td>\n<td>查询编码器处理的最大 token 数。<b>这在 Jina-ColBERT 模型中得到了扩展。</b></td>\n</tr>\n<tr>\n<td>最大文档长度</td>\n<td>512</td>\n<td>文档编码器处理的最大 token 数。<b>这在 Jina-ColBERT 模型中扩展到了 8192。</b></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"the-indexing-strategy-of-colbert\">ColBERT 的索引策略</h2>\n<p>与将每个文档编码为一个嵌入向量的基于表示的方法不同，<strong>ColBERT 将文档（和查询）编码为嵌入包，文档中的每个 token 都有自己的嵌入。</strong>这种方法本质上意味着对于较长的文档，需要存储更多的嵌入，<strong>这是原始 ColBERT 的一个痛点，后来在 ColBERTv2 中得到了解决。</strong></p>\n<p>高效管理这一问题的关键在于 ColBERT 使用向量数据库（如 <a href=\"https://github.com/facebookresearch/faiss?ref=jina-ai-gmbh.ghost.io\">FAISS</a>）进行索引和检索，以及其精心设计的索引过程，可以高效处理大量数据。原始 ColBERT 论文提到了几个提高索引和检索效率的策略，包括：</p>\n<ul>\n<li><strong>离线索引</strong>：文档表示在离线计算，允许预先计算和存储文档嵌入。这个过程利用批处理和 GPU 加速来高效处理大型文档集合。</li>\n<li><strong>嵌入存储</strong>：文档嵌入可以使用 32 位或 16 位值存储每个维度，在精度和存储需求之间提供权衡。这种灵活性使 ColBERT 能够在有效性（检索性能）和效率（存储和计算成本）之间保持平衡。</li>\n</ul>\n<p>在 ColBERTv2 中引入的<strong>残差压缩</strong>是原始 ColBERT 中不存在的新方法，它在保持质量的同时将模型的空间占用减少了 6-10 倍。这种技术通过有效捕获和仅存储与固定参考质心的差异来进一步压缩嵌入。</p>\n<h2 id=\"effectiveness-and-efficiency-of-colbert\">ColBERT 的有效性和效率</h2>\n<p>人们可能最初认为将 BERT 的深度上下文理解整合到搜索中必然需要大量计算资源，由于高延迟和计算成本而使这种方法在实时应用中不太可行。然而，ColBERT 通过其创新的后期交互机制挑战并推翻了这一假设。以下是一些值得注意的要点：</p>\n<ol>\n<li><strong>显著的效率提升</strong>：与传统的基于 BERT 的排序模型相比，ColBERT 在计算成本（FLOPs）和延迟方面实现了数量级的减少。具体来说，对于给定的模型大小（例如 12 层\"base\" transformer 编码器），ColBERT 不仅匹配而且在某些情况下超过了 BERT 基础模型的效果，同时显著降低了计算需求。例如，在重排序深度 <em>k</em>=10 时，BERT 需要的 FLOPs 比 ColBERT 多近 180 倍；随着 <em>k</em> 的增加，这个差距进一步扩大，在 <em>k</em>=1000 时达到 13900 倍，在 <em>k</em>=2000 时甚至达到 23000 倍。</li>\n<li><strong>端到端检索中改进的召回率和 MRR@10</strong>：与最初认为查询和文档表示之间需要更深层的交互（如早期交互模型所见）才能获得高检索性能的直觉相反，ColBERT 的端到端检索设置展现出了卓越的效果。例如，其 Recall@50 超过了官方 BM25 的 Recall@1000 和几乎所有其他模型的 Recall@200，突显了该模型无需直接比较每个查询-文档对就能从庞大集合中检索相关文档的卓越能力。</li>\n<li><strong>实际应用的实用性</strong>：实验结果突出了 ColBERT 在实际场景中的实用性。其索引吞吐量和内存效率使其能够在几小时内索引像 MS MARCO 这样的大型文档集合，同时保持高效性和可管理的空间占用。这些特性突显了 ColBERT 适合部署在性能和计算效率都至关重要的生产环境中。</li>\n<li><strong>文档集合规模的可扩展性</strong>：也许最令人惊讶的结论是 ColBERT 在处理大规模文档集合时的可扩展性和效率。该架构允许预计算文档嵌入并利用高效的批处理进行查询-文档交互，使系统能够随文档集合规模有效扩展。考虑到有效文档检索所需的复杂性和理解深度，这种可扩展性是反直觉的，展示了 ColBERT 在平衡计算效率和检索效果方面的创新方法。</li>\n</ol>\n<h2 id=\"using-jina-colbert-v1-en-a-8192-length-colbertv2-model\">使用 <code>jina-colbert-v1-en</code>：一个支持 8192 长度的 ColBERTv2 模型</h2>\n<p>Jina-ColBERT 旨在实现快速且准确的检索，支持<a href=\"https://jina.ai/news/jina-ai-launches-worlds-first-open-source-8k-text-embedding-rivaling-openai/?ref=jina-ai-gmbh.ghost.io\">长达 8192 的上下文长度，利用了 JinaBERT 的进步</a>，其架构增强使其能够处理更长的序列。</p>\n<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">严格来说，Jina-ColBERT 支持 8190 个 token 长度。请注意在 ColBERT 文档编码器中，每个文档都在开头添加了 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">[D],[CLS]</code> 填充。</div></div>\n<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/jina-colbert-v1-en · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://huggingface.co/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://cdn-thumbnails.huggingface.co/social-thumbnails/models/jinaai/jina-colbert-v1-en.png\" alt=\"\"></div></a></figure>\n<h3 id=\"jinas-improvement-over-original-colbert\">Jina 对原始 ColBERT 的改进</h3>\n<p>Jina-ColBERT 的主要进步在于其骨干网络 <code>jina-bert-v2-base-en</code>，它能够处理显著更长的上下文（最多 8192 个 token），相比使用 <code>bert-base-uncased</code> 的原始 ColBERT 有了很大提升。这种能力对于处理包含大量内容的文档至关重要，可以提供更详细和更具上下文的搜索结果。</p>\n<h3 id=\"jina-colbert-v1-en-performance-comparison-vs-colbertv2\"><code>jina-colbert-v1-en</code> 与 ColBERTv2 的性能比较</h3>\n<p>我们在 BEIR 数据集和偏好长上下文的新 LoCo 基准上评估了 <code>jina-colbert-v1-en</code>，将其与原始 ColBERTv2 实现和非交互式的<code>jina-embeddings-v2-base-en</code> 模型。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>ColBERTv2</th>\n<th>jina-colbert-v1-en</th>\n<th>jina-embeddings-v2-base-en</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arguana</td>\n<td>46.5</td>\n<td><strong>49.4</strong></td>\n<td>44.0</td>\n</tr>\n<tr>\n<td>Climate-Fever</td>\n<td>18.1</td>\n<td>19.6</td>\n<td><strong>23.5</strong></td>\n</tr>\n<tr>\n<td>DBPedia</td>\n<td><strong>45.2</strong></td>\n<td>41.3</td>\n<td>35.1</td>\n</tr>\n<tr>\n<td>FEVER</td>\n<td>78.8</td>\n<td><strong>79.5</strong></td>\n<td>72.3</td>\n</tr>\n<tr>\n<td>FiQA</td>\n<td>35.4</td>\n<td>36.8</td>\n<td><strong>41.6</strong></td>\n</tr>\n<tr>\n<td>HotpotQA</td>\n<td><strong>67.5</strong></td>\n<td>65.9</td>\n<td>61.4</td>\n</tr>\n<tr>\n<td>NFCorpus</td>\n<td>33.7</td>\n<td><strong>33.8</strong></td>\n<td>32.5</td>\n</tr>\n<tr>\n<td>NQ</td>\n<td>56.1</td>\n<td>54.9</td>\n<td><strong>60.4</strong></td>\n</tr>\n<tr>\n<td>Quora</td>\n<td>85.5</td>\n<td>82.3</td>\n<td><strong>88.2</strong></td>\n</tr>\n<tr>\n<td>SCIDOCS</td>\n<td>15.4</td>\n<td>16.9</td>\n<td><strong>19.9</strong></td>\n</tr>\n<tr>\n<td>SciFact</td>\n<td>68.9</td>\n<td><strong>70.1</strong></td>\n<td>66.7</td>\n</tr>\n<tr>\n<td>TREC-COVID</td>\n<td>72.6</td>\n<td><strong>75.0</strong></td>\n<td>65.9</td>\n</tr>\n<tr>\n<td>Webis-touch2020</td>\n<td>26.0</td>\n<td><strong>27.0</strong></td>\n<td>26.2</td>\n</tr>\n<tr>\n<td>LoCo</td>\n<td>74.3</td>\n<td>83.7</td>\n<td><strong>85.4</strong></td>\n</tr>\n<tr>\n<td>Average</td>\n<td>51.7</td>\n<td><strong>52.6</strong></td>\n<td>51.6</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>这个表格展示了 <code>jina-colbert-v1-en</code> 的出色性能，特别是在需要更长上下文长度的场景中，相比原始的 ColBERTv2。注意，<code>jina-embeddings-v2-base-en</code> <a href=\"https://arxiv.org/abs/2310.19923?ref=jina-ai-gmbh.ghost.io\">使用了更多的训练数据</a>，而 <code>jina-colbert-v1-en</code> 仅使用 MSMARCO，这可能解释了为什么 <code>jina-embeddings-v2-base-en</code> 在某些任务上表现良好。</p><h3 id=\"example-usage-of-jina-colbert-v1-en\"><code>jina-colbert-v1-en</code> 的使用示例</h3><p>这段代码展示了使用 Jina-ColBERT 的索引过程，展示了其对长文档的支持。</p><pre><code class=\"language-python\">from colbert import Indexer\nfrom colbert.infra import Run, RunConfig, ColBERTConfig\n\nn_gpu: int = 1  # Set your number of available GPUs\nexperiment: str = \"\"  # Name of the folder where the logs and created indices will be stored\nindex_name: str = \"\"  # The name of your index, i.e. the name of your vector database\n\nif __name__ == \"__main__\":\n    with Run().context(RunConfig(nranks=n_gpu, experiment=experiment)):\n        config = ColBERTConfig(\n          doc_maxlen=8192  # Our model supports 8k context length for indexing long documents\n        )\n        indexer = Indexer(\n          checkpoint=\"jinaai/jina-colbert-v1-en\",\n          config=config,\n        )\n        documents = [\n          \"ColBERT is an efficient and effective passage retrieval model.\",\n          \"Jina-ColBERT is a ColBERT-style model but based on JinaBERT so it can support both 8k context length.\",\n          \"JinaBERT is a BERT architecture that supports the symmetric bidirectional variant of ALiBi to allow longer sequence length.\",\n          \"Jina-ColBERT model is trained on MSMARCO passage ranking dataset, following a very similar training procedure with ColBERTv2.\",\n          \"Jina-ColBERT achieves the competitive retrieval performance with ColBERTv2.\",\n          \"Jina is an easier way to build neural search systems.\",\n          \"You can use Jina-ColBERT to build neural search systems with ease.\",\n          # Add more documents here to ensure the clustering work correctly\n        ]\n        indexer.index(name=index_name, collection=documents)\n</code></pre><h3 id=\"use-jina-colbert-v1-en-in-ragatouille\">在 RAGatouille 中使用 <code>jina-colbert-v1-en</code></h3><p>RAGatouille 是一个新的 Python 库，它简化了在 RAG 流程中使用高级检索方法的过程。它的设计注重模块化和易于集成，使用户能够无缝使用最先进的研究成果。RAGatouille 的主要目标是简化在 RAG 流程中应用 ColBERT 等复杂模型的过程，让开发者无需深入了解底层研究就能使用这些方法。感谢 <a href=\"https://twitter.com/bclavie?ref=jina-ai-gmbh.ghost.io\">Benjamin Clavié</a>，现在你可以轻松使用 <code>jina-colbert-v1-en</code>：</p><pre><code class=\"language-python\">from ragatouille import RAGPretrainedModel\n\n# Get your model & collection of big documents ready\nRAG = RAGPretrainedModel.from_pretrained(\"jinaai/jina-colbert-v1-en\")\nmy_documents = [\n    \"very long document1\",\n    \"very long document2\",\n    # ... more documents\n]\n\n# And create an index with them at full length!\nRAG.index(collection=my_documents,\n          index_name=\"the_biggest_index\",\n          max_document_length=8190,)\n\n# or encode them in-memory with no truncation, up to your model's max length\nRAG.encode(my_documents)\n</code></pre><p>要了解更多关于 Jina-ColBERT 的详细信息，你可以访问其 <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">Hugging Face 页面</a>。</p><h2 id=\"conclusion\">结论</h2><p>ColBERT 在信息检索领域代表了一个重要的进步。通过 Jina-ColBERT 支持更长的上下文长度，同时保持与 ColBERT 后期交互方法的兼容性，它为希望实现最先进搜索功能的开发者提供了一个强大的选择。</p><p>结合 RAGatouille 库，它简化了将复杂检索模型集成到 RAG 流程中的过程，开发者现在可以轻松利用高级检索的能力，简化他们的工作流程并增强他们的应用。Jina-ColBERT 和 RAGatouille 的协同展示了在使高级 AI 搜索模型变得易于访问和高效使用方面的显著进展。</p>",
  "comment_id": "65d3a2134a32310001f5b71b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/02/Untitled-design--28-.png",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-02-19T19:46:43.000+01:00",
  "updated_at": "2024-08-30T23:11:22.000+02:00",
  "published_at": "2024-02-20T02:19:04.000+01:00",
  "custom_excerpt": "Jina AI's ColBERT on Hugging Face has set Twitter abuzz, bringing a fresh perspective to search with its 8192-token capability. This article unpacks the nuances of ColBERT and ColBERTv2, showcasing their innovative designs and why their late interaction feature is a game-changer for search.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/what-is-colbert-and-late-interaction-and-why-they-matter-in-search/",
  "excerpt": "Jina AI 在 Hugging Face 上发布的 ColBERT 在 Twitter 上引起热议，凭借其 8192 token 的处理能力为搜索带来了全新视角。本文深入解析 ColBERT 和 ColBERTv2 的细节特性，展示了它们的创新设计，以及为什么它们的后期交互特性能够彻底改变搜索领域。",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Neon theater or concert hall marquee letters lit up at night with city lights and faint \"Adobe Sto\" visible.",
  "feature_image_caption": null
}