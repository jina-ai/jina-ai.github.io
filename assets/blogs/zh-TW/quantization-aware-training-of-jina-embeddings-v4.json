{
  "slug": "quantization-aware-training-of-jina-embeddings-v4",
  "id": "685d4b76f1bef30001fc5449",
  "uuid": "6b06b483-2d13-4f1d-8d9d-147fa6dffe4b",
  "title": "jina-embeddings-v4 的量化感知訓練",
  "html": "<p>量化是一種廣泛用於解決人工智慧中擴展問題的技術。這個名稱聽起來很複雜，但它只是將數字四捨五入，使其佔用更少的空間。這意味著更小的向量模型 (Embeddings) 佔用更少的記憶體和儲存空間，以及更快的資訊檢索，因為比較向量所需的時間更少。量化是一種純粹的數值技術，不關心您的模型處理什麼樣的資料或您有哪些用例，因此它可以帶來改進，而無需大量的昂貴的領域知識。</p><p>人們可能會預期，量化涉及權衡，沒有什麼是免費的——我們必須犧牲一些精度。在本文中，我們將向您展示一種透過<em>量化感知訓練</em> (quantization-aware training, QAT) 使其<strong>無損</strong>的方法。此技術用於 <code>jina-embeddings-v4</code> 中，以提供空間關鍵應用中所需的更小的向量模型 (Embeddings)。</p><h2 id=\"overview-of-quantization-techniques\">量化技術概述</h2><p>模型量化通常意味著以下四件事之一：</p><ul><li>訓練後量化（Post-training quantization, <strong>PTQ</strong>）</li><li>訓練用於量化向量模型 (Embeddings) 輸出（Output QAT）</li><li>訓練用於完全量化模型（Full QAT）</li><li>從現有的未量化模型中提煉出一個新的量化模型</li></ul><p>訓練後量化（<strong>PTQ</strong>）接受經過訓練的向量模型 (Embedding) 模型，並且不以任何方式修改它。這只是丟棄模型產生的浮點值的最小有效位數的問題。我們只是將數字四捨五入，有時將它們縮放到一個範圍。</p><p><strong>Output QAT</strong> 意味著微調向量模型 (Embedding) 模型，以產生最佳的降低精度向量。這意味著修改模型，但它不會改變模型權重的精度，因此不會減小其大小。只有輸出向量大小減小。</p><p><strong>Full QAT</strong> 從一個完全訓練好的、全精度模型開始，降低模型權重的精度，然後微調此修改後的模型的性能。這會產生一個顯著更小的模型以及更小的向量模型 (Embeddings)，但需要進行一些微調。</p><p><strong>Distillation</strong> 是訓練一個新模型以匹配現有模型性能的過程。這意味著創建一個從頭開始設計為量化的新模型，然後使用現有模型生成所需的盡可能多的訓練資料來訓練它，直到它的性能盡可能接近現有模型。</p><p>下表總結了這四種方法的好處：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>更緊湊的向量模型 (Embeddings)？</th>\n<th>需要訓練？</th>\n<th>模型壓縮？</th>\n<th>更快的推論？</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PTQ</strong></td>\n<td><strong>✓</strong></td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Output QAT</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Full QAT</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td><strong>Distillation</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>（到一個更小的模型）</em></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>所有四種方法都產生更緊湊的向量模型 (Embeddings)，但除了 PTQ 之外，所有方法都需要一些額外的訓練，而只有 Full QAT 和 Distillation 產生新的、更快的模型。Full QAT 和 Distillation 的實施成本要高得多，因為它們需要比 Output QAT 更多的訓練。</p><p>在本文中，我們只會研究 PTQ 和 Output QAT，它們不會改變向量模型 (Embedding) 模型的大小或速度。</p><h2 id=\"experimental-setup\">實驗設定</h2><p>對於這些實驗，我們的基準模型是帶有檢索適配器的 <code>jina-embeddings-v4</code>，它產生 2048 維的 32 位精度浮點 (FP32) 向量。因此，每個向量模型 (Embedding) 的大小為 8196 位元組，即 8kB。</p><p>我們使用來自 <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR 基準測試</a>套件的查詢-文件檢索基準測試任務研究了幾種實驗條件。檢索過程使用向量之間的餘弦相似度來查找和排名與查詢最匹配的文件。</p><ul><li><strong>基準</strong> — <code>jina-embeddings-v4</code> 向量模型 (Embedding) 向量在沒有任何量化的情況下的性能。這些實驗都使用了該模型的 beta 版本，並且發布的性能略好。</li><li><strong>PTQ</strong> — 我們將輸出向量量化為二進制向量，而沒有更改模型。</li><li><strong>Output QAT</strong> — 我們量化了輸出向量，並對檢索適配器進行了微調，以提高其在量化條件下的性能。</li></ul><h3 id=\"quantization-levels\">量化級別</h3><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"816\" height=\"636\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image.png 816w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">圖 1：後量化向量模型 (Embedding) 大小比較。</span></figcaption></figure><p>我們實驗了四種不同的量化級別。</p><ul><li><strong>8 位元整數</strong> — FP32 值縮減為 -128 到 127 範圍內的整數，將向量模型 (Embeddings) 縮小 4 倍至 <strong>2048 位元組</strong>。</li><li><strong>4 位元整數</strong> — 與 4 位元整數相同，但我們映射到 -8 到 7 的範圍，將向量大小減少 8 倍，至 <strong>1024 位元組</strong>。</li><li><strong>三元量化</strong> — 所有值都映射到三個值之一：-1、0、1。最佳儲存時，這會將每個維度減少到 1.6 位元，將向量模型 (Embedding) 向量的大小大致減少 40 倍，至約 <strong>230 位元組</strong>。</li><li><strong>二進制量化</strong> — 我們使用 <code>torch.sign</code> 資料類型將 FP32 標量值轉換為一位元，該資料類型僅提供兩個值，需要一位元來儲存。這將 2048 維向量模型 (Embedding) 向量從 8192 位元組減少到 <strong>128 位元組</strong>，減少了 64 倍。</li></ul><h3 id=\"scaling\">縮放</h3><p>對於二進制量化，量化非常簡單：如果向量值大於 0 或為正數，則映射到 1。否則，它映射到 -1。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-1.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1159\" height=\"221\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-1.png 1159w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">圖 2：二進制量化。所有負值都變成 -1，所有其他值都變成 1。</span></figcaption></figure><p>對於其他量化情境，我們將值歸一化到一個範圍，然後四捨五入到量化級別允許的最接近的值。向量模型 (Embedding) 向量由 -∞ 和 +∞ 之間的比例數字組成（或者，在實踐中，是非常大的正數和負數）。我們使用兩個數字 $max$ 和 $min$ 來縮放用於量化的值。</p><p>對於三元量化，我們採用每個向量分量 $v$ 並按如下方式轉換它：</p><ul><li>如果 $v$ ≥ $max$，則 $v$ 變為 1。</li><li>如果 $v$ ≤ $min$，則 $v$ 變為 -1。</li><li>如果 $min$ &lt; $v$ &lt; $max$，則 $v$ 變為 0。</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-2.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1030\" height=\"220\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-2.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-2.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-2.png 1030w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">圖 3：三元量化。定義一個區間，並且該區間內的值變為 0。所有較低的值都變成 -1，所有較高的值都變成 1。</span></figcaption></figure><p>對於 4 位元整數：</p><ul><li>如果 $v$ ≥ $max$，則 $v$ 變為 7。</li><li>如果 $v$ ≤ $min$，則 $v$ 變為 -8。</li><li>如果 $min$ &lt; $v$ &lt; $max$，則 $v$ 變為 $16*(v - min)/(max - min) - 8$，然後四捨五入到最接近的整數。這將值縮放到範圍 $[-8,7]$。</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-3.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1023\" height=\"221\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-3.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-3.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-3.png 1023w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">圖 4：4 位元量化。定義一個區間，並且所有值都歸一化到定義的範圍 [-8,7]。</span></figcaption></figure><p></p><p>對於 8 位元整數：</p><ul><li>如果 $v$ ≥ $max$，則 $v$ 變為 127。</li><li>如果 $v$ ≤ $min$，則 $v$ 變為 -128。</li><li>如果 $min$ &lt; $v$ &lt; $max$，則 $v$ 變為 $256*(v - min)/(max - min) - 128$，四捨五入到最接近的整數。這將值縮放到範圍 $[-128,127]$。</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-4.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1023\" height=\"219\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-4.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-4.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-4.png 1023w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">圖 5：8 位元量化。定義一個區間，並且所有值都歸一化到定義的範圍 [-128,127]。</span></figcaption></figure><p>為了計算 $max$ 和 $min$，我們使用了兩種方法：</p><ul><li><strong>最小值/最大值</strong> — 我們分批處理我們的資料，並且對於每一批，我們識別出最高和最低的向量分量，將 $max$ 設置為最高，將 $min$ 設置為最低。</li><li><strong>批次上的滾動平均</strong> — 對於每個批次，我們計算向量分量的平均值和標準差。在處理所有批次時，我們保持平均值和標準差的移動平均值。如果 $avg$ 是批次平均值的當前移動平均值，並且 $std$ 是標準差的當前移動平均值，則對於每個批次：</li></ul><p>$max = avg + std$<br>$min = avg - std$</p><h3 id=\"qat-fine-tuning\">QAT 微調</h3><p>對於 PTQ 實驗，我們按原樣使用模型，並使用上述方法量化它產生的向量模型 (Embeddings)。</p><p>對於 Output QAT，我們使用<em>直接估計</em>微調模型。這意味著我們反轉量化過程，將值恢復到全精度，然後計算損失（即誤差），然後我們使用該損失指標來微調模型。</p><p> 在每個案例中，我們都針對 10,000 個步驟進行了微調，每 500 個步驟儲存一個檢查點。 然後，我們保留了在 <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a> 基準測試中得分最高的檢查點。</p>\n<h3 id=\"asymmetric-quantization\">非對稱量化 (Asymmetric Quantization)</h3>\n<p> 訓練後量化 (PTQ) 和輸出感知量化訓練 (Output QAT) 降低了向量模型 (embedding vectors) 的大小，但並未減少模型大小或推論速度； 所有的節省都在儲存的文件向量模型 (document embeddings) 的大小和檢索速度上。</p>\n<p> 因此，我們測試了在檢索時量化查詢向量 (query vectors) 以及保持它們不量化的兩種情況，因為無論哪種方式，它都不會改變儲存的向量模型 (embedding vectors) 的大小。</p>\n<h2 id=\"results\">結果</h2>\n<p> 我們總共測試了九種情況，總結在下表中：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>條件名稱</th>\n<th>微調</th>\n<th>量化等級</th>\n<th>縮放策略</th>\n<th>量化查詢</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基準 (Baseline)</td>\n<td>❌</td>\n<td>不適用 (n/a)</td>\n<td>不適用 (n/a)</td>\n<td>不適用 (n/a)</td>\n</tr>\n<tr>\n<td>PTQ Both</td>\n<td>❌</td>\n<td>二元 (Binary)</td>\n<td>不適用 (n/a)</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>PTQ Docs Only</td>\n<td>❌</td>\n<td>二元 (Binary)</td>\n<td>不適用 (n/a)</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>QAT Binary</td>\n<td><strong>✓</strong></td>\n<td>二元 (Binary)</td>\n<td>不適用 (n/a)</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT Binary Docs Only</td>\n<td><strong>✓</strong></td>\n<td>二元 (Binary)</td>\n<td>不適用 (n/a)</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>QAT Trinary</td>\n<td><strong>✓</strong></td>\n<td>三元 (Trinary)</td>\n<td>滾動平均 (Rolling Average)</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 4-bits</td>\n<td><strong>✓</strong></td>\n<td>4 位元 (4-bits)</td>\n<td>滾動平均 (Rolling Average)</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 8-bits</td>\n<td><strong>✓</strong></td>\n<td>8 位元 (8-bits)</td>\n<td>滾動平均 (Rolling Average)</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 8-bits Min/Max</td>\n<td><strong>✓</strong></td>\n<td>8 位元 (8-bits)</td>\n<td>最小值/最大值 (Min/Max)</td>\n<td><strong>✓</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p><em>表 2：實驗條件</em></p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>條件名稱</th>\n<th>平均分數</th>\n<th>與基準的差異</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基準 (Baseline)</td>\n<td>60.10</td>\n<td>不適用 (n/a)</td>\n</tr>\n<tr>\n<td>PTQ Binary</td>\n<td>58.33</td>\n<td>-1.78</td>\n</tr>\n<tr>\n<td>PTQ Binary Docs Only</td>\n<td>59.08</td>\n<td>-1.02</td>\n</tr>\n<tr>\n<td>QAT Binary</td>\n<td>59.22</td>\n<td>-0.89</td>\n</tr>\n<tr>\n<td>QAT Binary Docs Only</td>\n<td>60.81</td>\n<td>+0.70</td>\n</tr>\n<tr>\n<td>QAT Trinary</td>\n<td>59.49</td>\n<td>-0.62</td>\n</tr>\n<tr>\n<td>QAT 4-bits</td>\n<td>61.73</td>\n<td>+1.62</td>\n</tr>\n<tr>\n<td>QAT 8-bits</td>\n<td>61.67</td>\n<td>+1.56</td>\n</tr>\n<tr>\n<td>QAT 8-bits Min/Max</td>\n<td>61.29</td>\n<td>+1.19</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p><em>表 3：在十二個 NanoBEIR 基準測試中，每個條件的平均分數（以正確百分比表示）。</em></p>\n<p> 從上表可以看出，針對量化進行微調可提高分數。 <strong>PTQ Binary</strong> 和 <strong>QAT Binary</strong> 條件之間的唯一區別是微調，並且分數差異顯著。 類似地，我們看到 <strong>PTQ Binary Docs Only</strong> 和 <strong>QAT Binary Docs Only</strong> 條件之間的分數提高了近 2%，它們僅因相同的微調而區分。</p>\n<p> 毫不奇怪地，我們也看到，量化程度越低，分數通常會提高，4 位元量化的得分高於三元量化，而三元量化又優於二元量化。 然而，進一步提高到 8 位元似乎沒有改善任何東西。</p>\n<p> 我們僅在二元案例中測試了保持查詢不量化的情況，但這似乎可以提高效能。</p>\n<p> 最後，我們的測試表明，滾動平均縮放方法優於簡單的最小值/最大值方法。</p>\n<h2 id=\"conclusion\">結論</h2>\n<p> 量化對於向量模型 (embedding models) 具有一些重要的操作優勢，透過顯著減小向量模型 (embedding vectors) 的大小並加速資訊檢索。 雖然簡單的訓練後量化 (PTQ) 在記憶體和儲存方面提供了直接的好處，但我們的實驗表明，感知量化訓練 (QAT) 顯著減輕了不可避免的精度損失。 微調始終產生更好的分數。</p>\n<p> 量化程度直接影響效能，這也是您對基於降低數值精度的方法的期望。 較不激進的量化（例如，4 位元）通常優於更激進的方法（例如，二元），但令人驚訝的是，8 位元和 4 位元量化之間的效能沒有顯著差異。 看來，在達到某個不精確的閾值之前，量化程度的大小之間幾乎沒有差異。</p>\n<p> 縮放策略也很重要，與固定的最小值/最大值方法相比，滾動平均方法顯示出更好的結果。 使用相對於資料的縮放值似乎效果更好，值得進一步探索。</p>\n<p> 量化可以讓您以更少的成本從向量模型 (embedding models) 中獲得更多。 儘管本文未探討所有量化選項，但它探討了兩種易於訪問的選項，並且它們具有實際的好處。 我們正在努力完善和改進量化策略，以便我們可以進一步降低使用者的成本，並期望在不久的將來發布對 <code>jina-embeddings-v4</code> 的二元支援。</p>",
  "comment_id": "685d4b76f1bef30001fc5449",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/06/Heading---2025-06-30T114820.483.webp",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-06-26T15:30:30.000+02:00",
  "updated_at": "2025-06-30T21:14:36.000+02:00",
  "published_at": "2025-06-30T21:14:36.000+02:00",
  "custom_excerpt": "Quantization gives smaller embeddings. We show you fine-tuned quantization gives you even lossless embeddings.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "64ae64a4733bc60001949ca4",
      "name": "Andrei Ungureanu",
      "slug": "andrei",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2023/07/Me.jpg",
      "cover_image": null,
      "bio": "Software / AI Engineer, with a passion for content creation.",
      "website": null,
      "location": "Beijing, China",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/andrei/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/quantization-aware-training-of-jina-embeddings-v4/",
  "excerpt": "量化可以產生更小的向量模型 (Embeddings)。我們將向您展示經過微調的量化，甚至可以產生無損的向量模型。",
  "reading_time": 8,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}