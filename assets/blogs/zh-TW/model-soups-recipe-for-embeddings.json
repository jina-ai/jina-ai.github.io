{
  "slug": "model-soups-recipe-for-embeddings",
  "id": "681b63a077c406000104263b",
  "uuid": "e3fc45b3-6cf9-4a0b-863f-bc4a8417c436",
  "title": "Model Soup 的 Embedding 食譜",
  "html": "<p>在這些艱難的時刻，沒有什麼比一碗暖呼呼的湯更棒了。</p><p>蔬菜湯是經典的義大利湯品之一：濃稠、豐盛、美味，結合了豆類、耐煮的蔬菜以及米飯或麵食。它的味道是將多種食材組合在一起的產物。這有點像東歐的羅宋湯、美國的砂鍋菜，或是太平洋亞洲地區的家常炒菜，都是將現成且便宜的食材組合在一起，變成一道受人喜愛的菜餚。</p><p>根據一系列論文（從 <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a> 開始），我們可以將幾乎相同的食譜用於神經網路模型。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://proceedings.mlr.press/v162/wortsman22a.html\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time</div><div class=\"kg-bookmark-description\">The conventional recipe for maximizing model accuracy is to (1) train multiple models with various hyperparameters and (2) pick the individual model which performs best on a held-out validation set…</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-pmlr.ico\" alt=\"\"><span class=\"kg-bookmark-author\">PMLR</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://proceedings.mlr.press/v162/assets/images/logo-pmlr.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>「模型湯」（唉，不是「模型砂鍋菜」或「模型炒菜」）是一類模型集成技術，旨在減輕優化訓練數據和模型超參數的成本。在訓練神經網路時，您通常會嘗試不同的數據和超參數值，並多次訓練，以尋找性能最佳的結果。訓練在計算上非常昂貴，並且成本會迅速增加。</p><p>相反，「模型湯」涉及使用不同的超參數和訓練數據選擇來訓練多個模型——與您通常會做的一樣——然後將它們組合起來。結果是比單個最佳模型性能更高、更穩健。它並不能節省成本，因為您仍然需要訓練多個模型，但您可以以相同的價格獲得更好的結果。</p><p>模型湯方法已經證明對文本圖像多模態嵌入模型 <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">(Wortsman et al. 2022)</a> 和生成式大型語言模型很有用。（<a href=\"https://doi.org/10.1038/s42256-024-00975-8\">Takuya et al. 2025</a>）在 Jina AI，我們已經開始使用這種技術來訓練我們自己的模型，<code>jina-embeddings-v3</code> 和 <code>reader-lm-v2</code> 都整合了模型湯。</p><p>在本文中，我們將研究模型湯，並展示我們使用它們的一些工作成果。具體來說：</p><ol><li>我們可以使用模型湯，通過合併訓練過程中不同時間點的模型來提高性能嗎？</li><li>我們可以合併使用不同數據集和針對不同任務訓練的模型，從而獲得比訓練單個模型更好的性能和更高的訓練效率嗎？</li></ol><p>這具有重要的潛在優勢：</p><ul><li>模型湯可以具有更好和更穩健的性能。</li><li>多語言嵌入模型通常會因訓練數據量不均而導致偏差和性能下降。如果能夠單獨地針對每個任務或數據集訓練出我們能做到的最佳模型，然後將它們平等地組合起來，那將是一大福音。</li><li>我們也許可以通過以模組化的方式更改我們的模型，一次更新一個組件模型，然後將其與其他模型重新合併，從而更好地進行持續學習和模型更新。</li></ul><h2 id=\"how-does-it-work\">它是如何運作的？</h2><p>合併多個模型的輸出是統計決策理論中的一種古老技術。例如，在天氣預報中，常見的做法是創建多個模型（通常由具有不同假設的不同人員創建），然後使用各種機制來平均他們的預測。如果每個模型的錯誤是隨機分佈的，那麼平均模型將會得出錯誤更少的答案。</p><p>例如，如果您有三個不同的模型，它們輸出二元「是」或「否」，並且每個模型在 10% 的時間內是錯誤的，那麼三個模型中有兩個錯誤的機率只有 2.8%。五個模型，使用多數決策標準，錯誤的機率僅為 0.856%。</p><p>平均模型的工作原理相同，但不是組合不同模型的輸出，而是組合模型本身。</p><p>使用的方法是<em>隨機權重平均</em> (<a href=\"https://auai.org/uai2018/proceedings/papers/313.pdf\">Izmailov et al. 2018</a>) 的延伸，它依賴於對神經網路損失情況的深入了解，以表明在常見情況下，簡單的權重平均可以提高模型的泛化性能。</p><p>平均模型的實際機制非常簡單：您只需平均多個模型的權重即可。</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/05/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"380\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/05/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/05/image.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2025/05/image.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2025/05/image.png 2400w\" sizes=\"(min-width: 1200px) 1200px\"><figcaption><span style=\"white-space: pre-wrap;\">如何合併模型以製作模型湯。這個例子非常小而簡單，但仍然顯示了該過程：將權重相加，然後除以要合併的模型數量。</span></figcaption></figure><p>如果這看起來太容易了，那麼重要的是要注意，以這種方式合併模型存在局限性。您不能只是合併任何兩個神經網路的權重，並期望它能正常工作。</p><p>模型平均僅適用於非常相似的模型，即權重一開始彼此差異不大的模型。確保這一點的方法是預先訓練一個模型，然後通過使用不同的超參數或不同的數據對其進行微調來創建該模型的多個變體。這些模型通常足夠相似以進行平均。</p><p>更專業地說，預訓練通常會產生一個權重接近損失盆地底部的模型，而微調不容易導致逃脫該損失盆地。如果要合併的所有模型的權重都在同一個損失盆地中，那麼它們的權重將相當接近，並且平均它們很可能會起作用。這並不能保證，但從經驗上來看，它似乎經常是真的，因此很有用。</p><h2 id=\"experimental-setup\">實驗設置</h2><p><strong>基礎模型</strong>：對於此處描述的實驗，我們使用了 <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\">FacebookAI 的 <code>xlm-roberta-base</code></a>（<a href=\"https://aclanthology.org/2020.acl-main.747/\">Conneau et al. 2020</a>）作為我們的預訓練基礎模型。該模型具有 2.8 億個參數，並且已經在包含大約 100 種語言文本的 2.5TB Common Crawl 數據上進行了預訓練。</p><p>在進行實驗之前，我們在我們精心策劃的句子對訓練集上對 <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code></a> 進行了微調，以進行嵌入訓練。</p><p><strong>訓練數據</strong>：Jina AI 維護用於訓練的自定義策劃數據集。對於第一個實驗，我們使用了專門為六種語言（英語、阿拉伯語、德語、西班牙語、日語和中文）中的對比訓練而策劃的句子三元組。對於第二個實驗，我們使用了英語中特定任務的訓練數據集。</p><p><strong>評估</strong>：我們使用了 <a href=\"https://github.com/embeddings-benchmark/mteb/tree/main/docs/mmteb\">MMTEB 基準集</a>（<a href=\"https://arxiv.org/abs/2502.13595\">Enevoldsen et al. 2025</a>）和 <a href=\"https://project-miracl.github.io/\">MIRACL 基準</a>（<a href=\"https://direct.mit.edu/tacl/article/doi/10.1162/tacl_a_00595/117438/MIRACL-A-Multilingual-Retrieval-Dataset-Covering\">Zhang et al. 2023</a>）的相關部分，以評估我們訓練和合併產生的模型。</p><h3 id=\"experiment-1-single-run-averaging\">實驗 1：單次運行平均</h3><p>對於此實驗，我們使用了所有六種語言的對比句子三元組，混合在一起，總共進行了 6,000 個訓練步驟，批次大小為 1,024 個項目。每 2,000 步，我們保存模型狀態以進行平均，從而產生 3 個模型，每個模型都反映了訓練過程中的不同時間點。</p><p>我們平均了三個模型以產生最終模型。然後，我們針對 MMTEB-STS 和 MIRACL 基準集測試了合併後的模型和三個保存的檢查點。</p><p>我們的結果總結在下表中：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>MIRACL<br>(avg 6 languages)</th>\n<th>MMTEB-STS English<br>(avg 8 benchmarks)</th>\n<th>MMTEB-STS Multilingual<br>(avg 6 benchmarks)</th>\n<th>Average of 20 benchmarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>No triplet training</td>\n<td>0.3163</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.6276</td>\n</tr>\n<tr>\n<td>Step 2000</td>\n<td>0.4631</td>\n<td><strong>0.7924</strong></td>\n<td>0.7561</td>\n<td>0.6813</td>\n</tr>\n<tr>\n<td>Step 4000</td>\n<td>0.4639</td>\n<td>0.7902</td>\n<td><strong>0.7583</strong></td>\n<td>0.6812</td>\n</tr>\n<tr>\n<td>Step 6000 (final)</td>\n<td><strong>0.4680</strong></td>\n<td>0.7891</td>\n<td>0.7575</td>\n<td>0.6818</td>\n</tr>\n<tr>\n<td>Merged model<br>(all 3 stored checkpoints)</td>\n<td>0.4669</td>\n<td>0.7910</td>\n<td>0.7579</td>\n<td><strong>0.6823</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>與儲存的檢查點中性能最佳者相比，使用先前的檢查點進行合併通常不會產生性能更好的模型，無論是在單個基準測試中還是在使用的三個基準測試組中的任何一個上。但是，它確實產生了所有基準測試平均在一起的最佳模型。</p><p>在單個基準測試中，合併模型與性能最佳的檢查點之間的差異在每種情況下都小於 0.01。這不僅適用於上表中的平均值，而且適用於每個單獨的測試。</p><p>這表明合併不同的訓練檢查點可以以非常小的性能成本產生更穩健的模型。</p><p>此外，通過合併不同的檢查點，我們可以有效地防止過度訓練。過度訓練最近已成為神經網路中的一個重要主題。（<a href=\"https://arxiv.org/abs/2503.19206v2\">Springer et al., 2025</a>）可以以一種方式訓練網路，使其在進一步微調後變得更難且性能更差。</p><p>由於在我們的實驗中，性能最佳的檢查點通常不是最後一個，因此我們可能在 6,000 個訓練步驟中過度訓練了我們的模型。合併後的模型非常接近匹配所有測試中最佳檢查點的性能，消除了過度訓練的缺陷。</p><h3 id=\"experiment-2-averaging-models-trained-for-different-tasks\">實驗 2：平均針對不同任務訓練的模型</h3><p>對於此實驗，我們訓練了三個模型，每個模型都用於不同的常見嵌入任務：</p><ul><li><strong>語義相似度</strong>：測量兩個文本之間在含義上的相對重疊或相似性，通常長度相當。</li><ul>\n<li><strong>基於文本查詢的文件檢索</strong>：尋找最能滿足查詢的文件。查詢通常比它們匹配的文件短得多。</li><li><strong>問答</strong>：尋找最能回答自然語言問題的文件。問題通常也比它們匹配的文本短得多。</li></ul><p>同時訓練所有三個任務的模型非常困難，因為目標非常不同，我們希望模型湯能改善這個過程。</p><p>根據先前的經驗，我們知道每個任務都需要不同數量的訓練週期。訓練總結如下：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>任務</th>\n<th>訓練步驟<br> (batchsize = 1,024)</th>\n<th>訓練資料集大小<br> (以項目計)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Question Answering (QA)</td>\n<td>2,000</td>\n<td>256,000</td>\n</tr>\n<tr>\n<td>Document Retrieval</td>\n<td>3,000</td>\n<td>384,000</td>\n</tr>\n<tr>\n<td>Semantic Similarity (STS)</td>\n<td>1,000</td>\n<td>128,000</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>這產生了三個模型，然後我們將它們合併為一個單一模型。我們針對 MMTEB 基準集中與這三個任務相關的部分測試了結果模型：<a href=\"https://project-miracl.github.io/\">MIRACL</a>、<a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a> 和 STSEval（MMTEB 的英文和多語部分）。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(平均 6 種語言)</th>\n<th>NanoBEIR<br>(平均 13 個基準)</th>\n<th>MMTEB-STS English<br>(平均 9 個基準)</th>\n<th>MMTEB-STS Multilingual<br>(平均 6 個基準)</th>\n<th>平均 34 個基準</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>No triplet training</td>\n<td>0.3163</td>\n<td>0.5089</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.5876</td>\n</tr>\n<tr>\n<td>QA training</td>\n<td><strong>0.4489</strong></td>\n<td>0.5332</td>\n<td>0.7843</td>\n<td>0.7535</td>\n<td>0.6237</td>\n</tr>\n<tr>\n<td>Retrieval training</td>\n<td>0.4272</td>\n<td><strong>0.5360</strong></td>\n<td>0.7766</td>\n<td>0.7340</td>\n<td>0.6154</td>\n</tr>\n<tr>\n<td>STS training</td>\n<td>0.1779</td>\n<td>0.4519</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.5508</td>\n</tr>\n<tr>\n<td>Merged model</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td><strong>0.6240</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>我們在這裡看到，特定任務訓練的模型在每個任務上都有最佳效能。MIRACL 主要是一個問答基準，即使它被稱為檢索基準，並且經過 QA 訓練的模型在它上面的表現優於所有其他模型，包括合併模型。NanoBEIR 是一個更傳統的資訊檢索基準集，我們看到經過檢索訓練的模型在它上面表現最佳。語義相似性 (STS) 模型在這些基準上的得分非常差，但在明確的 STS 任務上擊敗了其他模型。對於每個類別，合併模型的表現都比單一任務訓練模型差。</p><p>但再一次，如果我們對所有基準進行平均，合併模型的表現優於其他模型，儘管其分數僅比經過 QA 訓練的模型略有提高，並且在 STS 任務上的表現非常差。</p><p>我們還僅合併了 QA 和檢索模型，並在相同的基準上對結果模型進行了評分：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(平均 6 種語言)</th>\n<th>NanoBEIR<br>(平均 13 個基準)</th>\n<th>MMTEB-STS English<br>(平均 9 個基準)</th>\n<th>MMTEB-STS Multilingual<br>(平均 6 個基準)</th>\n<th>平均 34 個測試</th>\n<th>QA &amp; IR 平均<br>(19 個測試)</th>\n<th>STS 平均<br>(15 個測試)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Best task-trained model</td>\n<td>0.4489</td>\n<td>0.5360</td>\n<td><strong>0.7994</strong></td>\n<td><strong>0.7651</strong></td>\n<td>0.6237</td>\n<td>0.5066</td>\n<td><strong>0.7857</strong></td>\n</tr>\n<tr>\n<td>Merged model</td>\n<td>0.4246</td>\n<td>0.5309</td>\n<td>0.7981</td>\n<td>0.7640</td>\n<td>0.6240</td>\n<td>0.4973</td>\n<td>0.7845</td>\n</tr>\n<tr>\n<td>QA+Retrieval merged model</td>\n<td><strong>0.4610</strong></td>\n<td><strong>0.5404</strong></td>\n<td>0.7878</td>\n<td>0.7498</td>\n<td><strong>0.6288</strong></td>\n<td><strong>0.5153</strong></td>\n<td>0.7726</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>我們在這裡看到，雖然我們可以透過合併針對這兩個任務訓練的模型來提高問答和檢索的效能，但添加 STS 訓練的模型會降低所有類別中特定任務的效能。這表明語義相似性在某些重要方面不同於 QA 和檢索，並且經過 STS 訓練的模型不適合與其他兩個模型合併。</p><p>這可能是因為問答和檢索涉及將短文本（問題和查詢）與較長的文件進行匹配，而語義相似性涉及比較長度更相似的文件。</p><p><a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a> 描述了一種選擇性平均方法，他們稱之為「貪婪」合併。它涉及採用一個模型，通常是一組模型中效能最佳的模型，然後僅將那些個別提高效能的模型添加到其中。只有三個模型，因此在這次實驗中使用貪婪合併沒有多大意義。但是，我們可以想像一個有更多模型的情況，並使用類似這樣的技術作為確定任務之間相似程度的基礎。我們在這裡發現語義相似性與其他兩個不同。然後，我們可以評估一個模型何時可以執行許多任務，以及何時使用不同的模型更具成本效益。</p><h2 id=\"soup%E2%80%99s-on\">上湯了！</h2><p>模型湯將多樣性融入到比其各部分總和更大的東西中。這種方法的價值在於它能夠提供更高的穩定性、穩健性，並充當防止過度訓練的保障，而無需額外的訓練成本。我們的實驗表明，合併檢查點或特定任務的模型可以提高整體效能，即使有時會以特定任務的峰值為代價。</p><p>最後，模型湯提供了一種實用且非常簡單的方法來構建更具適應性的模型，儘管它有一些注意事項。它不是萬靈丹，並且僅適用於模型已經非常相似的情況。</p><p>正如他們在網路上所說的，<em>Your Mileage May Vary</em>。但是，找出模型湯是否可以在您訓練模型時提供幫助既便宜又容易。</p>",
  "comment_id": "681b63a077c406000104263b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/05/Heading--6-.jpg",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-05-07T15:44:00.000+02:00",
  "updated_at": "2025-05-07T19:56:02.000+02:00",
  "published_at": "2025-05-07T18:43:10.000+02:00",
  "custom_excerpt": "Boost robustness and performance with model soups: averaging weights. No extra cost, better results.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/model-soups-recipe-for-embeddings/",
  "excerpt": "使用模型湯（Model Soups）增強穩健性和效能：權重平均。 無需額外成本，效果更佳。",
  "reading_time": 9,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}