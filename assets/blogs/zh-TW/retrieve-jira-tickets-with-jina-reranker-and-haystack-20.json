{
  "slug": "retrieve-jira-tickets-with-jina-reranker-and-haystack-20",
  "id": "661543ffd6a1020001681e99",
  "uuid": "54231ab9-8258-4020-bd25-3d13ec8f5f04",
  "title": "使用 Jina Reranker 和 Haystack 2.0 檢索 Jira Tickets",
  "html": "<p>繼<a href=\"https://haystack.deepset.ai/blog/using-jina-embeddings-haystack?ref=jina-ai-gmbh.ghost.io\">將 Jina Embeddings 整合到 Deepset 的 Haystack 2.0</a> 和<a href=\"https://jina.ai/news/maximizing-search-relevancy-and-rag-accuracy-with-jina-reranker?ref=jina-ai-gmbh.ghost.io\">發布 Jina Reranker</a> 之後，我們很高興宣布 Jina Reranker 現在也可以通過 <a href=\"https://docs.haystack.deepset.ai/docs/jinaranker?ref=jina-ai-gmbh.ghost.io\">Jina Haystack 擴展</a>使用。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://haystack.deepset.ai/integrations/jina?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Jina AI | Haystack</div><div class=\"kg-bookmark-description\">Use the latest Jina AI embedding models</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://haystack.deepset.ai/favicon.ico\" alt=\"\"><span class=\"kg-bookmark-author\">Haystack</span><span class=\"kg-bookmark-publisher\">Authors deepset</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://haystack.deepset.ai/images/haystack-ogimage.png\" alt=\"\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">Maximize the search relevancy and RAG accuracy at ease</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a></figure><p><a href=\"https://haystack.deepset.ai/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Haystack</a> 是一個端到端的框架，可以協助您完成 GenAI 專案生命週期的每個階段。無論您想要執行文件搜索、檢索增強生成（RAG）、問答還是答案生成，Haystack 都可以將最先進的 embedding 模型和 LLM 整合到管道中，以構建端到端的 NLP 應用程式並解決您的使用案例。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://haystack.deepset.ai/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Haystack | Haystack</div><div class=\"kg-bookmark-description\">Haystack, the composable open-source AI framework</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://haystack.deepset.ai/favicon.ico\" alt=\"\"><span class=\"kg-bookmark-author\">Haystack</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://haystack.deepset.ai/images/haystack-ogimage.png\" alt=\"\"></div></a></figure><p>在這篇文章中，我們將展示如何使用它們來建立自己的 Jira 工單搜索引擎，以簡化您的操作並且不再浪費時間建立重複的問題。</p><p>要跟隨本教程，您需要一個 Jina Reranker API 金鑰。您可以從 <a href=\"https://jina.ai/reranker/?ref=jina-ai-gmbh.ghost.io\">Jina Reranker 網站</a>建立一個擁有一百萬個代幣免費試用額度的金鑰。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">您可以在 <a href=\"https://colab.research.google.com/github/jina-ai/workshops/blob/main/notebooks/embeddings/haystack/Haystack_Reranker.ipynb?ref=jina-ai-gmbh.ghost.io\">Colab</a> 上跟著操作或<a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/embeddings/haystack/Haystack_Reranker.ipynb?ref=jina-ai-gmbh.ghost.io\">下載 notebook</a>。</div></div><h2 id=\"retrieving-jira-support-tickets\">檢索 Jira 支援工單</h2><p>任何處理複雜專案的團隊都經歷過這種困擾：想要提交一個問題，但不知道是否已經有相同問題的工單存在。</p><p>在接下來的教程中，我們將向您展示如何使用 Jina Reranker 和 Haystack 管道輕鬆創建一個工具，該工具可以在建立新工單時提示可能的重複工單。</p><ul><li>通過輸入需要與所有現有工單進行核對的工單，管道將首先從數據庫中檢索所有相關問題。</li><li>然後它會從列表中移除初始工單（如果它已經存在於數據庫中）和任何子工單（即父 ID 對應於原始工單的工單）。</li><li>最終的選擇現在只包括可能涵蓋與原始工單相同主題但在數據庫中未通過其 ID 標記為相關的問題。這些工單會被重新排序以確保最大的相關性，並使您能夠識別數據庫中的重複條目。</li></ul><h3 id=\"getting-the-dataset\">獲取數據集</h3><p>為了實施我們的解決方案，我們選擇了 <a href=\"https://zookeeper.apache.org/?ref=jina-ai-gmbh.ghost.io\">Apache Zookeeper</a> 專案中所有\"進行中\"的 Jira 工單。這是一個用於協調分布式應用程序進程的開源服務。</p><p>我們已將工單放在一個 <a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/embeddings/haystack/tickets.json?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">JSON 文件</a>中以使其更方便使用。請<a href=\"https://raw.githubusercontent.com/jina-ai/workshops/main/notebooks/embeddings/haystack/tickets.json?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">下載該文件</a>到您的工作空間。</p><h3 id=\"set-up-the-prerequisites\">設置先決條件</h3><p>要安裝需求，請運行：</p><pre><code class=\"language-Bash\">pip install --q chromadb haystack-ai jina-haystack chroma-haystack\n</code></pre><p>要輸入 API 金鑰，將其設置為環境變數：</p><pre><code class=\"language-Python\">import os\nimport getpass\n\nos.environ[\"JINA_API_KEY\"] = getpass.getpass()\n</code></pre><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">如果您通過 notebook 運行此代碼，<code spellcheck=\"false\" style=\"white-space: pre-wrap;\">getpass.getpass()</code> 將提示您在相應的代碼塊下方輸入 API 金鑰。您可以在那裡輸入金鑰並按 Enter 繼續教程。如果您願意，也可以直接用 API 金鑰替換 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">getpass.getpass()</code>。</div></div><h3 id=\"build-the-indexing-pipeline\">建立索引管道</h3><p>索引管道將預處理工單，將它們轉換為向量，並進行存儲。我們將使用 <a href=\"https://docs.trychroma.com/getting-started?ref=jina-ai-gmbh.ghost.io\">Chroma DocumentStore</a> 作為我們的向量數據庫來存儲向量嵌入，通過 <a href=\"https://haystack.deepset.ai/integrations/chroma-documentstore?ref=jina-ai-gmbh.ghost.io\">Chroma Document Store Haystack 整合</a>。</p><pre><code class=\"language-Python\">from haystack_integrations.document_stores.chroma import ChromaDocumentStore\n\ndocument_store = ChromaDocumentStore()\n</code></pre><p>我們將首先定義我們的自定義數據預處理器，只考慮相關的文檔字段並刪除所有空條目：</p><pre><code class=\"language-Python\">import json\nfrom typing import List\nfrom haystack import Document, component\n\nrelevant_keys = ['Summary', 'Issue key', 'Issue id', 'Parent id', 'Issue type', 'Status', 'Project lead', 'Priority', 'Assignee', 'Reporter', 'Creator', 'Created', 'Updated', 'Last Viewed', 'Due Date', 'Labels',\n                 'Description', 'Comment', 'Comment__1', 'Comment__2', 'Comment__3', 'Comment__4', 'Comment__5', 'Comment__6', 'Comment__7', 'Comment__8', 'Comment__9', 'Comment__10', 'Comment__11', 'Comment__12',\n                 'Comment__13', 'Comment__14', 'Comment__15']\n\n@component\nclass RemoveKeys:\n    @component.output_types(documents=List[Document])\n    def run(self, file_name: str):\n        with open(file_name, 'r') as file:\n            tickets = json.load(file)\n        cleaned_tickets = []\n        for t in tickets:\n            t = {k: v for k, v in t.items() if k in relevant_keys and v}\n            cleaned_tickets.append(t)\n        return {'documents': cleaned_tickets}\n</code></pre><p>然後我們需要創建一個自定義 JSON 轉換器，將工單轉換為 Haystack 可以理解的 Document 對象：</p><pre><code class=\"language-Python\">@component\nclass JsonConverter:\n    @component.output_types(documents=List[Document])\n    def run(self, tickets: List[Document]):\n        tickets_documents = []\n        for t in tickets:\n            if 'Parent id' in t:\n                t = Document(content=json.dumps(t), meta={'Issue key': t['Issue key'], 'Issue id': t['Issue id'], 'Parent id': t['Parent id']})\n            else:\n                t = Document(content=json.dumps(t), meta={'Issue key': t['Issue key'], 'Issue id': t['Issue id'], 'Parent id': ''})\n            tickets_documents.append(t)\n        return {'documents': tickets_documents}\n</code></pre><p>最後，我們對 Documents 進行嵌入，並將這些嵌入寫入 ChromaDocumentStore：</p><pre><code class=\"language-Python\">from haystack import Pipeline\n\nfrom haystack.components.writers import DocumentWriter\nfrom haystack_integrations.components.retrievers.chroma import ChromaEmbeddingRetriever\nfrom haystack.document_stores.types import DuplicatePolicy\n\nfrom haystack_integrations.components.embedders.jina import JinaDocumentEmbedder\n\nretriever = ChromaEmbeddingRetriever(document_store=document_store)\nretriever_reranker = ChromaEmbeddingRetriever(document_store=document_store)\n\nindexing_pipeline = Pipeline()\nindexing_pipeline.add_component('cleaner', RemoveKeys())\nindexing_pipeline.add_component('converter', JsonConverter())\nindexing_pipeline.add_component('embedder', JinaDocumentEmbedder(model='jina-embeddings-v2-base-en'))\nindexing_pipeline.add_component('writer', DocumentWriter(document_store=document_store, policy=DuplicatePolicy.SKIP))\n\nindexing_pipeline.connect('cleaner', 'converter')\nindexing_pipeline.connect('converter', 'embedder')\nindexing_pipeline.connect('embedder', 'writer')\n\nindexing_pipeline.run({'cleaner': {'file_name': 'tickets.json'}})\n</code></pre><p>這應該會創建一個進度條並輸出一個包含存儲信息的簡短 JSON：</p><pre><code class=\"language-Text\">Calculating embeddings: 100%|██████████| 1/1 [00:01&lt;00:00,  1.21s/it]\n{'embedder': {'meta': {'model': 'jina-embeddings-v2-base-en',\n   'usage': {'total_tokens': 20067, 'prompt_tokens': 20067}}},\n 'writer': {'documents_written': 31}}</code></pre><h3 id=\"build-the-query-pipeline\">建立查詢流程</h3><p>讓我們建立一個查詢流程，以便開始比較工單。在 Haystack 2.0 中，檢索器與 DocumentStore 緊密結合。如果我們將文件存儲傳遞給先前初始化的檢索器，此流程就可以訪問我們生成的文件，並將它們傳遞給重排序器。重排序器然後直接將這些文件與問題進行比較，並根據相關性進行排名。</p><p>我們首先定義自定義清理器，以移除包含與作為查詢傳遞的問題具有相同問題 ID 或父 ID 的工單：</p><pre><code class=\"language-Python\">from typing import Optional\n\n@component\nclass RemoveRelated:\n    @component.output_types(documents=List[Document])\n    def run(self, tickets: List[Document], query_id: Optional[str]):\n        retrieved_tickets = []\n        for t in tickets:\n            if not t.meta['Issue id'] == query_id and not t.meta['Parent id'] == query_id:\n                retrieved_tickets.append(t)\n        return {'documents': retrieved_tickets}\n</code></pre><p>然後我們對查詢進行嵌入，檢索相關文件，清理選擇，最後進行重排序：</p><pre><code class=\"language-Python\">from haystack_integrations.components.embedders.jina import JinaTextEmbedder\nfrom haystack_integrations.components.rankers.jina import JinaRanker\n\nquery_pipeline_reranker = Pipeline()\nquery_pipeline_reranker.add_component('query_embedder_reranker', JinaTextEmbedder(model='jina-embeddings-v2-base-en'))\nquery_pipeline_reranker.add_component('query_retriever_reranker', retriever_reranker)\nquery_pipeline_reranker.add_component('query_cleaner_reranker', RemoveRelated())\nquery_pipeline_reranker.add_component('query_ranker_reranker', JinaRanker())\n\nquery_pipeline_reranker.connect('query_embedder_reranker.embedding', 'query_retriever_reranker.query_embedding')\nquery_pipeline_reranker.connect('query_retriever_reranker', 'query_cleaner_reranker')\nquery_pipeline_reranker.connect('query_cleaner_reranker', 'query_ranker_reranker')\n</code></pre><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/04/upload_916b6073b69f880f765730833bcdfbe3.png\" class=\"kg-image\" alt=\"Flowchart diagram outlining a query processing workflow with functions like 'text', 'query_embedder_reranker', 'meta'.\" loading=\"lazy\" width=\"510\" height=\"972\"></figure><p>為了突顯重排序器帶來的差異，我們分析了同一個流程但沒有最後重排序步驟的情況（為了便於閱讀，本文省略了相應的程式碼，但可以在 notebook 中找到）：</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/04/upload_d16f493c35c403b55f7c420c11c1f998.png\" class=\"kg-image\" alt=\"Flowchart detailing a text search process with 'query_embedding', 'query_retriever', and 'query_cleaner' components.\" loading=\"lazy\" width=\"572\" height=\"984\"></figure><p>為了比較這兩個流程的結果，我們現在以現有工單的形式定義查詢，這裡是「ZOOKEEPER-3282」：</p><pre><code class=\"language-Python\">query_ticket_key = 'ZOOKEEPER-3282'\n\nwith open('tickets.json', 'r') as file:\n    tickets = json.load(file)\n\nfor ticket in tickets:\n    if ticket['Issue key'] == query_ticket_key:\n        query = str(ticket)\n        query_ticket_id = ticket['Issue id']\n</code></pre><p>這涉及「文件的大規模重構」[<a href=\"https://en.wikipedia.org/wiki/Sic?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\"><em>sic</em></a>]。你會看到，儘管拼寫錯誤，Jina Reranker 仍能正確檢索到相似的工單。</p><pre><code class=\"language-JSON\">{\n    \"Summary\": \"a big refactor for the documetations\"\n    \"Issue key\": \"ZOOKEEPER-3282\"\n    \"Issue id:: 13216608\n    \"Parent id\": \"\"\n    \"Issue Type\": \"Task\"\n    \"Status\": \"In Progress\"\n    \"Project lead\": \"phunt\"\n    \"Priority\": \"Major\"\n    \"Assignee\": \"maoling\"\n    \"Reporter\": \"maoling\"\n    \"Creator\": \"maoling\"\n    \"Created\": \"19/Feb/19 11:50\"\n    \"Updated\": \"04/Aug/19 12:48\"\n    \"Last Viewed\": \"12/Mar/24 11:56\"\n    \"Description\": \"Hi guys: I'am working on doing a big refactor for the documetations.it aims to - 1.make a better reading experiences and help users know more about zookeeper quickly,as good as other projects' doc(e.g redis,hbase). - 2.have less changes to diff with the original docs as far as possible. - 3.solve the problem when we have some new features or improvements,but cannot find a good place to doc it.   The new catalog may looks kile this: * is new one added. ** is the one to keep unchanged as far as possible. *** is the one modified. -------------------------------------------------------------- |---Overview    |---Welcome ** [1.1]    |---Overview ** [1.2]    |---Getting Started ** [1.3]    |---Release Notes ** [1.4] |---Developer    |---API *** [2.1]    |---Programmer's Guide ** [2.2]    |---Recipes *** [2.3]    |---Clients * [2.4]    |---Use Cases * [2.5] |---Admin &amp; Ops    |---Administrator's Guide ** [3.1]    |---Quota Guide ** [3.2]    |---JMX ** [3.3]    |---Observers Guide ** [3.4]    |---Dynamic Reconfiguration ** [3.5]    |---Zookeeper CLI * [3.6]    |---Shell * [3.7]    |---Configuration flags * [3.8]    |---Troubleshooting &amp; Tuning  * [3.9] |---Contributor Guidelines    |---General Guidelines * [4.1]    |---ZooKeeper Internals ** [4.2] |---Miscellaneous    |---Wiki ** [5.1]    |---Mailing Lists ** [5.2] -------------------------------------------------------------- The Roadmap is: 1.(I pick up it : D)  1.1 write API[2.1], which includes the：    1.1.1  original API Docs which is a Auto-generated java doc,just give a link.    1.1.2. Restful-api (the apis under the /zookeeper-contrib-rest/src/main/java/org/apache/zookeeper/server/jersey/resources)  1.2 write Clients[2.4], which includes the:      1.2.1 C client      1.2.2 zk-python, kazoo      1.2.3 Curator etc.......      look at an example from: https://redis.io/clients # write Recipes[2.3], which includes the:  - integrate \"Java Example\" and \"Barrier and Queue Tutorial\"(Since some bugs in the examples and they are obsolete，we may delete something) into it.  - suggest users to use the recipes implements of Curator and link to the Curator's recipes doc.   # write Zookeeper CLI[3.6], which includes the:  - about how to use the zk command line interface [./zkCli.sh]    e.g ls /; get ; rmr;create -e -p etc.......  - look at an example from redis: https://redis.io/topics/rediscli   # write shell[3.7], which includes the:   - list all usages of the shells under the zookeeper/bin. (e.g zkTxnLogToolkit.sh,zkCleanup.sh)   # write Configuration flags[3.8], which includes the:   - list all usages of configurations properties(e.g zookeeper.snapCount):   - move the original Advanced Configuration part of zookeeperAdmin.md into it.     look at an example from:https://coreos.com/etcd/docs/latest/op-guide/configuration.html    # write Troubleshooting &amp; Tuning[3.9], which includes the:   - move the original \"Gotchas: Common Problems and Troubleshooting\" part of Administrator's Guide.md into it.   - move the original \"FAQ\" into into it.   - add some new contents （e.g https://www.yumpu.com/en/document/read/29574266/building-an-impenetrable-zookeeper-pdf-github）.   look at an example from:https://redis.io/topics/problems                             https://coreos.com/etcd/docs/latest/tuning.html   # write General Guidelines[4.1], which includes the:  - move the original \"Logging\" part of ZooKeeper Internals into it as the logger specification.  - write specifications about code, git commit messages,github PR  etc ...    look at an example from:    http://hbase.apache.org/book.html#hbase.commit.msg.format   # write Use Cases[2.5], which includes the:  - just move the context from: https://cwiki.apache.org/confluence/display/ZOOKEEPER/PoweredBy into it.  - add some new contents.(e.g Apache Projects:Spark;Companies:twitter,fb)   -------------------------------------------------------------- BTW: - Any insights or suggestions are very welcomed.After the dicussions,I will create a series of tickets(An umbrella) - Since these works can be done parallelly, if you are interested in them, please don't hesitate,just assign to yourself, pick it up. (Notice: give me a ping to avoid the duplicated work).\"\n}\n</code></pre><p>最後，我們運行查詢流程。在這種情況下，它會檢索 20 個工單，刪除 ID 相關的條目，對它們進行重排序，並輸出 10 個最相關問題的最終選擇。</p><p>在重新排序步驟之前，輸出包含 17 張票證：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Issue ID</th>\n<th>Issue Key</th>\n<th>Summary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>13191544</td>\n<td>ZOOKEEPER-3170</td>\n<td>Umbrella for eliminating ZooKeeper flaky tests</td>\n</tr>\n<tr>\n<td>2</td>\n<td>13400622</td>\n<td>ZOOKEEPER-4375</td>\n<td>Quota cannot limit the specify value when multiply clients create/set znodes</td>\n</tr>\n<tr>\n<td>3</td>\n<td>13249579</td>\n<td>ZOOKEEPER-3499</td>\n<td>[admin server way] Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n<tr>\n<td>4</td>\n<td>13295073</td>\n<td>ZOOKEEPER-3775</td>\n<td>Wrong message in IOException</td>\n</tr>\n<tr>\n<td>5</td>\n<td>13268474</td>\n<td>ZOOKEEPER-3617</td>\n<td>ZK digest ACL permissions gets overridden</td>\n</tr>\n<tr>\n<td>6</td>\n<td>13296971</td>\n<td>ZOOKEEPER-3787</td>\n<td>Apply modernizer-maven-plugin to build</td>\n</tr>\n<tr>\n<td>7</td>\n<td>13265507</td>\n<td>ZOOKEEPER-3600</td>\n<td>support the complete linearizable read and multiply read consistency level</td>\n</tr>\n<tr>\n<td>8</td>\n<td>13222060</td>\n<td>ZOOKEEPER-3318</td>\n<td>[CLI way]Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n<tr>\n<td>9</td>\n<td>13262989</td>\n<td>ZOOKEEPER-3587</td>\n<td>Add a documentation about docker</td>\n</tr>\n<tr>\n<td>10</td>\n<td>13262130</td>\n<td>ZOOKEEPER-3578</td>\n<td>Add a new CLI: multi</td>\n</tr>\n<tr>\n<td>11</td>\n<td>13262828</td>\n<td>ZOOKEEPER-3585</td>\n<td>Add a documentation about RequestProcessors</td>\n</tr>\n<tr>\n<td>12</td>\n<td>13262494</td>\n<td>ZOOKEEPER-3583</td>\n<td>Add new apis to get node type and ttl time info</td>\n</tr>\n<tr>\n<td>13</td>\n<td>12998876</td>\n<td>ZOOKEEPER-2519</td>\n<td>zh->state should not be 0 while handle is active</td>\n</tr>\n<tr>\n<td>14</td>\n<td>13536435</td>\n<td>ZOOKEEPER-4696</td>\n<td>Update for Zookeeper latest version</td>\n</tr>\n<tr>\n<td>15</td>\n<td>13297249</td>\n<td>ZOOKEEPER-3789</td>\n<td>fix the build warnings about @see,@link,@return found by IDEA</td>\n</tr>\n<tr>\n<td>16</td>\n<td>12728973</td>\n<td>ZOOKEEPER-1983</td>\n<td>Append to zookeeper.out (not overwrite) to support logrotation</td>\n</tr>\n<tr>\n<td>17</td>\n<td>12478629</td>\n<td>ZOOKEEPER-915</td>\n<td>Errors that happen during sync() processing at the leader do not get propagated back to the client.</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>在加入重新排序器後，我們現在執行查詢管道：</p><pre><code class=\"language-Python\">result = query_pipeline_reranker.run(data={'query_embedder_reranker':{'text': query},\n                                  'query_retriever_reranker': {'top_k': 20},\n                                  'query_cleaner_reranker': {'query_id': query_ticket_id},\n                                  'query_ranker_reranker': {'query': query, 'top_k': 10}\n                                  }\n                            )\n\nfor idx, res in enumerate(result['query_ranker_reranker']['documents']):\n    print('Doc {}:'.format(idx + 1), res)\n</code></pre><p>最終輸出是 10 張最相關的票證：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Issue ID</th>\n<th>Issue Key</th>\n<th>Summary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>13262989</td>\n<td>ZOOKEEPER-3587</td>\n<td>Add a documentation about docker</td>\n</tr>\n<tr>\n<td>2</td>\n<td>13265507</td>\n<td>ZOOKEEPER-3600</td>\n<td>support the complete linearizable read and multiply read consistency level</td>\n</tr>\n<tr>\n<td>3</td>\n<td>13249579</td>\n<td>ZOOKEEPER-3499</td>\n<td>[admin server way] Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n<tr>\n<td>4</td>\n<td>12478629</td>\n<td>ZOOKEEPER-915</td>\n<td>Errors that happen during sync() processing at the leader do not get propagated back to the client.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>13262828</td>\n<td>ZOOKEEPER-3585</td>\n<td>Add a documentation about RequestProcessors</td>\n</tr>\n<tr>\n<td>6</td>\n<td>13297249</td>\n<td>ZOOKEEPER-3789</td>\n<td>fix the build warnings about @see,@link,@return found by IDEA</td>\n</tr>\n<tr>\n<td>7</td>\n<td>12998876</td>\n<td>ZOOKEEPER-2519</td>\n<td>zh->state should not be 0 while handle is active</td>\n</tr>\n<tr>\n<td>8</td>\n<td>13536435</td>\n<td>ZOOKEEPER-4696</td>\n<td>Update for Zookeeper latest version</td>\n</tr>\n<tr>\n<td>9</td>\n<td>12728973</td>\n<td>ZOOKEEPER-1983</td>\n<td>Append to zookeeper.out (not overwrite) to support logrotation</td>\n</tr>\n<tr>\n<td>10</td>\n<td>13222060</td>\n<td>ZOOKEEPER-3318</td>\n<td>[CLI way]Add a complete backup mechanism for zookeeper internal</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"advantages-of-jina-embeddings-and-reranker\">Jina Embeddings 和 Reranker 的優勢</h2><p>總結這個教程，我們基於 <a href=\"https://jina.ai/embeddings/?ref=jina-ai-gmbh.ghost.io\">Jina Embeddings</a>、<a href=\"https://jina.ai/reranker/?ref=jina-ai-gmbh.ghost.io\">Jina Reranker</a> 和 <a href=\"https://haystack.deepset.ai/?ref=jina-ai-gmbh.ghost.io\">Haystack 2.0</a> 構建了一個重複票證識別工具。上述結果清楚地表明，需要 Jina Embeddings 通過向量搜尋檢索相關文檔，並需要 Jina Reranker 最終獲取最相關的內容。</p><p>以兩個與新增文檔相關的問題為例，即\"ZOOKEEPER-3585\"和\"ZOOKEEPER-3587\"，我們看到在檢索步驟之後，它們分別被正確地列在第 11 和第 9 位。在對文檔重新排序後，它們現在都進入了最相關文檔的前 5 名，分別位於第 5 和第 1 位，顯示出顯著的改進。</p><p>通過在 Haystack 的管道中整合這兩個模型，整個工具已經可以使用。這種組合使 <a href=\"https://haystack.deepset.ai/integrations/jina/?ref=jina-ai-gmbh.ghost.io\">Jina Haystack 擴展</a>成為您應用程式的完美解決方案。</p>",
  "comment_id": "661543ffd6a1020001681e99",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/04/Reranker-Haystack.jpg",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-04-09T15:34:55.000+02:00",
  "updated_at": "2024-07-08T21:11:51.000+02:00",
  "published_at": "2024-04-10T16:00:49.000+02:00",
  "custom_excerpt": "Learn how to use Jina Reranker and Embeddings with Haystack to create your own Jira ticket search engine, streamlining your operations and never again waste time creating duplicate issues.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "authors": [
    {
      "id": "65e85e35b22368000152a4bf",
      "name": "Francesco Kruk",
      "slug": "francesco",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Portrait-Picture_Low.jpg",
      "cover_image": null,
      "bio": null,
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/francesco/"
    }
  ],
  "primary_author": {
    "id": "65e85e35b22368000152a4bf",
    "name": "Francesco Kruk",
    "slug": "francesco",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Portrait-Picture_Low.jpg",
    "cover_image": null,
    "bio": null,
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/francesco/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/retrieve-jira-tickets-with-jina-reranker-and-haystack-20/",
  "excerpt": "瞭解如何使用 Jina Reranker 和 Embeddings 搭配 Haystack 來建立你自己的 Jira 工單搜尋引擎，以簡化你的作業流程，再也不會浪費時間建立重複的問題。",
  "reading_time": 10,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Graphic with \"Reranker\" and \"Haystack by deepset\" on a black background with teal decorative elements.",
  "feature_image_caption": null
}