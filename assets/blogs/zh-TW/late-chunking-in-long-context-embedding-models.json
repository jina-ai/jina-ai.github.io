{
  "slug": "late-chunking-in-long-context-embedding-models",
  "id": "66c72e30da9a33000146d836",
  "uuid": "9eda87e2-a799-4360-bac9-6a1cd0193349",
  "title": "長文本嵌入模型中的延後分塊技術",
  "html": "<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Late Chunking 現已在 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">jina-embeddings-v3</code> API 中提供。<b><strong style=\"white-space: pre-wrap;\">建議閱讀順序：第一部分、</strong></b><a href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii/?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">第二部分</strong></b></a><b><strong style=\"white-space: pre-wrap;\">、</strong></b><a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">研究論文</strong></b></a><b><strong style=\"white-space: pre-wrap;\">。</strong></b></div></div><p></p><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">What Late Chunking Really Is &amp; What It's Not: Part II</div><div class=\"kg-bookmark-description\">Part 2 of our exploration of Late Chunking, a deep dive into why it is the best method for chunk embeddings and improving search/RAG performance.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-128x128-4.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/lc2.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">最新！第二部分：深入探討邊界線索和誤解。</span></p></figcaption></figure><p>大約一年前，在 2023 年 10 月，我們發布了<a href=\"https://jina.ai/news/jina-ai-launches-worlds-first-open-source-8k-text-embedding-rivaling-openai?ref=jina-ai-gmbh.ghost.io\">世界上第一個具有 8K 上下文長度的開源嵌入模型</a>，<code>jina-embeddings-v2-base-en</code>。此後，關於嵌入模型中長上下文的用處，一直存在著諸多爭議。對於許多應用來說，將數千字長的文檔編碼為單一嵌入表示並非理想選擇。許多使用案例需要檢索較小的文本片段，而且密集向量檢索系統通常在處理較小的文本片段時表現更好，因為語義在嵌入向量中不太可能被「過度壓縮」。</p><p>檢索增強生成（RAG）是最著名的應用之一，它需要將文檔分割成較小的文本塊（例如在 512 個標記內）。這些塊通常存儲在向量資料庫中，其向量表示由文本嵌入模型生成。在運行時，相同的嵌入模型將查詢編碼為向量表示，然後用於識別相關的存儲文本塊。這些文本塊隨後被傳遞給大型語言模型（LLM），後者根據檢索到的文本合成對查詢的回應。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/Diagram--Blog-images--1-.svg\" class=\"kg-image\" alt=\"Flowchart detailing a query processing system, starting from &quot;Query&quot; to &quot;Document Chunks&quot; and &quot;Embedding Model,&quot; then to &quot;Vec\" loading=\"lazy\" width=\"1458\" height=\"307\"><figcaption><span style=\"white-space: pre-wrap;\">典型的 RAG 管線：分塊-嵌入-檢索-生成。</span></figcaption></figure><p>簡而言之，嵌入較小的塊似乎更為可取，部分原因是下游 LLM 的輸入大小限制，同時也因為<strong>人們擔心長上下文中的重要上下文信息在壓縮成單一向量時可能會被稀釋</strong>。</p><p>但如果行業只需要 512 上下文長度的嵌入模型，<em>那麼訓練 8192 上下文長度的模型有什麼意義呢？</em></p><p>在本文中，我們通過探索 RAG 中簡單分塊-嵌入管線的局限性，重新審視這個重要但令人不適的問題。我們引入了一種名為<strong>「Late Chunking」</strong>的新方法，它利用 8192 長度嵌入模型提供的豐富上下文信息來更有效地嵌入文本塊。</p><h2 id=\"the-lost-context-problem\">丟失上下文問題</h2><p>簡單的分塊-嵌入-檢索-生成 RAG 管線並非沒有挑戰。具體來說，<strong>這個過程可能會破壞遠距離上下文依賴關係。</strong>換句話說，當相關信息分散在多個塊中時，將文本片段脫離上下文可能會使其失去效果，這使得這種方法特別有問題。</p><p>在下圖中，一篇 Wikipedia 文章被分割成句子塊。你可以看到像「its」和「the city」這樣的詞指代的是「Berlin」，而「Berlin」只在第一句中提到。這使得嵌入模型更難將這些引用與正確的實體聯繫起來，從而產生較低質量的向量表示。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/image-3.png\" class=\"kg-image\" alt=\"Comparative panels display Berlin's Wikipedia article and its chunked text to highlight clarity and readability benefits.\" loading=\"lazy\" width=\"1774\" height=\"456\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/08/image-3.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/08/image-3.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/08/image-3.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/08/image-3.png 1774w\" sizes=\"(min-width: 720px) 720px\"></figure><p>這意味著，如果我們將一篇長文章分割成句子長度的塊，如上例所示，RAG 系統可能難以回答「柏林的人口是多少？」這樣的查詢。因為城市名稱和人口數字從未在同一個塊中出現，而且在沒有更大文檔上下文的情況下，提供給 LLM 的任一塊都無法解析像「it」或「the city」這樣的照應引用。</p><p>有一些啟發式方法可以緩解這個問題，比如使用滑動窗口重新採樣、使用多個上下文窗口長度，以及執行多次文檔掃描。然而，像所有啟發式方法一樣，這些方法都是碰運氣的；它們在某些情況下可能有效，但在理論上無法保證其有效性。</p><h2 id=\"the-solution-late-chunking\">解決方案：Late Chunking</h2><p>簡單的編碼方法（如下圖左側所示）涉及使用句子、段落或最大長度限制來預先分割文本。之後，嵌入模型被重複應用於這些結果塊。為了為每個塊生成單一嵌入，許多嵌入模型使用這些標記級嵌入的<em>平均池化</em>來輸出單一嵌入向量。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/Diagram--Blog-images--4-.svg\" class=\"kg-image\" alt=\"Flowchart comparing naive and late chunking methods in document processing with labeled steps and embeddings.\" loading=\"lazy\" width=\"1020\" height=\"865\"><figcaption><span style=\"white-space: pre-wrap;\">簡單分塊策略（左）和 Late Chunking 策略（右）的示意圖。</span></figcaption></figure><p>相比之下，我們在本文中提出的「Late Chunking」方法首先將嵌入模型的 transformer 層應用於<em>整個文本</em>或盡可能多的文本。這會為每個標記生成一個包含整個文本信息的向量表示序列。隨後，對這個標記向量序列的每個塊進行平均池化，產生考慮了整個文本上下文的每個塊的嵌入。與生成獨立同分布（i.i.d.）塊嵌入的簡單編碼方法不同，<strong>Late Chunking 創建了一組塊嵌入，其中每一個都是「以前一個為條件」，從而為每個塊編碼更多的上下文信息。</strong></p><p>顯然，要有效應用 Late Chunking，我們需要像 <code>jina-embeddings-v2-base-en</code> 這樣的長上下文嵌入模型，它支持高達 8192 個標記——大約相當於十頁標準文本。這種大小的文本片段更不太可能有需要更長上下文才能解決的上下文依賴關係。</p><p>需要強調的是，Late Chunking 仍然需要邊界線索，但這些線索只在獲得標記級嵌入<em>之後</em>才使用——因此在命名中使用「late」一詞。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>簡單分塊</th>\n<th>Late Chunking</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>邊界線索的需求</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>邊界線索的使用</td>\n<td>直接在預處理中</td>\n<td>在從 transformer 層獲得標記級嵌入之後</td>\n</tr>\n<tr>\n<td>結果塊嵌入</td>\n<td>i.i.d.</td>\n<td>條件性</td>\n</tr>\n<tr>\n<td>鄰近塊的上下文信息</td>\n<td>丟失。一些啟發式方法（如重疊採樣）可緩解此問題</td>\n<td>通過長上下文嵌入模型得到良好保留</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"implementation-and-qualitative-evaluation\">實作和質性評估</h2><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/15vNZb6AsU7byjYoaEtXuNu567JWNzXOz?usp=sharing&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://ssl.gstatic.com/colaboratory-static/common/4c9d6ee1a7679cb6c4c106e58fabaf56/img/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://colab.research.google.com/img/colab_favicon_256px.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Late Chunking 的實作可以在上面連結的 Google Colab 中找到。在這裡，我們利用 Tokenizer API 中最近發布的功能，該功能利用所有可能的邊界線索將長文檔分割成有意義的塊。關於這個功能背後的算法的更多討論可以在 X 上找到。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/tokenizer/?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Tokenizer API</div><div class=\"kg-bookmark-description\">免費 API，可用於文本標記化和將長文本分段。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-tokenize-api.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Based. Semantic chunking is overrated. Especially when you write a super regex that leverages all possible boundary cues and heuristics to segment text accurately without the need for complex language models. Just think about the speed and the hosting cost. This 50-line,… <a href=\"https://t.co/AtBCSrn7nI?ref=jina-ai-gmbh.ghost.io\">pic.twitter.com/AtBCSrn7nI</a></p>— Jina AI (@JinaAI_) <a href=\"https://twitter.com/JinaAI_/status/1823756993108304135?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">August 14, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><p>當對上述維基百科的例子應用延遲分段時，你可以立即看到語義相似度的改善。例如，在維基百科文章中提到\"這個城市\"和\"柏林\"時，表示\"這個城市\"的向量現在包含了將其與先前提到的\"柏林\"聯繫起來的資訊，這使其在涉及該城市名稱的查詢中能更好地匹配。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Query</th>\n<th>Chunk</th>\n<th>Sim. on naive chunking</th>\n<th>Sim. on late chunking</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Berlin</td>\n<td>Berlin is the capital and largest city of Germany, both by area and by population.</td>\n<td>0.849</td>\n<td>0.850</td>\n</tr>\n<tr>\n<td>Berlin</td>\n<td>Its more than 3.85 million inhabitants make it the European Union's most populous city, as measured by population within city limits.</td>\n<td>0.708</td>\n<td>0.825</td>\n</tr>\n<tr>\n<td>Berlin</td>\n<td>The city is also one of the states of Germany, and is the third smallest state in the country in terms of area.</td>\n<td>0.753</td>\n<td>0.850</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>你可以在上面的數值結果中觀察到這一點，這些結果比較了\"Berlin\"這個詞的嵌入與使用餘弦相似度得到的關於柏林文章中各個句子的嵌入。\"Sim. on IID chunk embeddings\"列顯示了\"Berlin\"查詢嵌入與使用先驗分段的嵌入之間的相似度值，而\"Sim. under contextual chunk embedding\"則代表使用延遲分段方法的結果。</p><h2 id=\"quantitative-evaluation-on-beir\">在 BEIR 上的定量評估</h2><p>為了驗證延遲分段在玩具示例之外的有效性，我們使用了 <a href=\"https://github.com/beir-cellar/beir?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\">BeIR</a> 中的一些檢索基準進行了測試。這些檢索任務包括一個查詢集、一個文本文檔語料庫，以及一個存儲與每個查詢相關文檔 ID 資訊的 QRels 文件。</p><p>要識別與查詢相關的文檔，首先將文檔進行分段，編碼成嵌入索引，並使用 k-近鄰（kNN）為每個查詢嵌入確定最相似的段落。由於每個段落對應一個文檔，因此可以將段落的 kNN 排名轉換為文檔的 kNN 排名（在排名中多次出現的文檔只保留第一次出現）。然後將這個結果排名與地面真相 QRels 文件提供的排名進行比較，並計算 nDCG@10 等檢索指標。下面描述了這個程序，為了可重現性，評估腳本可以在此存儲庫中找到。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/jina-ai/late-chunking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub - jina-ai/late-chunking: 用於解釋和評估延遲分段（chunked pooling）的程式碼</div><div class=\"kg-bookmark-description\">用於解釋和評估延遲分段（chunked pooling）的程式碼 - jina-ai/late-chunking</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">jina-ai</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://opengraph.githubassets.com/bf0bb9d5ca928dc3fe25ae621398af0fdf5e34324e37cbeee6fa4189218c9b4d/jina-ai/late-chunking\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>我們在各種 BeIR 數據集上運行了這個評估，比較了朴素分段與我們的延遲分段方法。為了獲取邊界線索，我們使用了一個將文本分割成大約 256 個標記的正則表達式。朴素和延遲分段評估都使用了 <a href=\"https://huggingface.co/jinaai/jina-embeddings-v2-small-en?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\"><code>jina-embeddings-v2-small-en</code></a> 作為嵌入模型；這是 <code>v2-base-en</code> 模型的一個較小版本，仍然支持最多 8192 個標記長度。結果可以在下表中找到。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>Avg. Document Length (characters)</th>\n<th>Naive Chunking (nDCG@10)</th>\n<th>Late Chunking (nDCG@10)</th>\n<th>No Chunking (nDCG@10)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SciFact</td>\n<td>1498.4</td>\n<td>64.20%</td>\n<td><strong>66.10%</strong></td>\n<td>63.89%</td>\n</tr>\n<tr>\n<td>TRECCOVID</td>\n<td>1116.7</td>\n<td>63.36%</td>\n<td>64.70%</td>\n<td><strong>65.18%</strong></td>\n</tr>\n<tr>\n<td>FiQA2018</td>\n<td>767.2</td>\n<td>33.25%</td>\n<td><strong>33.84%</strong></td>\n<td>33.43%</td>\n</tr>\n<tr>\n<td>NFCorpus</td>\n<td>1589.8</td>\n<td>23.46%</td>\n<td>29.98%</td>\n<td><strong>30.40%</strong></td>\n</tr>\n<tr>\n<td>Quora</td>\n<td>62.2</td>\n<td>87.19%</td>\n<td>87.19%</td>\n<td>87.19%</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>在所有情況下，延遲分段都比朴素方法提高了分數。在某些情況下，它甚至超越了將整個文檔編碼為單一嵌入的效果，而在其他數據集中，完全不分段反而產生了最好的結果（當然，不分段只有在不需要對段落進行排名時才有意義，這種情況在實踐中很少見）。如果我們將朴素方法和延遲分段之間的性能差距與文檔長度進行對比，很明顯文檔的平均長度與延遲分段帶來的 nDCG 分數改善程度相關。換句話說，<strong>文檔越長，延遲分段策略的效果就越好。</strong></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/chart--22-.svg\" class=\"kg-image\" alt=\"折線圖顯示相對改善度隨文檔長度增加而下降，從 0 到 1500 個字符。\" loading=\"lazy\" width=\"582\" height=\"337\"><figcaption><span style=\"white-space: pre-wrap;\">延遲分段相對於朴素分段的改善程度與平均文檔長度相關。</span></figcaption></figure><h2 id=\"conclusion\">結論</h2><p>在本文中，我們介紹了一種稱為\"延遲分段\"的簡單方法，通過利用長上下文嵌入模型的力量來嵌入短段落。我們展示了傳統的獨立同分佈段落嵌入如何無法保留上下文資訊，導致檢索效果不佳；以及延遲分段如何提供一個簡單而高效的解決方案，以在每個段落中維持和調節上下文資訊。延遲分段的效果在較長文檔上變得更加顯著——這種能力只有通過像 <code>jina-embeddings-v2-base-en</code> 這樣的高級長上下文嵌入模型才能實現。我們希望這項工作不僅能驗證長上下文嵌入模型的重要性，還能激發該主題的進一步研究。</p><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/what-late-chunking-really-is-and-what-its-not-part-ii?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">延遲分段究竟是什麼以及不是什麼：第二部分</div><div class=\"kg-bookmark-description\">我們探索延遲分段的第 2 部分，深入探討為什麼它是段落嵌入和改善搜索/RAG 性能的最佳方法。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-128x128-5.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/lc2-1.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">繼續閱讀第二部分：深入探討邊界線索和誤解。</span></p></figcaption></figure>",
  "comment_id": "66c72e30da9a33000146d836",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/08/banner-late-chunking.jpg",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-08-22T14:25:20.000+02:00",
  "updated_at": "2024-10-06T16:29:02.000+02:00",
  "published_at": "2024-08-22T17:06:17.000+02:00",
  "custom_excerpt": "Chunking long documents while preserving contextual information is challenging. We introduce the \"Late Chunking\" that leverages long-context embedding models to generate contextual chunk embeddings for better retrieval applications.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "636409b554b68a003dfbdef8",
      "name": "Michael Günther",
      "slug": "michael",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/profile_low_quality.jpeg",
      "cover_image": null,
      "bio": "ML Scientist and Engineer @ Jina AI. Enthusiastic about open source and AI with particular interest in solving information retrieval problems.",
      "website": "https://github.com/guenthermi",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/michael/"
    },
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "636409b554b68a003dfbdef8",
    "name": "Michael Günther",
    "slug": "michael",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/profile_low_quality.jpeg",
    "cover_image": null,
    "bio": "ML Scientist and Engineer @ Jina AI. Enthusiastic about open source and AI with particular interest in solving information retrieval problems.",
    "website": "https://github.com/guenthermi",
    "location": "Berlin",
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/michael/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/late-chunking-in-long-context-embedding-models/",
  "excerpt": "在保留上下文資訊的同時對長篇文件進行分塊具有挑戰性。我們提出「Late Chunking」方法，運用長上下文嵌入模型來生成具有上下文的區塊嵌入，以實現更好的檢索應用。",
  "reading_time": 8,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Diagram illustrating the 'Late Chunking' and 'Long Document Model' processes in machine learning on a black background.",
  "feature_image_caption": null
}