{
  "slug": "dspy-not-your-average-prompt-engineering",
  "id": "66077bf0a5c39b0001044181",
  "uuid": "e242c77c-f712-462c-9745-3e9269eb8a8b",
  "title": "DSPy：不只是一般的 Prompt 工程",
  "html": "<div class=\"kg-card kg-file-card\"><a class=\"kg-file-card-container\" href=\"https://jina-ai-gmbh.ghost.io/content/files/2024/04/DSPy-Not-Your-Average-Prompt-Engineering--1-.pdf\" title=\"Download\" download=\"\"><div class=\"kg-file-card-contents\"><div class=\"kg-file-card-title\">[投影片] DSPy：不是一般的提示詞工程</div><div class=\"kg-file-card-caption\">Han 於 2024 年 4 月 15 日在 Mountain View 的演講。</div><div class=\"kg-file-card-metadata\"><div class=\"kg-file-card-filename\">DSPy Not Your Average Prompt Engineering (1).pdf</div><div class=\"kg-file-card-filesize\">7 MB</div></div></div><div class=\"kg-file-card-icon\"><svg viewBox=\"0 0 24 24\"><defs><style>.a{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;}</style></defs><title>download-circle</title><polyline class=\"a\" points=\"8.25 14.25 12 18 15.75 14.25\"></polyline><line class=\"a\" x1=\"12\" y1=\"6.75\" x2=\"12\" y2=\"18\"></line><circle class=\"a\" cx=\"12\" cy=\"12\" r=\"11.25\"></circle></svg></div></a></div><p>最近我研究了 DSPy，這是由 Stanford NLP 團隊開發的前沿框架，旨在以演算法方式優化語言模型 (LM) 的提示詞。在過去三天裡，我對 DSPy 有了一些初步印象和寶貴見解。需要注意的是，我的觀察並非要取代 DSPy 的官方文件。事實上，我強烈建議在閱讀這篇文章之前，至少先閱讀一遍<a href=\"https://dspy-docs.vercel.app/?ref=jina-ai-gmbh.ghost.io\">他們的文件</a>和 <a href=\"https://github.com/stanfordnlp/dspy/blob/main/README.md?ref=jina-ai-gmbh.ghost.io\">README</a>。我在這裡的討論反映了我花了幾天時間探索其功能後的初步理解。還有一些進階功能，如 DSPy Assertions、Typed Predictor 和 LM weights tuning，我還沒有深入探索。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/stanfordnlp/dspy?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub - stanfordnlp/dspy: DSPy: The framework for programming—not prompting—foundation models</div><div class=\"kg-bookmark-description\">DSPy: The framework for programming—not prompting—foundation models - stanfordnlp/dspy</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">stanfordnlp</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://opengraph.githubassets.com/b8c1b2b4b3ff9c22d486f5c69dbda5fee6cc8dda8a42aaf1c2e154c17b7dc159/stanfordnlp/dspy\" alt=\"\"></div></a></figure><p>儘管我在 Jina AI 的背景主要集中在搜尋基礎架構上，我對 DSPy 的興趣並不是直接由其在檢索增強生成（RAG）方面的潛力所驅動。相反，我對利用 DSPy 進行自動提示詞調優來解決一些生成任務的可能性感到興趣。</p><p>如果你是 DSPy 的新手並尋找易於入門的起點，或者你已經熟悉該框架但覺得官方文件令人困惑或難以理解，這篇文章就是為你而寫的。我也選擇不嚴格遵循 DSPy 的慣用語法，因為這可能會讓新手感到困難。讓我們深入探討吧。</p><h2 id=\"what-i-like-about-dspy\">我喜歡 DSPy 的地方</h2><h3 id=\"dspy-closing-the-loop-of-prompt-engineering\">DSPy 閉環了提示詞工程的循環</h3><p>DSPy 最令我興奮的是它如何閉環提示詞工程的循環，將原本<em>手動</em>、<em>手工打造</em>的過程轉變為<em>結構化</em>、<em>明確定義</em>的機器學習工作流程：即準備數據集、定義模型、訓練、評估和測試。<strong>在我看來，這是 DSPy 最具革命性的方面。</strong></p><p>在灣區旅行並與許多專注於 LLM 評估的創業公司創始人交談時，我經常聽到關於指標、幻覺、可觀察性和合規性的討論。然而，這些對話往往沒有進展到關鍵的下一步：<strong>有了這些指標之後，我們該怎麼做？</strong>調整提示詞中的措辭，希望某些神奇的詞語（例如「我奶奶快死了」）能提升我們的指標，這能被視為一種策略性的方法嗎？這個問題一直沒有得到許多 LLM 評估創業公司的解答，我也無法解決——直到我發現了 DSPy。DSPy 引入了一種清晰的、程式化的方法來基於特定指標優化提示詞，甚至可以優化整個 LLM 管道，包括提示詞和 LLM 權重。</p><p>LangChain 的 CEO Harrison 和前 OpenAI 開發者關係主管 Logan 都在<a href=\"https://podcasts.apple.com/us/podcast/unsupervised-learning/id1672188924?ref=jina-ai-gmbh.ghost.io\">Unsupervised Learning Podcast</a> 中表示，2024 年將是 LLM 評估的關鍵一年。正因如此，我認為 DSPy 值得比現在更多的關注，因為 DSPy 提供了這個拼圖中缺失的關鍵部分。</p><h3 id=\"dspy-separating-logic-from-textual-representation\">DSPy 將邏輯從文字表示中分離</h3><p>DSPy 令我印象深刻的另一個方面是，它將提示詞工程轉化為一個可重現且與 LLM 無關的模組。為了實現這一點，<strong>它將邏輯從提示詞中抽離出來，在<em>邏輯</em>和<em>文字表示</em>之間創建了明確的關注點分離</strong>，如下圖所示。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--5-.png\" class=\"kg-image\" alt=\"Flowchart depicting sentiment analysis process with steps such as Prompt, Logic, and Textual Representation on a black backgr\" loading=\"lazy\" width=\"1200\" height=\"630\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Heading--5-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/Heading--5-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--5-.png 1200w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">在 DSPy 中，提示詞包含內在邏輯（即 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>dspy.Module</span></code><span style=\"white-space: pre-wrap;\">）和其文字表示。邏輯是不可變的、可重現的、可測試的且與 LLM 無關。文字表示只是邏輯的結果。</span></figcaption></figure><p><strong>DSPy 將邏輯視為不可變、可測試和與 LLM 無關的「原因」，而文字表示僅僅是其「結果」</strong>的概念，最初可能令人困惑。尤其是在普遍認為「程式語言的未來是自然語言」的背景下。在接受「提示詞工程是未來」這個想法的同時，當遇到 DSPy 的設計理念時，人們可能會感到困惑。與簡化的期望相反，DSPy 引入了一系列模組和簽名語法，似乎將自然語言提示回退到了 C 程式設計的複雜程度！</p><p>但為什麼要採用這種方法？我的理解是，<strong>提示詞程式設計的核心是邏輯，而溝通則是一個放大器</strong>，可能增強或減弱其效果。<code>\"Do sentiment classification\"</code> 代表核心邏輯，而像 <code>\"Follow these demonstrations or I will fire you\"</code> 這樣的短語只是溝通它的一種方式。就像現實生活中的互動一樣，無法完成任務通常不是因為邏輯有誤，而是因為溝通出了問題。這解釋了為什麼許多人，特別是非母語者，覺得提示詞工程具有挑戰性。我觀察到公司中一些非常有能力的軟體工程師在提示詞工程方面掙扎，並不是因為他們缺乏邏輯，而是因為他們無法「說出那種感覺」。通過將邏輯與提示詞分離，<a href=\"https://dspy-docs.vercel.app/docs/building-blocks/modules?ref=jina-ai-gmbh.ghost.io\">DSPy 通過 <code>dspy.Module</code> 實現了邏輯的確定性程式設計</a>，使開發者能夠像在傳統工程中一樣專注於邏輯，而不受所使用的 LLM 影響。</p><p>那麼，如果開發者專注於邏輯，誰來管理文字表示呢？<strong>DSPy 承擔了這個角色，利用你的資料和評估指標來改進文字表示</strong>——從確定敘述重點到優化提示，以及選擇好的示例。更令人驚訝的是，DSPy 甚至可以使用評估指標來微調 LLM 權重！</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--6-.png\" class=\"kg-image\" alt=\"Flowchart illustrating a language model with branches for training data, logic, textual representation, and final results.\" loading=\"lazy\" width=\"1200\" height=\"630\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Heading--6-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/Heading--6-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--6-.png 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>對我來說，DSPy 的主要貢獻——閉環提示詞工程的訓練和評估循環，以及將邏輯從文字表示中分離——突顯了它對 LLM/Agent 系統的潛在重要性。這無疑是一個雄心勃勃的願景，但絕對是必要的！</p><h2 id=\"what-i-think-dspy-can-improve\">我認為 DSPy 可以改進的地方</h2><p>首先，DSPy 對新手來說有很陡的學習曲線，這是由於它的慣用語。像 <code>signature</code>、<code>module</code>、<code>program</code>、<code>teleprompter</code>、<code>optimization</code> 和 <code>compile</code> 這樣的術語可能會令人感到不知所措。即使對於那些精通提示詞工程的人來說，在 DSPy 中導航這些概念也可能是一個具有挑戰性的迷宮。</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Yeah, DSPy really needs someone to come in and explain everything without suitcase words. <a href=\"https://twitter.com/CShorten30?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">@CShorten30</a> does a great job, but we need more.</p>— Jonathan Mugan (@jmugan) <a href=\"https://twitter.com/jmugan/status/1773036172723236895?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">March 27, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><p>這種複雜性讓我想起了使用 <a href=\"https://github.com/jina-ai/jina?ref=jina-ai-gmbh.ghost.io\">Jina 1.0</a> 的經歷，當時我們引入了一系列概念如 <code>chunk</code>、<code>document</code>、<code>driver</code>、<code>executor</code>、<code>pea</code>、<code>pod</code>、<code>querylang</code> 和 <code>flow</code>（我們甚至設計了可愛的貼紙來幫助用戶記住！）。</p><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Document-FLAT--3-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Document-FLAT--3-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Document-FLAT--3-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pea-FLAT--1-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Pea-FLAT--1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pea-FLAT--1-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/QueryLang--FLAT.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/QueryLang--FLAT.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/QueryLang--FLAT.png 700w\"></div></div><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--3-FLAT--1-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/ILLUST--3-FLAT--1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--3-FLAT--1-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pod-FLAT--2-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Pod-FLAT--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pod-FLAT--2-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--5-FLAT--2-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/ILLUST--5-FLAT--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--5-FLAT--2-.png 700w\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">這些早期概念大多在後來的 Jina 重構中被移除。如今，只有 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Executor</span></code><span style=\"white-space: pre-wrap;\">、</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Document</span></code><span style=\"white-space: pre-wrap;\"> 和 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Flow</span></code><span style=\"white-space: pre-wrap;\"> 倖存於「大清洗」。我們在 Jina 3.0 中確實新增了一個概念 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Deployment</span></code><span style=\"white-space: pre-wrap;\">，所以算是扯平了。🤷</span></p></figcaption></figure><p>這個問題不僅存在於 DSPy 或 Jina；回想 TensorFlow 從 0.x 到 1.x 版本間引入的眾多概念和抽象。我認為這個問題經常出現在軟體框架的早期階段，當時為了<strong>確保最大程度的準確性和可重現性，往往直接將學術概念反映在程式碼庫中</strong>。然而，並非所有用戶都重視這種細緻的抽象，有些人偏好簡單的單行指令，有些則需要更大的靈活性。我在 2020 年的一篇部落格文章中詳細討論了軟體框架中的抽象問題，有興趣的讀者可以參考。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://hanxiao.io/2020/08/02/Layer-of-Abstraction-when-Building-Tensorflow-for-Search/?ref=jina-ai-gmbh.ghost.io#layer-of-abstraction\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Layer of Abstraction When Building \"Tensorflow\" for Search · Han Xiao Tech Blog - Neural Search &amp; AI Engineering</div><div class=\"kg-bookmark-description\">Since Feb. 2020, I started a new venture called Jina AI. Our mission is to build an open-source neural search ecosystem for businesses and developers, ... · Han Xiao</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://hanxiao.io/wechaticon.png\" alt=\"\"><span class=\"kg-bookmark-author\">logo</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://hanxiao.io/2020/08/02/Layer-of-Abstraction-when-Building-Tensorflow-for-Search/blog-abstraction-banner.jpg\" alt=\"\"></div></a></figure><p>其次，DSPy 的文檔在一致性方面有時顯得不足。像是 <code>module</code> 和 <code>program</code>、<code>teleprompter</code> 和 <code>optimizer</code>，或是 <code>optimize</code> 和 <code>compile</code>（有時也被稱為 <code>training</code> 或 <code>bootstrapping</code>）等術語被交替使用，增加了混亂。因此，我最初使用 DSPy 時花了很多時間來理解它具體 <code>optimizes</code> 什麼，以及 <code>bootstrapping</code> 過程到底是什麼。</p><p>儘管存在這些障礙，當你深入研究 DSPy 並重新閱讀文檔時，你可能會經歷一些頓悟的時刻，開始理解它的獨特術語與 PyTorch 等框架中熟悉的概念之間的聯繫。但是，DSPy 無疑在未來版本中有改進的空間，特別是在讓那些沒有 PyTorch 背景的提示工程師更容易上手方面。</p><h2 id=\"common-stumbling-blocks-for-dspy-newbies\">DSPy 新手常見的障礙</h2><p>在下面的章節中，我整理了一份最初讓我在學習 DSPy 時感到困惑的問題清單。我希望分享這些見解能幫助其他學習者解決類似的挑戰。</p><h3 id=\"what-are-teleprompter-optimization-and-compile-whats-exactly-being-optimized-in-dspy\">什麼是 <code>teleprompter</code>、<code>optimization</code> 和 <code>compile</code>？DSPy 究竟在優化什麼？</h3><p>在 DSPy 中，\"Teleprompters\" 是優化器（看起來 <a href=\"https://twitter.com/lateinteraction?ref=jina-ai-gmbh.ghost.io\">@lateinteraction</a> 正在更新文檔和代碼以clarify 這一點）。<code>compile</code> 函數是這個優化器的核心，類似於調用 <code>optimizer.optimize()</code>。可以將其視為 DSPy 中的訓練過程。這個 <code>compile()</code> 過程旨在調優：</p><ul><li>少樣本示範，</li><li>指令，</li><li>LLM 的權重</li></ul><p>然而，大多數 DSPy 入門教程不會深入探討權重和指令調優，這就引出了下一個問題。</p><h3 id=\"whats-bootstrap-in-dspy-all-about\">DSPy 中的 <code>bootstrap</code> 是什麼？</h3><p>Bootstrap 指的是為少樣本情境學習自動生成示範的過程，這是 <code>compile()</code> 過程（即我上面提到的優化/訓練）的重要組成部分。這些少樣本示範是從用戶提供的標註數據中生成的；一個示範通常包括輸入、輸出、推理過程（例如在思維鏈中），以及中間輸入和輸出（用於多階段提示）。當然，高質量的少樣本示範對於輸出質量至關重要。為此，DSPy 允許用戶定義度量函數來確保只選擇符合特定標準的示範，這就引出了下一個問題。</p><h3 id=\"whats-dspy-metric-function\">什麼是 DSPy 度量函數？</h3><p>通過實際使用 DSPy 的經驗，我認為度量函數需要比目前文檔中更多的關注。DSPy 中的度量函數在評估和訓練階段都扮演著重要角色，因為它的隱式特性（由 <code>trace=None</code> 控制），它也同時作為「損失」函數：</p><pre><code class=\"language-python\">def keywords_match_jaccard_metric(example, pred, trace=None):  \n    # Jaccard similarity between example keywords and predicted keywords  \n    A = set(normalize_text(example.keywords).split())  \n    B = set(normalize_text(pred.keywords).split())  \n    j = len(A &amp; B) / len(A | B)\n    if trace is not None:\n        # act as a \"loss\" function\n        return j  \n    return j &gt; 0.8  # act as evaluation</code></pre><p>這種方法與傳統機器學習有顯著不同，在傳統機器學習中，損失函數通常是連續且可微的（例如 hinge/MSE），而評估指標可能完全不同且是離散的（例如 NDCG）。在 DSPy 中，評估和損失函數在度量函數中是統一的，它可以是離散的，且大多數情況下返回布爾值。度量函數甚至可以整合 LLM！在下面的例子中，我使用 LLM 實現了一個模糊匹配，用於判斷預測值和標準答案在數量級上是否相似，例如「100 萬美元」和「$1M」會返回 true。</p><pre><code class=\"language-python\">class Assess(dspy.Signature):  \n    \"\"\"Assess the if the prediction is in the same magnitude to the gold answer.\"\"\"  \n  \n    gold_answer = dspy.InputField(desc='number, could be in natural language')  \n    prediction = dspy.InputField(desc='number, could be in natural language')  \n    assessment = dspy.OutputField(desc='yes or no, focus on the number magnitude, not the unit or exact value or wording')  \n  \ndef same_magnitude_correct(example, pred, trace=None):  \n    return dspy.Predict(Assess)(gold_answer=example.answer, prediction=pred.answer).assessment.lower() == 'yes'</code></pre><p>度量函數雖然很強大，但它顯著影響了 DSPy 的使用體驗，不僅決定了最終的品質評估，還會影響優化的結果。設計良好的度量函數可以導致優化的 prompts，而設計不當的度量函數則可能導致優化失敗。當用 DSPy 處理新問題時，你可能會發現在設計邏輯（即 <code>DSPy.Module</code>）和度量函數上花費的時間差不多。對新手來說，這種需要同時關注邏輯和度量的雙重焦點可能會令人卻步。</p><h3 id=\"bootstrapped-0-full-traces-after-20-examples-in-round-0-what-does-this-mean\"><code>\"Bootstrapped 0 full traces after 20 examples in round 0\"</code> 這是什麼意思？</h3><p>這個在 <code>compile()</code> 過程中悄悄出現的訊息值得你高度關注，因為它本質上意味著優化/編譯失敗了，你得到的 prompt 並不比簡單的 few-shot 更好。哪裡出錯了？我總結了一些幫助你在遇到這種訊息時除錯 DSPy 程式的提示：</p><h4 id=\"your-metric-function-is-incorrect\">你的度量函數不正確</h4><p>在 <code>BootstrapFewShot(metric=your_metric)</code> 中使用的函數 <code>your_metric</code> 是否正確實作？進行一些單元測試。<code>your_metric</code> 是否有返回 <code>True</code>，還是總是返回 <code>False</code>？注意，返回 <code>True</code> 很重要，因為這是 DSPy 判斷 bootstrapped 範例為\"成功\"的標準。如果你將每個評估都返回 <code>True</code>，那麼每個範例在 bootstrapping 中都會被視為\"成功\"！當然，這並不理想，但這就是你如何調整度量函數的嚴格程度來改變 <code>\"Bootstrapped 0 full traces\"</code> 的結果。注意，雖然 DSPy 文檔中提到度量也可以返回標量值，但在查看底層程式碼後，我不建議新手這麼做。</p><h4 id=\"your-logic-dspymodule-is-incorrect\">你的邏輯（<code>DSPy.Module</code>）不正確</h4><p>如果度量函數是正確的，那麼你需要檢查你的邏輯 <code>dspy.Module</code> 是否正確實作。首先，確認每個步驟的 <a href=\"https://dspy-docs.vercel.app/docs/building-blocks/signatures?ref=jina-ai-gmbh.ghost.io\">DSPy signature</a> 是否正確指定。像 <code>dspy.Predict('question-&gt;answer')</code> 這樣的內聯 signatures 很容易使用，但為了品質考量，我強烈建議使用<a href=\"https://dspy-docs.vercel.app/docs/building-blocks/signatures?ref=jina-ai-gmbh.ghost.io#class-based-dspy-signatures\">基於類別的 signatures</a>。具體來說，為類別添加一些描述性的文檔字串，填寫 <code>InputField</code> 和 <code>OutputField</code> 的描述欄位—這些都為語言模型提供了關於每個欄位的提示。下面我實作了兩個用於解決<a href=\"https://en.wikipedia.org/wiki/Fermi_problem?ref=jina-ai-gmbh.ghost.io\">費米問題</a>的多階段 <code>DSPy.Module</code>，一個使用內聯 signature，一個使用基於類別的 signature。</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-python\">class FermiSolver(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.step1 = dspy.Predict('question -&gt; initial_guess')\n        self.step2 = dspy.Predict('question, initial_guess -&gt; calculated_estimation')\n        self.step3 = dspy.Predict('question, initial_guess, calculated_estimation -&gt; variables_and_formulae')\n        self.step4 = dspy.ReAct('question, initial_guess, calculated_estimation, variables_and_formulae -&gt; gathering_data')\n        self.step5 = dspy.Predict('question, initial_guess, calculated_estimation, variables_and_formulae, gathering_data -&gt; answer')\n\n    def forward(self, q):\n        step1 = self.step1(question=q)\n        step2 = self.step2(question=q, initial_guess=step1.initial_guess)\n        step3 = self.step3(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation)\n        step4 = self.step4(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae)\n        step5 = self.step5(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae, gathering_data=step4.gathering_data)\n        return step5</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">僅使用內聯 signature 的費米問題求解器</span></p></figcaption></figure><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-python\">class FermiStep1(dspy.Signature):\n    question = dspy.InputField(desc='Fermi problems involve the use of estimation and reasoning')\n    initial_guess = dspy.OutputField(desc='Have a guess – don't do any calculations yet')\n\nclass FermiStep2(FermiStep1):\n    initial_guess = dspy.InputField(desc='Have a guess – don't do any calculations yet')\n    calculated_estimation = dspy.OutputField(desc='List the information you'll need to solve the problem and make some estimations of the values')\n\nclass FermiStep3(FermiStep2):\n    calculated_estimation = dspy.InputField(desc='List the information you'll need to solve the problem and make some estimations of the values')\n    variables_and_formulae = dspy.OutputField(desc='Write a formula or procedure to solve your problem')\n\nclass FermiStep4(FermiStep3):\n    variables_and_formulae = dspy.InputField(desc='Write a formula or procedure to solve your problem')\n    gathering_data = dspy.OutputField(desc='Research, measure, collect data and use your formula. Find the smallest and greatest values possible')\n\nclass FermiStep5(FermiStep4):\n    gathering_data = dspy.InputField(desc='Research, measure, collect data and use your formula. Find the smallest and greatest values possible')\n    answer = dspy.OutputField(desc='the final answer, must be a numerical value')\n\nclass FermiSolver2(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.step1 = dspy.Predict(FermiStep1)\n        self.step2 = dspy.Predict(FermiStep2)\n        self.step3 = dspy.Predict(FermiStep3)\n        self.step4 = dspy.Predict(FermiStep4)\n        self.step5 = dspy.Predict(FermiStep5)\n\n    def forward(self, q):\n        step1 = self.step1(question=q)\n        step2 = self.step2(question=q, initial_guess=step1.initial_guess)\n        step3 = self.step3(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation)\n        step4 = self.step4(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae)\n        step5 = self.step5(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae, gathering_data=step4.gathering_data)\n        return step5</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">使用基於類別的 signature 並對每個欄位有更全面描述的費米問題求解器。</span></p></figcaption></figure><p>另外，檢查 <code>def forward(self, )</code> 部分。對於多階段的 Modules，確保上一步的輸出（或像在 <code>FermiSolver</code> 中的所有輸出）都作為輸入傳遞給下一步。</p><h4 id=\"your-problem-is-just-too-hard\">你的問題太難了</h4><p>如果度量和模組都看起來正確，那麼可能你的問題太具挑戰性，而你實作的邏輯不足以解決它。因此，DSPy 發現以你的邏輯和度量函數無法 bootstrap 任何示例。在這種情況下，你可以考慮以下選項：</p><ul><li><strong>使用更強大的 LM。</strong>例如，將學生的 LM 從 <code>gpt-35-turbo-instruct</code> 替換為 <code>gpt-4-turbo</code>，使用更強大的 LM 作為老師。這通常相當有效。畢竟，更強大的模型意味著更好的 prompts 理解能力。</li><li><strong>改進你的邏輯。</strong>在你的 <code>dspy.Module</code> 中添加或替換一些步驟為更複雜的步驟。例如，將 <code>Predict</code> 替換為 <code>ChainOfThought</code> <code>ProgramOfThought</code>，添加 <code>Retrieval</code> 步驟。</li><li><strong>添加更多訓練範例。</strong>如果 20 個範例不夠，那就瞄準 100 個！你可以期望有一個範例通過度量檢查並被 <code>BootstrapFewShot</code> 選中。</li><li><strong>重新構思問題。</strong>通常，當問題表述不正確時，問題就會變得無法解決。但如果你換個角度看問題，事情可能會變得更簡單和明顯。</li></ul><p>在實踐中，這個過程涉及試錯的結合。例如，我處理了一個特別具有挑戰性的問題：根據兩到三個關鍵字生成類似 Google Material Design 圖標的 SVG 圖標。我的初始策略是使用一個簡單的 <code>DSPy.Module</code>，它使用 <code>dspy.ChainOfThought('keywords -&gt; svg')</code>，並配合一個度量函數來評估生成的 SVG 和真實 Material Design SVG 之間的視覺相似度，類似於 pHash 演算法。我從 20 個訓練範例開始，但在第一輪後，我得到了 <code>\"Bootstrapped 0 full traces after 20 examples in round 0\"</code>，表示優化失敗。通過將數據集增加到 100 個範例，修改我的模組以包含多個階段，並調整度量函數的閾值，我最終實現了 2 個 bootstrapped 示例並成功獲得了一些優化的 prompts。</p>",
  "comment_id": "66077bf0a5c39b0001044181",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--7-.png",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-03-30T03:41:52.000+01:00",
  "updated_at": "2024-04-23T10:46:48.000+02:00",
  "published_at": "2024-03-30T06:22:42.000+01:00",
  "custom_excerpt": "Heads up, Bay Area guys ditched their AVP already and buzz about DSPy now. Could DSPy be the new go-to framework for prompt engineering after LangChain and LlamaIndex?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/dspy-not-your-average-prompt-engineering/",
  "excerpt": "注意了，舊金山灣區的開發者們已經放棄了 AVP，現在都在談論 DSPy。在 LangChain 和 LlamaIndex 之後，DSPy 會成為新一代的 prompt engineering 框架嗎？",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Screenshot of a Tetris-like game with \"Score: 40\" and \"Press Start 2P\" text on display.",
  "feature_image_caption": null
}