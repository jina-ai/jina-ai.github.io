{
  "slug": "what-is-colbert-and-late-interaction-and-why-they-matter-in-search",
  "id": "65d3a2134a32310001f5b71b",
  "uuid": "726c942b-f6a7-4c89-a0ad-39aaad98d02f",
  "title": "什麼是 ColBERT 和晚期交互？為什麼它們在搜尋中如此重要？",
  "html": "<figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/jina-colbert-v2-multilingual-late-interaction-retriever-for-embedding-and-reranking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Jina ColBERT v2：用於嵌入和重排序的多語言後期互動檢索器</div><div class=\"kg-bookmark-description\">Jina ColBERT v2 支援 89 種語言，具有卓越的檢索性能、用戶可控的輸出維度，以及 8192 的 token 長度。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/colbert-banner.jpg\" alt=\"\"></div></a><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">更新：在 2024 年 8 月 31 日，我們發布了 Jina-ColBERT 的第二個版本，改進了性能，支援 89 種語言，並具有靈活的輸出維度。請查看發布文章了解更多詳情。</span></p></figcaption></figure><p>上週五，Jina AI 在 Hugging Face 上發布的 <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">ColBERT model</a> 在 AI 社群中引起了極大的關注，特別是在 Twitter/X 上。雖然許多人都熟悉突破性的 BERT 模型，但 ColBERT 引發的熱議讓一些人感到疑惑：在擁擠的資訊檢索技術領域中，是什麼讓 ColBERT 脫穎而出？為什麼 AI 社群對 8192 長度的 ColBERT 如此興奮？本文將深入探討 ColBERT 和 ColBERTv2 的細節，強調其設計、改進以及 ColBERT 後期互動的驚人效能。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">輕鬆提高搜索相關性和 RAG 準確性</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a></figure><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Introducing jina-colbert-v1-en. It takes late interactions &amp; token-level embeddings of ColBERTv2 and has better zero-shot performance on many tasks (in and out-of-domain). Now on <a href=\"https://twitter.com/huggingface?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">@huggingface</a> under Apache 2.0 licence<a href=\"https://t.co/snVGgI753H?ref=jina-ai-gmbh.ghost.io\">https://t.co/snVGgI753H</a></p>— Jina AI (@JinaAI_) <a href=\"https://twitter.com/JinaAI_/status/1758503072999907825?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">February 16, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><h2 id=\"what-is-colbert\">什麼是 ColBERT？</h2><p>\"ColBERT\" 代表 <strong>Co</strong>ntextualized <strong>L</strong>ate Interaction over <strong>BERT</strong>，這是一個源自史丹佛大學的模型，它利用了 BERT 的深度語言理解能力，同時引入了一種新穎的互動機制。這種被稱為<strong>後期互動</strong>的機制，通過在檢索過程的最後階段之前分別處理查詢和文件，實現了高效且精確的檢索。具體來說，該模型有兩個版本：</p><ul><li><strong>ColBERT</strong>：初始模型是 <a href=\"https://x.com/lateinteraction?s=20&ref=jina-ai-gmbh.ghost.io\"><strong>Omar Khattab</strong></a><strong> 和 Matei Zaharia</strong> 的心血結晶，通過論文\"ColBERT: Efficient and Effective Passage Search via Contextualized Late Interaction over BERT\"提出了一種全新的資訊檢索方法。他們的研究成果發表於 SIGIR 2020。</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2004.12832?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERT：通過 BERT 上下文化後期互動實現高效且有效的段落搜索</div><div class=\"kg-bookmark-description\">自然語言理解（NLU）的最新進展正在推動資訊檢索（IR）的快速發展，這主要歸功於對深度語言模型（LMs）在文檔排序方面的微調。雖然這些基於 LMs 的排序模型非常有效，但它們將計算成本提高了數個數量級，特別是因為它們必須將每個查詢-文檔對通過一個龐大的神經網絡來計算單個相關性分數。為了解決這個問題，我們提出了 ColBERT，這是一個為高效檢索而改編深度 LMs（特別是 BERT）的新型排序模型。ColBERT 引入了一種後期互動架構，它使用 BERT 獨立編碼查詢和文檔，然後使用一個廉價但強大的互動步驟來模擬它們的細粒度相似性。通過延遲但保留這種細粒度互動，ColBERT 可以利用深度 LMs 的表達能力，同時獲得離線預計算文檔表示的能力，大大加快了查詢處理速度。除了降低重新排序傳統模型檢索文檔的成本外，ColBERT 的剪枝友好互動機制還能夠直接從大型文檔集合中利用向量相似性索引進行端到端檢索。我們使用兩個最新的段落搜索數據集對 ColBERT 進行了廣泛評估。結果表明，ColBERT 的效果與現有的基於 BERT 的模型相當（並且優於每個非 BERT 基準），同時執行速度快兩個數量級，每次查詢所需的 FLOPs 減少四個數量級。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Omar Khattab</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">介紹\"後期互動\"的原始 ColBERT 論文。</span></p></figcaption></figure><ul><li><strong>ColBERTv2</strong>：在原有工作的基礎上，<strong>Omar Khattab</strong> 繼續他的研究，與 <strong>Barlas Oguz、Matei Zaharia 和 Michael S. Bernstein</strong> 合作，在 SIGIR 2021 上發表了\"ColBERTv2: Effective and Efficient Retrieval via Lightweight Late Interaction\"。ColBERT 的這次迭代解決了之前的限制，並引入了關鍵改進，如<strong>去噪監督</strong>和<strong>殘差壓縮</strong>，提升了模型的檢索效能和存儲效率。</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2112.01488?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERTv2：通過輕量級後期互動實現有效且高效的檢索</div><div class=\"kg-bookmark-description\">神經資訊檢索（IR）極大地改進了搜索和其他知識密集型語言任務。雖然許多神經 IR 方法將查詢和文檔編碼為單向量表示，但後期互動模型在每個 token 的粒度上產生多向量表示，並將相關性建模分解為可擴展的 token 級計算。這種分解已被證明使後期互動更有效，但它將這些模型的空間占用增加了一個數量級。在本工作中，我們引入了 ColBERTv2，這是一個將積極的殘差壓縮機制與去噪監督策略相結合的檢索器，同時改進了後期互動的質量和空間占用。我們在廣泛的基準測試中評估了 ColBERTv2，在訓練域內外建立了最先進的質量，同時將後期互動模型的空間占用減少了 6-10 倍。</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Keshav Santhanam</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">ColBERTv2 添加去噪監督和殘差壓縮來改善訓練數據質量並減少空間占用。</span></p></figcaption></figure><h2 id=\"understand-colberts-design\">理解 ColBERT 的設計</h2><p>鑑於 ColBERTv2 的架構與原始 ColBERT 非常相似，其主要創新主要圍繞訓練技術和壓縮機制，我們首先將深入探討原始 ColBERT 的基礎方面。</p><h3 id=\"what-is-late-interaction-in-colbert\">什麼是 ColBERT 中的後期互動？</h3><p>\"互動\"指的是通過比較查詢和文檔的表示來評估它們之間相關性的過程。</p><p>\"<em>後期互動</em>\"是 ColBERT 的精髓。這個術語源自模型的架構和處理策略，其中查詢和文檔表示的互動發生在處理過程的後期，在兩者都被獨立編碼之後。這與\"<em>早期互動</em>\"模型形成對比，在早期互動模型中，查詢和文檔嵌入在較早階段就開始互動，通常是在模型編碼之前或期間。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Interaction Type</th>\n<th>Models</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Early Interaction</td>\n<td>BERT, ANCE, DPR, Sentence-BERT, DRMM, KNRM, Conv-KNRM, etc.</td>\n</tr>\n<tr>\n<td>Late Interaction</td>\n<td>ColBERT, ColBERTv2</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>早期互動可能會增加計算複雜性，因為它需要考慮所有可能的查詢-文檔對，這使得它在大規模應用中效率較低。</p><p>像 ColBERT 這樣的後期互動模型通過允許預先計算文檔表示並在最後採用更輕量級的互動步驟來優化效率和可擴展性，這種互動步驟專注於已編碼的表示。這種設計選擇能夠實現更快的檢索時間和更低的計算需求，使其更適合處理大型文檔集合。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/colbert-blog-interaction.svg\" class=\"kg-image\" alt=\"Diagram illustrating query-document similarity with models for no, partial, and late interaction, including language mode rep\" loading=\"lazy\" width=\"300\" height=\"143\"><figcaption><span style=\"white-space: pre-wrap;\">神經 IR 中查詢與文件交互範式的示意圖，最左側為 ColBERT 的後期交互方式。</span></figcaption></figure><h3 id=\"no-interaction-cosine-similarity-of-document-and-query-embeddings\">無交互：文件和查詢嵌入的餘弦相似度</h3><p>許多實用的向量資料庫和神經搜尋解決方案都依賴於文件和查詢嵌入之間的快速餘弦相似度匹配。雖然這種被稱為「無交互」或「非交互式」的方法在直觀性和計算效率方面很有吸引力，但與那些包含某種形式的查詢和文件交互的模型相比，其表現被發現較為遜色。</p><p>「無交互」方法的核心限制在於其無法捕捉查詢和文件詞彙之間的複雜細微差別和關係。信息檢索的本質是理解並匹配查詢背後的意圖與文件中的內容。這個過程通常需要對相關詞彙進行深入的、上下文相關的理解，而單一的、聚合的文件和查詢嵌入很難提供這種理解。</p><h2 id=\"query-and-document-encoders-in-colbert\">ColBERT 中的查詢和文件編碼器</h2><p>ColBERT 的編碼策略建立在以深度上下文語言理解著稱的 BERT 模型基礎上。該模型為查詢或文件中的每個詞元生成密集向量表示，<strong>分別為查詢和文件創建上下文化嵌入的集合。</strong>這促進了在後期交互階段對其嵌入進行細緻的比較。</p><h3 id=\"query-encoder-of-colbert\">ColBERT 的查詢編碼器</h3><p>對於包含詞元 ${q_1, q_2, ..., q_l}$ 的查詢 $Q$，處理過程首先將 $Q$ 分詞為基於 BERT 的 WordPiece 詞元，並在前面加上特殊的 <code>[Q]</code> 詞元。這個 <code>[Q]</code> 詞元位於 BERT 的 <code>[CLS]</code> 詞元之後，用於標示查詢的開始。</p><p>如果查詢長度短於預定義的詞元數 $N_q$，則用 <code>[mask]</code> 詞元填充至 $N_q$；否則截斷至前 $N_q$ 個詞元。填充後的序列經過 BERT，然後是 CNN（卷積神經網絡）和正規化。輸出是一組嵌入向量，表示如下 $\\mathbf{E}_q$：<br>$$\\mathbf{E}_q := \\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[Q]},q_0,q_1,\\ldots,q_l\\mathtt{[mask]},\\mathtt{[mask]},\\ldots,\\mathtt{[mask]}\\right)\\right)$$</p><h3 id=\"document-encoder-of-colbert\">ColBERT 的文件編碼器</h3><p>同樣，對於包含詞元 ${d_1, d_2, ..., d_n}$ 的文件 $D$，在前面加上 <code>[D]</code> 詞元以標示文件的開始。這個序列無需填充，經過相同的處理過程，得到一組嵌入向量，表示如下 $\\mathbf{E}_d$：<br>$$\\mathbf{E}_d := \\mathrm{Filter}\\left(\\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[D]},d_0,d_1,...,d_n\\right)\\right)\\right)$$</p><p>使用 <code>[mask]</code> 詞元填充查詢（在論文中稱為<strong>查詢增強</strong>）確保了所有查詢的長度統一，便於批次處理。<code>[Q]</code> 和 <code>[D]</code> 詞元明確標記查詢和文件的開始，幫助模型區分這兩種輸入。</p><h3 id=\"comparing-colbert-to-cross-encoders\">比較 ColBERT 與交叉編碼器</h3><p>交叉編碼器同時處理查詢和文件對，使其具有高準確性，但由於評估每個可能的配對的計算成本，在大規模任務中效率較低。它們在需要精確評分句子對的特定場景中表現出色，如語意相似度任務或詳細內容比較。然而，這種設計限制了它們在需要從大型數據集快速檢索的情況下的應用，這些情況需要預計算嵌入和高效的相似度計算。</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/ce-vs-colbert.svg\" class=\"kg-image\" alt=\"Diagrams comparing &quot;Cross Encoder: Early all-to-all interaction&quot; and &quot;ColBERT: Late interaction&quot; with labeled Query and Docum\" loading=\"lazy\" width=\"210\" height=\"150\"></figure><p>相比之下，ColBERT 的後期交互模型允許預計算文件嵌入，大大加快了檢索過程，同時不影響語意分析的深度。這種方法雖然與交叉編碼器的直接方法相比似乎不夠直觀，但為即時和大規模信息檢索任務提供了可擴展的解決方案。它代表了計算效率和交互建模質量之間的策略性妥協。</p><h2 id=\"finding-the-top-k-documents-using-colbert\">使用 ColBERT 尋找前 K 個文件</h2><p>一旦我們得到查詢和文件的嵌入，找到最相關的前 K 個文件就變得直接了（但不像計算兩個向量的餘弦那麼直接）。</p><p>關鍵操作包括批量點積以計算詞元間相似度，在文件詞元中進行最大池化以找到每個查詢詞元的最高相似度，然後對查詢詞元進行求和得到總文件分數，最後根據這些分數對文件進行排序。偽 PyTorch 代碼如下：</p><pre><code class=\"language-python\">import torch\n\ndef compute_relevance_scores(query_embeddings, document_embeddings, k):\n    \"\"\"\n    Compute relevance scores for top-k documents given a query.\n    \n    :param query_embeddings: Tensor representing the query embeddings, shape: [num_query_terms, embedding_dim]\n    :param document_embeddings: Tensor representing embeddings for k documents, shape: [k, max_doc_length, embedding_dim]\n    :param k: Number of top documents to re-rank\n    :return: Sorted document indices based on their relevance scores\n    \"\"\"\n    \n    # Ensure document_embeddings is a 3D tensor: [k, max_doc_length, embedding_dim]\n    # Pad the k documents to their maximum length for batch operations\n    # Note: Assuming document_embeddings is already padded and moved to GPU\n    \n    # Compute batch dot-product of Eq (query embeddings) and D (document embeddings)\n    # Resulting shape: [k, num_query_terms, max_doc_length]\n    scores = torch.matmul(query_embeddings.unsqueeze(0), document_embeddings.transpose(1, 2))\n    \n    # Apply max-pooling across document terms (dim=2) to find the max similarity per query term\n    # Shape after max-pool: [k, num_query_terms]\n    max_scores_per_query_term = scores.max(dim=2).values\n    \n    # Sum the scores across query terms to get the total score for each document\n    # Shape after sum: [k]\n    total_scores = max_scores_per_query_term.sum(dim=1)\n    \n    # Sort the documents based on their total scores\n    sorted_indices = total_scores.argsort(descending=True)\n    \n    return sorted_indices\n</code></pre><p>請注意，這個程序在訓練和推理時的重新排序中都會使用。ColBERT 模型使用成對排序損失進行訓練，其中訓練數據由三元組 $(q, d^+, d^-)$ 組成，其中 $q$ 代表查詢，$d^+$ 是與查詢相關的（正面）文件，$d^-$ 是不相關的（負面）文件。模型的目標是學習表示，使得 $q$ 和 $d^+$ 之間的相似度分數高於 $q$ 和 $d^-$ 之間的分數。</p><p>訓練目標可以數學表示為最小化以下損失函數：$$\\mathrm{Loss} = \\max(0, 1 - S(q, d^+) + S(q, d^-))$$</p><p>，其中 $S(q, d)$ 表示 ColBERT 計算的查詢 $q$ 和文件 $d$ 之間的相似度分數。這個分數是通過聚合查詢和文件之間最佳匹配嵌入的最大相似度分數得到的，遵循模型架構中描述的後期交互模式。這種方法確保模型被訓練為能夠區分給定查詢的相關和不相關文件，通過鼓勵正面和負面文件對的相似度分數有更大的差距。</p><h3 id=\"denoised-supervision-in-colbertv2\">ColBERTv2 中的降噪監督</h3><p>ColBERTv2 中的降噪監督通過選擇具有挑戰性的負面樣本並利用交叉編碼器進行知識蒸餾來改進原始訓練過程。這種優化訓練數據質量的複雜方法包括以下步驟：</p><ol><li><strong>初始訓練</strong>：使用 MS MARCO 數據集的官方三元組，包含查詢、相關文件和不相關文件。</li><li><strong>索引和檢索</strong>：使用 ColBERTv2 的壓縮來索引訓練段落，然後為每個查詢檢索前 k 個段落。</li><li><strong>交叉編碼器重排序</strong>：通過 MiniLM 交叉編碼器的重排序來增強段落選擇，將其分數蒸餾到 ColBERTv2 中。</li><li><strong>形成訓練元組</strong>：生成 w 路元組用於訓練，同時包含高排名和低排名的段落以創建具有挑戰性的範例。</li><li><strong>迭代優化</strong>：重複該過程以持續改進難例選擇，從而提高模型性能。</li></ol><p>請注意，這個過程代表了對 ColBERT 訓練制度的複雜增強，而不是對其架構的根本改變。</p><h3 id=\"hyperparameters-of-colbert\">ColBERT 的超參數</h3><p>以下是 ColBERT 的超參數總結：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>超參數</th>\n<th>最佳選擇</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>學習率</td>\n<td>3 x 10^{-6}</td>\n<td>為確保穩定和有效的模型更新而選用於微調。</td>\n</tr>\n<tr>\n<td>批次大小</td>\n<td>32</td>\n<td>在計算效率和每次更新獲取足夠資訊量之間取得平衡。</td>\n</tr>\n<tr>\n<td>每個查詢的嵌入數量 (Nq)</td>\n<td>32</td>\n<td>固定數量以確保查詢間具有一致的表示大小，有助於高效處理。</td>\n</tr>\n<tr>\n<td>嵌入維度 (m)</td>\n<td>128</td>\n<td>經證實在表示能力和計算效率之間提供良好平衡。</td>\n</tr>\n<tr>\n<td>訓練迭代次數</td>\n<td>200k (MS MARCO), 125k (TREC CAR)</td>\n<td>根據數據集特性調整，確保充分學習同時避免過擬合。</td>\n</tr>\n<tr>\n<td>每維度嵌入位元組數</td>\n<td>4 (重排序), 2 (端到端排序)</td>\n<td>在精確度和空間效率之間權衡，並考慮應用場景（重排序 vs. 端到端）。</td>\n</tr>\n<tr>\n<td>向量相似度函數</td>\n<td>餘弦 (重排序), (平方) L2 (端到端)</td>\n<td>根據各自檢索場景的性能和效率選擇。</td>\n</tr>\n<tr>\n<td>FAISS 索引分區 (P)</td>\n<td>2000</td>\n<td>決定搜索空間分區的粒度，影響搜索效率。</td>\n</tr>\n<tr>\n<td>搜索最近分區數 (p)</td>\n<td>10</td>\n<td>在搜索廣度和計算效率之間取得平衡。</td>\n</tr>\n<tr>\n<td>每個嵌入的子向量數 (s)</td>\n<td>16</td>\n<td>影響量化的粒度，同時影響搜索速度和記憶體使用。</td>\n</tr>\n<tr>\n<td>每維度索引表示</td>\n<td>16 位元值</td>\n<td>在端到端檢索的第二階段中選用，用於管理準確性和空間的權衡。</td>\n</tr>\n<tr>\n<td>編碼器層數</td>\n<td>12 層 BERT</td>\n<td>在上下文理解深度和計算效率之間取得最佳平衡。</td>\n</tr>\n<tr>\n<td>最大查詢長度</td>\n<td>128</td>\n<td>查詢編碼器處理的最大標記數。<b>在 Jina-ColBERT 模型中得到擴展。</b></td>\n</tr>\n<tr>\n<td>最大文件長度</td>\n<td>512</td>\n<td>文件編碼器處理的最大標記數。<b>在 Jina-ColBERT 模型中擴展至 8192。</b></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"the-indexing-strategy-of-colbert\">ColBERT 的索引策略</h2>\n<p>與將每個文件編碼為一個嵌入向量的基於表示的方法不同，<strong>ColBERT 將文件（和查詢）編碼為嵌入向量集合，文件中的每個標記都有自己的嵌入。</strong>這種方法本質上意味著對於較長的文件，需要儲存更多的嵌入，<strong>這是原始 ColBERT 的一個痛點，後來在 ColBERTv2 中得到解決。</strong></p>\n<p>有效管理這一問題的關鍵在於 ColBERT 使用向量資料庫（如 <a href=\"https://github.com/facebookresearch/faiss?ref=jina-ai-gmbh.ghost.io\">FAISS</a>）進行索引和檢索，以及其詳細的索引過程，該過程旨在高效處理大量數據。原始 ColBERT 論文提到了幾種提高索引和檢索效率的策略，包括：</p>\n<ul>\n<li><strong>離線索引</strong>：文件表示在離線計算，允許預先計算和儲存文件嵌入。此過程利用批次處理和 GPU 加速來高效處理大量文件集合。</li>\n<li><strong>嵌入儲存</strong>：文件嵌入可以使用 32 位元或 16 位元值來儲存每個維度，在精確度和儲存需求之間提供權衡。這種靈活性使 ColBERT 能夠在效能（檢索性能）和效率（儲存和計算成本）之間保持平衡。</li>\n</ul>\n<p>在 ColBERTv2 中引入的<strong>殘差壓縮</strong>（在原始 ColBERT 中不存在）技術，通過有效捕捉和儲存與固定參考中心點的差異，在保持品質的同時將模型的空間佔用減少了 6-10 倍，這是一個關鍵突破。</p>\n<h2 id=\"effectiveness-and-efficiency-of-colbert\">ColBERT 的效能和效率</h2>\n<p>人們可能最初會認為將 BERT 的深度上下文理解整合到搜索中本質上需要大量計算資源，由於高延遲和計算成本，使這種方法在實時應用中較不可行。然而，ColBERT 通過其創新的後期交互機制挑戰並推翻了這一假設。以下是一些值得注意的要點：</p>\n<ol>\n<li><strong>顯著的效率提升</strong>：與傳統的基於 BERT 的排序模型相比，ColBERT 在計算成本（FLOPs）和延遲方面實現了數量級的減少。具體來說，對於給定的模型大小（如 12 層\"基礎\"transformer 編碼器），ColBERT 不僅匹配而且在某些情況下超越了 BERT 基礎模型的效能，且計算需求大幅降低。例如，在重排序深度 <em>k</em>=10 時，BERT 需要的 FLOPs 幾乎是 ColBERT 的 180 倍；隨著 <em>k</em> 增加，這個差距進一步擴大，在 <em>k</em>=1000 時達到 13900 倍，在 <em>k</em>=2000 時甚至達到 23000 倍。</li>\n<li><strong>端到端檢索中改善的召回率和 MRR@10</strong>：與最初認為查詢和文件表示之間需要更深入的交互（如早期交互模型所見）才能實現高檢索性能的直覺相反，ColBERT 的端到端檢索設置展示了卓越的效能。例如，其 Recall@50 超過了官方 BM25 的 Recall@1000 和幾乎所有其他模型的 Recall@200，突顯了該模型在不直接比較每個查詢-文件對的情況下，從大量集合中檢索相關文件的卓越能力。</li>\n<li><strong>實際應用的實用性</strong>：實驗結果突顯了 ColBERT 在實際情境中的應用價值。其索引處理量和記憶體效率使其適合在幾小時內索引如 MS MARCO 這樣的大型文件集合，同時保持高效能和可管理的空間佔用。這些特質突顯了 ColBERT 適合部署在性能和計算效率都至關重要的生產環境中。</li>\n<li><strong>文件集合規模的可擴展性</strong>：也許最令人驚訝的結論是 ColBERT 在處理大規模文件集合時的可擴展性和效率。該架構允許預計算文件嵌入，並利用高效的批次處理進行查詢-文件交互，使系統能夠隨著文件集合的大小有效擴展。考慮到有效文件檢索所需的複雜性和理解深度，這種可擴展性是反直覺的，展示了 ColBERT 在平衡計算效率和檢索效能方面的創新方法。</li>\n</ol>\n<h2 id=\"using-jina-colbert-v1-en-a-8192-length-colbertv2-model\">使用 <code>jina-colbert-v1-en</code>：一個 8192 長度的 ColBERTv2 模型</h2>\n<p>Jina-ColBERT 專為快速和準確的檢索而設計，支援<a href=\"https://jina.ai/news/jina-ai-launches-worlds-first-open-source-8k-text-embedding-rivaling-openai/?ref=jina-ai-gmbh.ghost.io\">最長 8192 的上下文長度，利用 JinaBERT 的進展</a>，由於其架構增強，允許處理更長的序列。</p>\n<div class=\"kg-card kg-callout-card kg-callout-card-blue\">\n<div class=\"kg-callout-emoji\">💡</div>\n<div class=\"kg-callout-text\">嚴格來說，Jina-ColBERT 支援 8190 個標記的長度。回想一下，在 ColBERT 文件編碼器中，每個文件的開頭都會填充 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">[D],[CLS]</code>。</div>\n</div>\n<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/jina-colbert-v1-en · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://huggingface.co/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://cdn-thumbnails.huggingface.co/social-thumbnails/models/jinaai/jina-colbert-v1-en.png\" alt=\"\"></div></a></figure>\n<h3 id=\"jinas-improvement-over-original-colbert\">Jina 相對於原始 ColBERT 的改進</h3>\n<p>Jina-ColBERT 的主要進展在於其骨幹網路 <code>jina-bert-v2-base-en</code>，它能夠處理顯著更長的上下文（最多 8192 個標記），相比原始使用 <code>bert-base-uncased</code> 的 ColBERT。這種能力對於處理包含大量內容的文件至關重要，能提供更詳細和更具上下文的搜索結果。</p>\n<h3 id=\"jina-colbert-v1-en-performance-comparison-vs-colbertv2\"><code>jina-colbert-v1-en</code> 與 ColBERTv2 的性能比較</h3>\n<p>我們在 BEIR 數據集和偏好長上下文的新 LoCo 基準上評估了 <code>jina-colbert-v1-en</code>，將其與原始 ColBERTv2 實現和非交互式的<code>jina-embeddings-v2-base-en</code> 模型。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>ColBERTv2</th>\n<th>jina-colbert-v1-en</th>\n<th>jina-embeddings-v2-base-en</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arguana</td>\n<td>46.5</td>\n<td><strong>49.4</strong></td>\n<td>44.0</td>\n</tr>\n<tr>\n<td>Climate-Fever</td>\n<td>18.1</td>\n<td>19.6</td>\n<td><strong>23.5</strong></td>\n</tr>\n<tr>\n<td>DBPedia</td>\n<td><strong>45.2</strong></td>\n<td>41.3</td>\n<td>35.1</td>\n</tr>\n<tr>\n<td>FEVER</td>\n<td>78.8</td>\n<td><strong>79.5</strong></td>\n<td>72.3</td>\n</tr>\n<tr>\n<td>FiQA</td>\n<td>35.4</td>\n<td>36.8</td>\n<td><strong>41.6</strong></td>\n</tr>\n<tr>\n<td>HotpotQA</td>\n<td><strong>67.5</strong></td>\n<td>65.9</td>\n<td>61.4</td>\n</tr>\n<tr>\n<td>NFCorpus</td>\n<td>33.7</td>\n<td><strong>33.8</strong></td>\n<td>32.5</td>\n</tr>\n<tr>\n<td>NQ</td>\n<td>56.1</td>\n<td>54.9</td>\n<td><strong>60.4</strong></td>\n</tr>\n<tr>\n<td>Quora</td>\n<td>85.5</td>\n<td>82.3</td>\n<td><strong>88.2</strong></td>\n</tr>\n<tr>\n<td>SCIDOCS</td>\n<td>15.4</td>\n<td>16.9</td>\n<td><strong>19.9</strong></td>\n</tr>\n<tr>\n<td>SciFact</td>\n<td>68.9</td>\n<td><strong>70.1</strong></td>\n<td>66.7</td>\n</tr>\n<tr>\n<td>TREC-COVID</td>\n<td>72.6</td>\n<td><strong>75.0</strong></td>\n<td>65.9</td>\n</tr>\n<tr>\n<td>Webis-touch2020</td>\n<td>26.0</td>\n<td><strong>27.0</strong></td>\n<td>26.2</td>\n</tr>\n<tr>\n<td>LoCo</td>\n<td>74.3</td>\n<td>83.7</td>\n<td><strong>85.4</strong></td>\n</tr>\n<tr>\n<td>Average</td>\n<td>51.7</td>\n<td><strong>52.6</strong></td>\n<td>51.6</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>此表顯示 <code>jina-colbert-v1-en</code> 的卓越效能，特別是在需要較長上下文長度的場景相較於原始的 ColBERTv2。請注意，<code>jina-embeddings-v2-base-en</code> <a href=\"https://arxiv.org/abs/2310.19923?ref=jina-ai-gmbh.ghost.io\">使用了更多訓練資料</a>，而 <code>jina-colbert-v1-en</code> 僅使用 MSMARCO，這可能解釋了 <code>jina-embeddings-v2-base-en</code> 在某些任務上的良好表現。</p><h3 id=\"example-usage-of-jina-colbert-v1-en\">使用 <code>jina-colbert-v1-en</code> 的範例</h3><p>這個程式碼片段概述了使用 Jina-ColBERT 的索引過程，展示了其對長文件的支援。</p><pre><code class=\"language-python\">from colbert import Indexer\nfrom colbert.infra import Run, RunConfig, ColBERTConfig\n\nn_gpu: int = 1  # Set your number of available GPUs\nexperiment: str = \"\"  # Name of the folder where the logs and created indices will be stored\nindex_name: str = \"\"  # The name of your index, i.e. the name of your vector database\n\nif __name__ == \"__main__\":\n    with Run().context(RunConfig(nranks=n_gpu, experiment=experiment)):\n        config = ColBERTConfig(\n          doc_maxlen=8192  # Our model supports 8k context length for indexing long documents\n        )\n        indexer = Indexer(\n          checkpoint=\"jinaai/jina-colbert-v1-en\",\n          config=config,\n        )\n        documents = [\n          \"ColBERT is an efficient and effective passage retrieval model.\",\n          \"Jina-ColBERT is a ColBERT-style model but based on JinaBERT so it can support both 8k context length.\",\n          \"JinaBERT is a BERT architecture that supports the symmetric bidirectional variant of ALiBi to allow longer sequence length.\",\n          \"Jina-ColBERT model is trained on MSMARCO passage ranking dataset, following a very similar training procedure with ColBERTv2.\",\n          \"Jina-ColBERT achieves the competitive retrieval performance with ColBERTv2.\",\n          \"Jina is an easier way to build neural search systems.\",\n          \"You can use Jina-ColBERT to build neural search systems with ease.\",\n          # Add more documents here to ensure the clustering work correctly\n        ]\n        indexer.index(name=index_name, collection=documents)\n</code></pre><h3 id=\"use-jina-colbert-v1-en-in-ragatouille\">在 RAGatouille 中使用 <code>jina-colbert-v1-en</code></h3><p>RAGatouille 是一個新的 Python 函式庫，可以讓在 RAG 流程中使用進階檢索方法變得更容易。它的設計著重於模組化和易於整合，讓使用者能夠無縫地運用最先進的研究成果。RAGatouille 的主要目標是簡化在 RAG 流程中應用像 ColBERT 這樣的複雜模型，讓開發者無需深入了解基礎研究就能利用這些方法。感謝 <a href=\"https://twitter.com/bclavie?ref=jina-ai-gmbh.ghost.io\">Benjamin Clavié</a>，現在您可以輕鬆使用 <code>jina-colbert-v1-en</code>：</p><pre><code class=\"language-python\">from ragatouille import RAGPretrainedModel\n\n# Get your model & collection of big documents ready\nRAG = RAGPretrainedModel.from_pretrained(\"jinaai/jina-colbert-v1-en\")\nmy_documents = [\n    \"very long document1\",\n    \"very long document2\",\n    # ... more documents\n]\n\n# And create an index with them at full length!\nRAG.index(collection=my_documents,\n          index_name=\"the_biggest_index\",\n          max_document_length=8190,)\n\n# or encode them in-memory with no truncation, up to your model's max length\nRAG.encode(my_documents)\n</code></pre><p>如需更詳細的資訊和深入了解 Jina-ColBERT，您可以造訪 <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">Hugging Face 頁面</a>。</p><h2 id=\"conclusion\">結論</h2><p>ColBERT 在資訊檢索領域代表了一個重要的進步。透過 Jina-ColBERT 啟用更長的上下文長度，並保持與 ColBERT 後期互動方法的相容性，為尋求實現最先進搜尋功能的開發者提供了一個強大的選擇。</p><p>結合 RAGatouille 函式庫，它簡化了將複雜檢索模型整合到 RAG 流程中的過程，開發者現在可以輕鬆運用進階檢索的力量，簡化工作流程並增強應用程式。Jina-ColBERT 和 RAGatouille 之間的協同效應，展示了在使進階 AI 搜尋模型變得容易存取和高效率方面的顯著進展。</p>",
  "comment_id": "65d3a2134a32310001f5b71b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/02/Untitled-design--28-.png",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-02-19T19:46:43.000+01:00",
  "updated_at": "2024-08-30T23:11:22.000+02:00",
  "published_at": "2024-02-20T02:19:04.000+01:00",
  "custom_excerpt": "Jina AI's ColBERT on Hugging Face has set Twitter abuzz, bringing a fresh perspective to search with its 8192-token capability. This article unpacks the nuances of ColBERT and ColBERTv2, showcasing their innovative designs and why their late interaction feature is a game-changer for search.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/what-is-colbert-and-late-interaction-and-why-they-matter-in-search/",
  "excerpt": "Jina AI 在 Hugging Face 上推出的 ColBERT 在 Twitter 上引起熱議，其 8192 token 的處理能力為搜尋領域帶來了新視角。本文將深入解析 ColBERT 和 ColBERTv2 的細節，展示其創新設計，以及為何其後期交互特性在搜尋領域中具有革命性的意義。",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Neon theater or concert hall marquee letters lit up at night with city lights and faint \"Adobe Sto\" visible.",
  "feature_image_caption": null
}