{
  "slug": "a-deep-dive-into-tokenization",
  "id": "65afb3ee8da8040001e17061",
  "uuid": "02d119e4-ed5f-4edf-8b66-65aea1386d96",
  "title": "深入探討 Tokenization",
  "html": "<p>在實施 AI 流程時，理解 AI 模型存在著許多障礙，其中一些是相當大的障礙。但很多人首先遇到的障礙是理解我們在談論 <strong>tokens</strong> 時的含義。</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/tokenizer?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Tokenizer API</div><div class=\"kg-bookmark-description\">Free API to tokenize texts, count and get first/last-N tokens.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-tokenize-api.png\" alt=\"\"></div></a></figure><p>在選擇 AI 語言模型時，最重要的實用參數之一是其上下文視窗的大小 — 即最大輸入文本大小 — 這是以 tokens 為單位計算的，而不是以字、字元或其他自動識別的單位計算。</p><p>此外，嵌入服務通常是按\"每個 token\"計費的，這意味著要理解你的帳單，tokens 是很重要的。</p><p>如果你不清楚 token 是什麼，這可能會令人感到非常困惑。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png\" class=\"kg-image\" alt=\"Jina Embeddings current price sheet (as of February 2024).\" loading=\"lazy\" width=\"2000\" height=\"1036\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png 2000w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Jina Embeddings 當前價格表（2024 年 2 月）。注意價格是以\"每百萬 tokens\"為單位。</span></figcaption></figure><p>但在現代 AI 的所有令人困惑的方面中，tokens 可能是最不複雜的。本文將嘗試闡明什麼是分詞（tokenization），它做什麼，以及為什麼我們要這樣做。</p><h2 id=\"tldr\">內容摘要</h2><p>對於那些想要或需要快速了解從 Jina Embeddings 購買多少 tokens 或估算需要購買多少的人來說，以下統計數據就是你所需要的。</p><h3 id=\"tokens-per-english-word\">每個英語單詞的 Tokens</h3><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">對英語模型的 Jina Embeddings v2 API 呼叫將使用<b><strong style=\"white-space: pre-wrap;\">大約比文本中的單詞數量多 10% 的 tokens</strong></b>，<b><strong style=\"white-space: pre-wrap;\">每個嵌入另加兩個 tokens</strong></b>。</div></div><p>在本文後面描述的實證測試中，使用 Jina Embeddings 英語專用模型時，各種英語文本轉換成 tokens 的比率大約比單詞多 10%。這個結果相當穩定。</p><p>Jina Embeddings v2 模型的上下文視窗為 8192 個 tokens。這意味著如果你傳入一個超過 7,400 個單詞的英語文本，很可能會被截斷。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">對<b><strong style=\"white-space: pre-wrap;\">英語版 Jina Embeddings v2</strong></b> 來說，輸入的最大大小約為<b><strong style=\"white-space: pre-wrap;\">7,400 個單詞</strong></b>。</div></div><h3 id=\"tokens-per-chinese-character\">每個中文字元的 Tokens</h3><p>對於中文來說，結果更加變化多端。根據文本類型的不同，每個漢字的 tokens 比率從 0.6 到 0.75 不等。當給中文版 Jina Embeddings v2 輸入英文文本時，產生的 tokens 數量與英語版 Jina Embeddings v2 大致相同：大約比單詞數量多 10%。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">對<b><strong style=\"white-space: pre-wrap;\">中英文版 Jina Embeddings v2</strong></b> 來說，中文輸入的最大大小約為<b><strong style=\"white-space: pre-wrap;\">10,500 字</strong></b>（<b><strong style=\"white-space: pre-wrap;\">字數</strong></b>），或者說<b><strong style=\"white-space: pre-wrap;\">每個漢字 0.6 到 0.75 個 tokens，每個嵌入另加兩個。</strong></b></div></div><h3 id=\"tokens-per-german-word\">每個德語單詞的 Tokens</h3><p>德語的單詞到 tokens 的比率比英語更加變化多端，但比中文少。根據文本類型的不同，平均比單詞多 20% 到 30% 的 tokens。當給德英文版 Jina Embeddings v2 輸入英文文本時，使用的 tokens 比英語專用和中英文模型略多：比單詞多 12% 到 15% 的 tokens。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">德英文版 Jina Embeddings v2 會計算<b><strong style=\"white-space: pre-wrap;\">比單詞多 20% 到 30% 的 tokens，每個嵌入另加兩個</strong></b>。輸入上下文的最大大小約為<b><strong style=\"white-space: pre-wrap;\">6,300 個德語單詞</strong></b>。</div></div><h3 id=\"caution\">注意事項</h3><p>這些是簡單的計算，但對於大多數自然語言文本和大多數用戶來說應該大致正確。最終，我們只能保證 tokens 的數量永遠不會超過你文本中的字元數加二。實際上它總是會比這少得多，但我們不能預先承諾任何具體的數量。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">實際結果可能有所不同！</strong></b><br><br>這些是基於統計學上簡單計算的估計。我們不保證任何特定請求會使用多少 tokens。</div></div><p>如果你只是需要關於購買多少 Jina Embeddings tokens 的建議，可以在這裡停止閱讀。其他公司的嵌入模型可能與 Jina 模型的單詞到 token 和漢字到 token 的比率不同，但總體上差異不會太大。</p><p>如果你想了解原因，本文的其餘部分將深入探討語言模型的分詞。</p><h2 id=\"words-tokens-numbers\">單詞、Tokens、數字</h2><p>分詞在自然語言處理中的應用歷史要早於現代 AI 模型的存在。</p><p>說電腦中的一切都只是數字可能有點老生常談，但這基本上是事實。然而，語言本質上不只是一堆數字。它可能是由聲波組成的語音，或是紙上的標記，甚至是印刷文本的圖像或手語視頻。但是，當我們談論使用電腦處理自然語言時，我們通常指的是由字元序列組成的文本：字母（a、b、c 等）、數字（0、1、2…）、標點符號和空格，使用不同的語言和文本編碼。</p><p>電腦工程師稱這些為\"字串\"。</p><p>AI 語言模型以數字序列作為輸入。所以，你可能寫下這句話：</p><blockquote><em>What is today's weather in Berlin?</em></blockquote><p>但是，經過分詞後，AI 模型得到的輸入是：</p><pre><code class=\"language-python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>分詞是將輸入字串轉換為 AI 模型可以理解的特定數字序列的過程。</p><p>當你通過按 token 收費的網路 API 使用 AI 模型時，每個請求都會被轉換成像上面那樣的數字序列。請求中的 tokens 數量就是該數字序列的長度。因此，要求英語版 Jina Embeddings v2 為 \"<em>What is today's weather in Berlin?</em>\" 生成嵌入將花費你 11 個 tokens，因為它在將該句子傳遞給 AI 模型之前將其轉換為了 11 個數字的序列。</p><p>基於 <a href=\"https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)?ref=jina-ai-gmbh.ghost.io\">Transformer 架構</a>的 AI 模型具有固定大小的<strong>上下文視窗</strong>，其大小以 tokens 為單位計量。有時這被稱為\"輸入視窗\"、\"上下文大小\"或\"序列長度\"（特別是在 <a href=\"https://huggingface.co/spaces/mteb/leaderboard?ref=jina-ai-gmbh.ghost.io\">Hugging Face MTEB 排行榜</a>上）。這意味著模型一次可以看到的最大文本大小。</p><p>所以，如果你想使用嵌入模型，這就是允許的最大輸入大小。</p><p>Jina Embeddings v2 模型都有 8,192 tokens 的上下文視窗。其他模型會有不同（通常更小）的上下文視窗。這意味著無論你輸入多少文本，與該 Jina Embeddings 模型相關聯的分詞器必須將其轉換為不超過 8,192 個 tokens。</p><h2 id=\"mapping-language-to-numbers\">將語言映射到數字</h2><p>解釋 tokens 邏輯最簡單的方式是：</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">token 是代表字串中一部分的數字。</div></div><p>對於自然語言模型來說，token 所代表的字串部分可以是一個詞、詞的一部分或標點符號。空格在分詞器輸出中通常不會有任何明確的表示。</p><p>分詞是自然語言處理中一組稱為<a href=\"https://en.wikipedia.org/wiki/Text_segmentation?ref=jina-ai-gmbh.ghost.io\"><em>文本分段</em></a>技術的一部分，執行分詞的模組很邏輯地被稱為<strong>分詞器</strong>。</p><p>為了展示分詞是如何工作的，我們將使用最小的英語版 Jina Embeddings v2 模型：<code>jina-embeddings-v2-small-en</code>。Jina Embeddings 的其他英語專用模型 — <code>jina-embeddings-v2-base-en</code> — 使用相同的分詞器，所以沒必要下載我們在本文中不會使用的額外 AI 模型。</p><p>首先，在你的 Python 環境或筆記本中安裝 <code>transformers</code> 模組。使用<code>-U</code> 標誌來確保升級到最新版本，因為此模型無法與某些舊版本相容：</p><pre><code class=\"language-bash\">pip install -U transformers\n</code></pre><p>然後，使用 <code>AutoModel.from_pretrained</code> 下載 <a href=\"https://huggingface.co/jinaai/jina-embeddings-v2-small-en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\"><code>jina-embeddings-v2-small-en</code></a>：</p><pre><code class=\"language-Python\">from transformers import AutoModel\n\nmodel = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-small-en', trust_remote_code=True)\n</code></pre><p>要標記化字串，請使用模型的 <code>tokenizer</code> 成員物件的 <code>encode</code> 方法：</p><pre><code class=\"language-Python\">model.tokenizer.encode(\"What is today's weather in Berlin?\")\n</code></pre><p>結果是一個數字列表：</p><pre><code class=\"language-Python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>要將這些數字轉換回字串形式，使用 <code>tokenizer</code> 物件的 <code>convert_ids_to_tokens</code> 方法：</p><pre><code class=\"language-Python\">model.tokenizer.convert_ids_to_tokens([101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102])\n</code></pre><p>結果是一個字串列表：</p><pre><code class=\"language-Python\">['[CLS]', 'what', 'is', 'today', \"'\", 's', 'weather', 'in',\n 'berlin', '?', '[SEP]']\n</code></pre><p>請注意，模型的分詞器具有以下特點：</p><ol><li>在開頭添加 <code>[CLS]</code>，在結尾添加 <code>[SEP]</code>。這是出於技術原因所必需的，意味著**每個嵌入請求都會多消耗兩個標記**，超出文本本身所需的標記數量。</li><li>將標點符號從單詞中分開，把「<em>Berlin?</em>」分成：<code>berlin</code> 和 <code>?</code>，把「<em>today's</em>」分成 <code>today</code>、<code>'</code> 和 <code>s</code>。</li><li>將所有內容轉為小寫。並非所有模型都這樣做，但這在使用英語時有助於訓練。在大小寫具有不同含義的語言中，這可能就不那麼有幫助。</li></ol><p>不同程式中的不同字數計算演算法可能會對這個句子的字數有不同統計。OpenOffice 將其計為六個字。Unicode 文本分段演算法（<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode Standard Annex #29</a>）計為七個字。其他軟體可能會得出不同的數字，這取決於它們如何處理標點符號和像「's」這樣的附著語。</p><p>這個模型的分詞器為這六或七個字產生了九個標記，再加上每個請求所需的兩個額外標記。</p><p>現在，讓我們試試一個不如柏林常見的地名：</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"I live in Kinshasa.\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>結果：</p><pre><code class=\"language-Python\">['[CLS]', 'i', 'live', 'in', 'kin', '##sha', '##sa', '.', '[SEP]']\n</code></pre><p>「Kinshasa」這個名字被分成三個標記：<code>kin</code>、<code>##sha</code> 和 <code>##sa</code>。<code>##</code> 表示這個標記不是單詞的開頭。</p><p>如果我們給分詞器一些完全陌生的內容，標記數量相對於字數的比例會更高：</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"Klaatu barada nikto\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n\n['[CLS]', 'k', '##la', '##at', '##u', 'bar', '##ada', 'nik', '##to', '[SEP]']\n</code></pre><p>三個字被分成八個標記，再加上 <code>[CLS]</code> 和 <code>[SEP]</code> 標記。</p><p>德語的分詞情況類似。使用 <a href=\"https://jina.ai/news/ich-bin-ein-berliner-german-english-bilingual-embeddings-with-8k-token-length/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Jina Embeddings v2 for German</a> 模型，我們可以用與英語模型相同的方式來標記化「What is today's weather in Berlin?」的德語翻譯。</p><pre><code class=\"language-Python\">german_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-de', trust_remote_code=True)\ntoken_ids = german_model.tokenizer.encode(\"Wie wird das Wetter heute in Berlin?\")\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>結果：</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Wie', 'wird', 'das', 'Wetter', 'heute', 'in', 'Berlin', '?', '&lt;/s&gt;']\n</code></pre><p>這個分詞器與英語的有些不同，它使用 <code>&lt;s&gt;</code> 和 <code>&lt;/s&gt;</code> 替代了 <code>[CLS]</code> 和 <code>[SEP]</code>，但功能相同。此外，文本沒有進行大小寫標準化——大小寫保持原樣——因為在德語中，大小寫的意義與英語不同。</p><p>（為了簡化這個演示，我移除了一個表示單詞開頭的特殊字符。）</p><p>現在，讓我們試試一個來自<a href=\"https://www.welt.de/politik/deutschland/plus249565102/Proteste-der-Landwirte-Die-Krux-mit-den-Foerdermitteln.html?ref=jina-ai-gmbh.ghost.io\">報紙文章</a>的更複雜句子：</p><blockquote>Ein Großteil der milliardenschweren Bauern-Subventionen bleibt liegen – zu genervt sind die Landwirte von bürokratischen Gängelungen und Regelwahn.</blockquote><pre><code>sentence = \"\"\"\nEin Großteil der milliardenschweren Bauern-Subventionen\nbleibt liegen – zu genervt sind die Landwirte von \nbürokratischen Gängelungen und Regelwahn.\n\"\"\"\ntoken_ids = german_model.tokenizer.encode(sentence)\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)</code></pre><p>標記化結果：</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Ein', 'Großteil', 'der', 'mill', 'iarden', 'schwer', \n 'en', 'Bauern', '-', 'Sub', 'ventionen', 'bleibt', 'liegen', \n '–', 'zu', 'gen', 'ervt', 'sind', 'die', 'Landwirte', 'von', \n 'büro', 'krat', 'ischen', 'Gän', 'gel', 'ungen', 'und', 'Regel', \n 'wahn', '.', '&lt;/s&gt;']\n</code></pre><p>在這裡，你可以看到許多德語單詞被分成更小的片段，而且不一定按照德語語法允許的方式分割。結果是，在字數計數器中只算作一個字的長德語單詞，在 Jina 的 AI 模型中可能會被分成任意數量的標記。</p><p>讓我們用中文做同樣的事，將「What is today's weather in Berlin?」翻譯成：</p><blockquote>柏林今天的天气怎么样？</blockquote><pre><code>chinese_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-zh', trust_remote_code=True)\ntoken_ids = chinese_model.tokenizer.encode(\"柏林今天的天气怎么样？\")\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>標記化結果：</p><pre><code class=\"language-Python\">['&lt;s&gt;', '柏林', '今天的', '天气', '怎么样', '？', '&lt;/s&gt;']\n</code></pre><p>在中文中，書面文本通常沒有詞間空格，但 Jina Embeddings 分詞器經常將多個中文字符組合在一起：</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Token string</th>\n<th>Pinyin</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>柏林</td>\n<td>Bólín</td>\n<td>Berlin</td>\n</tr>\n<tr>\n<td>今天的</td>\n<td>jīntiān de</td>\n<td>today's</td>\n</tr>\n<tr>\n<td>天气</td>\n<td>tiānqì</td>\n<td>weather</td>\n</tr>\n<tr>\n<td>怎么样</td>\n<td>zěnmeyàng</td>\n<td>how</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>讓我們使用一個來自<a href=\"https://news.mingpao.com/pns/%e6%b8%af%e8%81%9e/article/20240116/s00002/1705335848777/%e7%81%a3%e5%8d%80%e7%86%b1%e6%90%9c-%e7%a9%97%e5%9c%b0%e9%90%b5%e6%8e%a8%e6%89%8b%e6%a9%9f%e3%80%8c%e9%9d%9c%e9%9f%b3%e4%bb%a4%e3%80%8d-%e7%84%a1%e7%bd%b0%e5%89%87-%e5%b8%82%e6%b0%91%e6%9c%89%e7%a8%b1%e5%85%b7%e8%ad%a6%e7%a4%ba%e4%bd%9c%e7%94%a8-%e6%9c%89%e6%84%9f%e5%af%a6%e6%95%88%e4%b8%8d%e5%a4%a7?ref=jina-ai-gmbh.ghost.io\">香港報紙</a>的更複雜句子：</p><pre><code class=\"language-Python\">sentence = \"\"\"\n新規定執行首日，記者在下班高峰前的下午5時來到廣州地鐵3號線，\n從繁忙的珠江新城站啟程，向機場北方向出發。\n\"\"\"\ntoken_ids = chinese_model.tokenizer.encode(sentence)\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>（翻譯：<em>\"在新規定實施的第一天，本記者在下午 5 點放工高峰期抵達廣州地鐵 3 號線，從珠江新城站出發，向機場北方向前進。\"</em>）</p><p>結果：</p><pre><code class=\"language-python\">['&lt;s&gt;', '新', '規定', '執行', '首', '日', '，', '記者', '在下', '班', \n '高峰', '前的', '下午', '5', '時', '來到', '廣州', '地', '鐵', '3', \n '號', '線', '，', '從', '繁忙', '的', '珠江', '新城', '站', '啟', \n '程', '，', '向', '機場', '北', '方向', '出發', '。', '&lt;/s&gt;']\n</code></pre><p>這些 token 並不對應任何特定的中文詞典。例如，\"啟程\" 通常會被視為一個單詞，但在這裡被分成兩個字元。同樣地，\"在下班\" 通常會被認為是兩個詞，其分界點應該在 \"在\" 和 \"下班\" 之間，而不是像 tokenizer 所做的那樣在 \"在下\" 和 \"班\" 之間分開。</p><p>在所有三種語言中，tokenizer 斷詞的位置與人類讀者認知的邏輯斷句位置並不直接相關。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">tokenizer 算法並不使用傳統的語言感知詞典，所以它的行為與人類計算詞數的方式不相符。</div></div><p>這並非 Jina Embeddings 模型的特殊功能。這種分詞方法在 AI 模型開發中幾乎是通用的。雖然不同的 AI 模型可能沒有完全相同的 tokenizer，但在目前的發展階段，它們實際上都會使用具有這種行為特徵的 tokenizer。</p><p>下一節將討論 tokenization 所使用的具體算法及其背後的邏輯。</p><h2 id=\"why-do-we-tokenize-and-why-this-way\">為什麼我們要進行分詞？為什麼要用這種方式？</h2><p>AI 語言模型接受代表文本序列的數字序列作為輸入，但在運行底層神經網路和創建嵌入之前還需要進行一些處理。當面對代表小文本序列的數字列表時，模型會在其內部字典中查找每個數字，這個字典為每個數字儲存了一個獨特的向量。然後它將這些向量組合起來，作為神經網路的輸入。</p><p>這意味著 tokenizer <strong>必須</strong>能夠將<strong><em>任何</em></strong>我們給它的輸入文本轉換成出現在模型的 token 向量字典中的 token。如果我們使用傳統詞典中的 token，當我們第一次遇到拼寫錯誤、罕見的專有名詞或外語單詞時，整個模型就會停止運作。它無法處理那個輸入。</p><p>在自然語言處理中，這被稱為詞彙表外（OOV）問題，它在所有文本類型和所有語言中都普遍存在。解決 OOV 問題有幾種策略：</p><ol><li>忽略它。用 \"未知\" token 替代所有不在詞典中的內容。</li><li>繞過它。不使用將文本序列映射到向量的詞典，而是使用將<em>單個字符</em>映射到向量的詞典。英語大多數時候只使用 26 個字母，所以這比任何詞典都要小得多，且對 OOV 問題更具魯棒性。</li><li>在文本中尋找頻繁出現的子序列，將它們放入詞典，剩下的內容使用字符（單字母 token）。</li></ol><p>第一種策略意味著會失去很多重要信息。如果數據採取的形式不在詞典中，模型甚至無法從所見的數據中學習。即使是最大的詞典中也有許多普通文本中的內容未被收錄。</p><p>第二種策略是可行的，研究人員也對此進行過探究。然而，這意味著模型必須接受更多輸入並學習更多內容。這需要更大的模型和更多的訓練數據，而結果從未被證明比第三種策略更好。</p><p>AI 語言模型幾乎都以某種形式實現第三種策略。大多數使用 <a href=\"https://huggingface.co/learn/nlp-course/chapter6/6?ref=jina-ai-gmbh.ghost.io\">Wordpiece 算法</a> <a href=\"https://ieeexplore.ieee.org/document/6289079?ref=jina-ai-gmbh.ghost.io\">[Schuster 和 Nakajima 2012]</a> 的某種變體或稱為 <a href=\"https://en.wikipedia.org/wiki/Byte_pair_encoding?ref=jina-ai-gmbh.ghost.io\">字節對編碼</a>（BPE）的類似技術。[<a href=\"https://www.drdobbs.com/a-new-algorithm-for-data-compression/184402829?ref=jina-ai-gmbh.ghost.io\">Gage 1994</a>，<a href=\"https://aclanthology.org/P16-1162/?ref=jina-ai-gmbh.ghost.io\">Senrich 等人 2016</a>] 這些算法是<em>與語言無關</em>的。這意味著它們對所有書面語言的工作方式都相同，除了可能字符列表外不需要其他知識。它們是為像 Google 的 BERT 這樣的多語言模型設計的，這些模型可以接受從互聯網抓取的任何輸入——數百種語言和電腦程序等非人類語言的文本——因此可以在不進行複雜語言學處理的情況下進行訓練。</p><p>一些研究表明，使用更具語言特異性和語言感知的 tokenizer 可以帶來顯著改進。[<a href=\"https://aclanthology.org/2021.acl-long.243/?ref=jina-ai-gmbh.ghost.io\">Rust 等人 2021</a>] 但以這種方式構建 tokenizer 需要時間、金錢和專業知識。實施像 BPE 或 Wordpiece 這樣的通用策略要便宜和容易得多。</p><p>然而，結果是，除非將文本運行通過 tokenizer 然後計算輸出的 token 數量，否則無法知道特定文本代表多少個 token。因為文本最小可能的子序列是一個字母，所以你可以確定 token 數量不會大於字符數（減去空格）再加二。</p><p>要獲得一個好的估計，我們需要向 tokenizer 輸入大量文本，並根據經驗計算我們獲得的 token 數量與輸入的單詞或字符數量的平均比較。在下一節中，我們將對目前可用的所有 Jina Embeddings v2 模型進行一些不太系統的經驗測量。</p><h2 id=\"empirical-estimates-of-token-output-sizes\">token 輸出大小的經驗估計</h2><p>對於英語和德語，我使用 Unicode 文本分割算法（<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode 標準附件 #29</a>）來獲取文本的詞數。當你雙擊某個內容時，這個算法被廣泛用於選擇文本片段。這是最接近通用客觀詞計數器的工具。</p><p>我在 Python 中安裝了實現這個文本分割器的 <a href=\"https://pypi.org/project/polyglot/?ref=jina-ai-gmbh.ghost.io\">polyglot 庫</a>：</p><pre><code class=\"language-bash\">pip install -U polyglot\n</code></pre><p>要獲取文本的詞數，你可以使用這樣的程式碼片段：</p><pre><code class=\"language-python\">from polyglot.text import Text\n\ntxt = \"What is today's weather in Berlin?\"\nprint(len(Text(txt).words))\n</code></pre><p>結果應該是 <code>7</code>。</p><p>要獲取 token 數量，將文本片段傳遞給各種 Jina Embeddings 模型的 tokenizer，如下所述，每次我都從返回的 token 數量中減去二。</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\">此處列出的 token 計數<b><strong style=\"white-space: pre-wrap;\">不包括</strong></b>每個分詞文本開頭和結尾的額外兩個 token。</div></div><h3 id=\"english-jina-embeddings-v2-small-en-and-jina-embeddings-v2-base-en\">英語<br>（<code>jina-embeddings-v2-small-en</code> 和 <code>jina-embeddings-v2-base-en</code>）</h3><p>為了計算平均值，我從 <a href=\"https://wortschatz.uni-leipzig.de/en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Wortschatz Leipzig</a> 下載了兩個英語文本語料庫，這是萊比錫大學主辦的多種語言和配置的免費可下載語料庫集合：</p><ul><li>2020 年的一百萬句英語新聞數據語料庫（<code>eng_news_2020_1M</code>）</li><li>2016 年的一百萬句 <a href=\"https://en.wikipedia.org/?ref=jina-ai-gmbh.ghost.io\">英語維基百科</a> 數據語料庫（<code>eng_wikipedia_2016_1M</code>）</li></ul><p>這兩個都可以在<a href=\"https://wortschatz.uni-leipzig.de/en/download/English?ref=jina-ai-gmbh.ghost.io\">他們的英語下載頁面</a>找到。</p><p>為了增加多樣性，我還從 Project Gutenberg 下載了 <a href=\"https://www.gutenberg.org/ebooks/135?ref=jina-ai-gmbh.ghost.io\">Hapgood 翻譯的維克多·雨果的《悲慘世界》</a>，以及1611 年翻譯的英皇欽定本聖經。</p><p>對於所有四個文本，我使用 <code>polyglot</code> 中實現的 Unicode 分割器計算詞數，然後計算 <code>jina-embeddings-v2-small-en</code> 產生的 token，每次分詞請求減去兩個 token。結果如下：</p>\n<!--kg-card-begin: html-->\n<table id=\"6f07d5d4-ca08-466e-92fc-e784a932e4d0\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"4b8c4003-8ef9-4ac5-8df3-ef7662ab4d3b\"><th id=\"wvl`\" class=\"simple-table-header-color simple-table-header\">文本</th><th id=\"|<X;\" class=\"simple-table-header-color simple-table-header\">詞數<br>（Unicode 分割器）<br></th><th id=\"GHal\" class=\"simple-table-header-color simple-table-header\">Token 數<br>（Jina Embeddings v2 <br>英語版）<br></th><th id=\"h]mu\" class=\"simple-table-header-color simple-table-header\">Token 與詞的比率<br>（取至小數點後三位）<br></th></tr></thead><tbody><tr id=\"7e9eda1b-54b6-40f3-be6f-b233f161e2b5\"><td id=\"wvl`\" class=\"\"><code>eng_news_2020_1M</code></td><td id=\"|<X;\" class=\"\">22,825,712</td><td id=\"GHal\" class=\"\">25,270,581</td><td id=\"h]mu\" class=\"\">1.107</td></tr><tr id=\"a81dfe1d-9143-4306-9bf3-4891ca8fb019\"><td id=\"wvl`\" class=\"\"><code>eng_wikipedia_2016_1M</code></td><td id=\"|<X;\" class=\"\">24,243,607</td><td id=\"GHal\" class=\"\">26,813,877</td><td id=\"h]mu\" class=\"\">1.106</td></tr><tr id=\"d2fff413-6e0d-4ab2-9626-4d618d99af91\"><td id=\"wvl`\" class=\"\"><code>les_miserables_en</code></td><td id=\"|<X;\" class=\"\">688,911</td><td id=\"GHal\" class=\"\">764,121</td><td id=\"h]mu\" class=\"\">1.109</td></tr><tr id=\"eb304e43-4fd3-4e02-9993-13fb0307f544\"><td id=\"wvl`\" class=\"\"><code>kjv_bible</code></td><td id=\"|<X;\" class=\"\">1,007,651</td><td id=\"GHal\" class=\"\">1,099,335</td><td id=\"h]mu\" class=\"\">1.091</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>使用精確數字並不表示這是一個精確的結果。具有如此不同體裁的文件會產生比字數多 9% 到 11% 的字符數，這表明您可能會得到比字數多約 10% 的字符數（按 Unicode 分詞器計算）。文字處理器通常不會計算標點符號，而 Unicode 分詞器會計算，所以您不能期望辦公軟體的字數計算與此相符。</p><h3 id=\"german-jina-embeddings-v2-base-de\">德語<br>(<code>jina-embeddings-v2-base-de</code>)</h3><p>對於德語，我從 <a href=\"https://wortschatz.uni-leipzig.de/en/download/German?ref=jina-ai-gmbh.ghost.io\">Wortschatz Leipzig 的德語頁面</a>下載了三個語料庫：</p><ul><li><code>deu_mixed-typical_2011_1M</code> — 來自 2011 年不同體裁文本的均衡混合的一百萬個句子。</li><li><code>deu_newscrawl-public_2019_1M</code> — 來自 2019 年的一百萬個新聞文本句子。</li><li><code>deu_wikipedia_2021_1M</code> — 2021 年從德語維基百科中提取的一百萬個句子。</li></ul><p>為了增加多樣性，我還從 <a href=\"https://www.deutschestextarchiv.de/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">德語文本檔案庫</a>下載了<a href=\"https://deutschestextarchiv.de/search?q=Kapital&in=metadata&ref=jina-ai-gmbh.ghost.io\">卡爾・馬克思的《資本論》三卷</a>。</p><p>然後我按照與英語相同的程序進行：</p>\n<!--kg-card-begin: html-->\n<table id=\"ad695a91-f35b-4215-bd4d-5d1415bb9812\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"7786decb-f68d-433d-8f58-3861d0350027\"><th id=\"UGp`\" class=\"simple-table-header-color simple-table-header\" style=\"width:234.2265625px\">文本</th><th id=\"|qln\" class=\"simple-table-header-color simple-table-header\">字數<br>(Unicode 分詞器)<br></th><th id=\"YXZX\" class=\"simple-table-header-color simple-table-header\">字符數<br>(Jina Embeddings v2 <br>用於德語和英語)<br></th><th id=\"oEoQ\" class=\"simple-table-header-color simple-table-header\">字符數與字數的比率<br>(保留 3 位小數)<br></th></tr></thead><tbody><tr id=\"9cb48640-64db-4783-8bfe-c78412022a21\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_mixed-typical_2011_1M</code></td><td id=\"|qln\" class=\"\">7,924,024</td><td id=\"YXZX\" class=\"\">9,772,652</td><td id=\"oEoQ\" class=\"\">1.234</td></tr><tr id=\"32fee905-17dc-4c2c-a32d-5e6508b033bc\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_newscrawl-public_2019_1M</code></td><td id=\"|qln\" class=\"\">17,949,120</td><td id=\"YXZX\" class=\"\">21,711,555</td><td id=\"oEoQ\" class=\"\">1.210</td></tr><tr id=\"35d0c8c4-7912-4d61-829a-bb39b643aa1c\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_wikipedia_2021_1M</code></td><td id=\"|qln\" class=\"\">17,999,482</td><td id=\"YXZX\" class=\"\">22,654,901</td><td id=\"oEoQ\" class=\"\">1.259</td></tr><tr id=\"19e10367-e070-4dcc-8cbe-cfc75c43e0f9\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>marx_kapital</code></td><td id=\"|qln\" class=\"\">784,336</td><td id=\"YXZX\" class=\"\">1,011,377</td><td id=\"oEoQ\" class=\"\">1.289</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>這些結果的差異比僅英語模型更大，但仍表明德語文本平均會產生比字數多 20% 到 30% 的字符數。</p><p>使用德英雙語分詞器時，英語文本產生的字符數比僅英語分詞器多：</p>\n<!--kg-card-begin: html-->\n<table id=\"c31b2079-e921-4e06-a24b-8ed60ae63d8d\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"fe722fdd-ab88-44b4-9f3b-43c62eb3ccb5\"><th id=\"Nc<l\" class=\"simple-table-header-color simple-table-header\" style=\"width:187.78125px\">文本</th><th id=\"R@A^\" class=\"simple-table-header-color simple-table-header\">字數<br>(Unicode 分詞器)<br></th><th id=\"UUfl\" class=\"simple-table-header-color simple-table-header\">字符數<br>(Jina Embeddings v2 <br>用於德語和英語)<br></th><th id=\"iTZS\" class=\"simple-table-header-color simple-table-header\">字符數與字數的比率<br>(保留 3 位小數)<br></th></tr></thead><tbody><tr id=\"3461fd8c-ca39-4670-8f0e-e38a4958464a\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_news_2020_1M</code></td><td id=\"R@A^\" class=\"\">24243607</td><td id=\"UUfl\" class=\"\">27758535</td><td id=\"iTZS\" class=\"\">1.145</td></tr><tr id=\"48770d4d-5855-4f5f-934f-5b2900aa56c3\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"R@A^\" class=\"\">22825712</td><td id=\"UUfl\" class=\"\">25566921</td><td id=\"iTZS\" class=\"\">1.120</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>使用雙語德英分詞器對英語文本進行編碼時，應該預期需要比僅英語分詞器多 12% 到 15% 的字符數。</p><h3 id=\"chinese-jina-embeddings-v2-base-zh\">中文<br>(<code>jina-embeddings-v2-base-zh</code>)</h3><p>中文通常不使用空格書寫，在 20 世紀之前也沒有傳統的「詞」的概念。因此，中文文本的大小通常以字數來衡量。所以，我沒有使用 Unicode 分詞器，而是通過移除所有空格然後直接獲取字符長度來測量中文文本的長度。</p><p>我從 <a href=\"https://wortschatz.uni-leipzig.de/en/download/Chinese?ref=jina-ai-gmbh.ghost.io\">Wortschatz Leipzig 的中文語料庫頁面</a>下載了三個語料庫：</p><ul><li><code>zho_wikipedia_2018_1M</code> — 2018 年從中文維基百科提取的一百萬個句子。</li><li><code>zho_news_2007-2009_1M</code> — 2007 年至 2009 年收集的一百萬個中文新聞來源句子。</li><li><code>zho-trad_newscrawl_2011_1M</code> — 來自專門使用繁體字的新聞來源的一百萬個句子。</li></ul><p>此外，為了增加多樣性，我還使用了魯迅在 1920 年代初期創作的中篇小說《阿 Q 正傳》。我從 <a href=\"https://www.gutenberg.org/ebooks/25332?ref=jina-ai-gmbh.ghost.io\">古騰堡計劃下載了繁體版本</a>。</p>\n<!--kg-card-begin: html-->\n<table id=\"dace0ca3-97c0-481e-98e2-d2724b7bbe66\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"adc6e6ff-8afd-4915-8884-0894546a13dc\"><th id=\"bCvb\" class=\"simple-table-header-color simple-table-header\" style=\"width:223.6953125px\">文本</th><th id=\"CaUc\" class=\"simple-table-header-color simple-table-header\">字數<br></th><th id=\"CQ{d\" class=\"simple-table-header-color simple-table-header\">字符數<br>(Jina Embeddings v2 <br>用於中文和英語)<br></th><th id=\"_};C\" class=\"simple-table-header-color simple-table-header\">字符數與字數的比率<br>(保留 3 位小數)<br></th></tr></thead><tbody><tr id=\"e75154ce-a33e-4af1-a983-4c4213f93c0e\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_wikipedia_2018_1M</code></td><td id=\"CaUc\" class=\"\">45,116,182</td><td id=\"CQ{d\" class=\"\">29,193,028</td><td id=\"_};C\" class=\"\">0.647</td></tr><tr id=\"605560a8-5c77-4add-a3e4-4615779b571a\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_news_2007-2009_1M</code></td><td id=\"CaUc\" class=\"\">44,295,314</td><td id=\"CQ{d\" class=\"\">28,108,090</td><td id=\"_};C\" class=\"\">0.635</td></tr><tr id=\"6e23944e-a480-4978-8550-a83404b218c4\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho-trad_newscrawl_2011_1M</code></td><td id=\"CaUc\" class=\"\">54,585,819</td><td id=\"CQ{d\" class=\"\">40,290,982</td><td id=\"_};C\" class=\"\">0.738</td></tr><tr id=\"50abbb96-06f7-4308-9c66-7c18f2a67721\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>Ah_Q</code></td><td id=\"CaUc\" class=\"\">41,268</td><td id=\"CQ{d\" class=\"\">25,346</td><td id=\"_};C\" class=\"\">0.614</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>這種字符與標記之比的差異出人意料，尤其是繁體字語料庫中的異常值值得進一步研究。儘管如此，我們可以得出結論：對於中文來說，你所需要的 token 數量會比文本中的字符數量要少。根據你的內容，可以預期需要減少 25% 到 40%。</p><p>在 Jina Embeddings v2 中英雙語版本中的英文文本，其 token 數量與純英文模型產生的數量大致相同：</p>\n<!--kg-card-begin: html-->\n<table id=\"061e7c3f-d109-476d-85fb-db3b369e4f35\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"1200d074-3353-4815-ab66-a90e93ec349d\"><th id=\"v\\xv\" class=\"simple-table-header-color simple-table-header\" style=\"width:184.53125px\">Text</th><th id=\"qlUV\" class=\"simple-table-header-color simple-table-header\" style=\"width:165.3125px\">Word count<br>(Unicode Segmenter)<br></th><th id=\"=]?F\" class=\"simple-table-header-color simple-table-header\">Token count<br>(Jina Embeddings v2 for Chinese and English)<br></th><th id=\"<rlw\" class=\"simple-table-header-color simple-table-header\">Ratio of tokens to words<br>(to 3 decimal places)<br></th></tr></thead><tbody><tr id=\"2fe4e02d-94fd-4513-bfcb-7f85d66b6883\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_news_2020_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">24,243,607</td><td id=\"=]?F\" class=\"\">26,890,176</td><td id=\"<rlw\" class=\"\">1.109</td></tr><tr id=\"e7f937f4-b156-4f5d-9e0b-3041d07b1b20\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">22,825,712</td><td id=\"=]?F\" class=\"\">25,060,352</td><td id=\"<rlw\" class=\"\">1.097</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<h2 id=\"taking-tokens-seriously\">認真對待 Token</h2><p>Token 是 AI 語言模型的重要骨架，這個領域的研究仍在持續進行中。</p><p>AI 模型在一個革命性的發現是：它們對於雜訊數據具有很強的抗性。即使特定模型使用的並非最佳的分詞策略，只要網絡夠大、資料充足且訓練得當，它就能從不完美的輸入中學會做正確的事情。</p><p>因此，相比其他領域，在改進分詞方面投入的精力要少得多，但這種情況可能會改變。</p><p>作為通過 <a href=\"https://jina.ai/embeddings/?ref=jina-ai-gmbh.ghost.io\">Jina Embeddings 這樣的 API</a> 購買嵌入向量的用戶，你無法精確知道特定任務需要多少 token，可能需要自己進行一些測試才能得到確切的數字。但是這裡提供的估算值—英文約為詞數的 110%、德文約為詞數的 125%、中文約為字符數的 70%—應該足以用於基本預算規劃。</p>",
  "comment_id": "65afb3ee8da8040001e17061",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/01/Untitled-design--25-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-01-23T13:41:18.000+01:00",
  "updated_at": "2024-08-14T11:38:01.000+02:00",
  "published_at": "2024-01-31T16:10:14.000+01:00",
  "custom_excerpt": "Tokenization, in LLMs, means chopping input texts up into smaller parts for processing. So why are embeddings billed by the token?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "632ae7353e4e55003d52598e",
    "name": "Scott Martens",
    "slug": "scott",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
    "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
    "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
    "website": "https://jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/a-deep-dive-into-tokenization/",
  "excerpt": "在 LLM 中，Tokenization 意味著將輸入文字切分成較小的部分進行處理。那麼為什麼 embeddings 要按照 token 來計費呢？",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Colorful speckled grid pattern with a mix of small multicolored dots on a black background, creating a mosaic effect.",
  "feature_image_caption": null
}