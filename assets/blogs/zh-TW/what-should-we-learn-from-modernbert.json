{
  "slug": "what-should-we-learn-from-modernbert",
  "id": "678cc6a18f6bb40001a63537",
  "uuid": "fde6f3d6-20f1-4f8e-b811-ab6e2880a9c6",
  "title": "從 ModernBERT 中我們應該學到什麼？",
  "html": "<p>回到 2018 年，Google 發布了 BERT，這在當時 LLM 浪潮之前就已經是 NLP 的一大突破。即使到現在，許多小型語言模型仍然是基於 BERT 構建的。在 2024 年 12 月，<a href=\"https://huggingface.co/blog/modernbert?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">ModernBERT</a> 將我們從近期 LLM 發展中學到的經驗應用到這些較小的模型上。關鍵改進在哪？更好的參數效率、代碼理解能力和長文本處理能力。</p><p>在這篇文章中，我們將分析 ModernBERT 與兩個我們非常熟悉的模型的比較：<code>jina-XLM-RoBERTa</code>（<code>jina-embeddings-v3</code> 背後的多語言骨幹）和 <code>RoBERTa-large</code>。讓我們看看每個模型：</p><ul><li><strong>ModernBERT</strong>（2024 年 12 月）是最近發布的 SLM，由 Answer.AI、LightOn 和 HuggingFace 共同開發。它利用了現代優化技術，如 RoPE 實現 8,192 token 的上下文窗口和 <a href=\"https://arxiv.org/abs/2002.05202?ref=jina-ai-gmbh.ghost.io\">GeGLU layers</a>，在保持效率的同時提升性能。</li><li><a href=\"https://huggingface.co/jinaai/xlm-roberta-flash-implementation?ref=jina-ai-gmbh.ghost.io\"><strong><code>jina-XLM-RoBERTa</code></strong></a><strong> </strong>（2024 年 9 月）是一個基於 Meta 的 <a href=\"https://huggingface.co/docs/transformers/en/model_doc/xlm-roberta?ref=jina-ai-gmbh.ghost.io\"><code>XLM-RoBERTa</code></a> 的多語言文本嵌入模型。原始的 <code>XLM-RoBERTa</code> 使用 XLM 大型多語言數據集增強了 <code>RoBERTa</code>，而 <code>jina-XLM-RoBERTa</code> 則通過擴展上下文訓練、<a href=\"https://arxiv.org/abs/2104.09864?ref=jina-ai-gmbh.ghost.io\">RoPE</a> 實現和 <a href=\"https://arxiv.org/abs/2307.08691?ref=jina-ai-gmbh.ghost.io\">FlashAttention-2</a> 支持進一步改進。這個模型是 <code>jina-embeddings-v3</code> 的骨幹。</li><li><a href=\"https://huggingface.co/FacebookAI/roberta-large?ref=jina-ai-gmbh.ghost.io\"><strong><code>RoBERTa-large</code></strong></a>（2019 年 7 月）由 Meta 開發，是 BERT 的增強版本，擁有 3.55 億參數。通過延長訓練時間、更大的數據集和動態遮罩等創新，它在包括 <a href=\"https://gluebenchmark.com/?ref=jina-ai-gmbh.ghost.io\">GLUE</a>、<a href=\"https://rajpurkar.github.io/SQuAD-explorer/?ref=jina-ai-gmbh.ghost.io\">SQuAD</a> 和 <a href=\"https://arxiv.org/abs/1704.04683?ref=jina-ai-gmbh.ghost.io\">RACE</a> 在內的關鍵基準測試中取得了驚人的成果。這使它非常適合從文本分類到問答等各種 NLP 任務。</li></ul><p>通過比較這些模型的三個核心方面，我們旨在為模型開發者突出 ModernBERT 的有效設計選擇，並為未來的 BERT 類模型識別關鍵的開發見解。我們還將分享開發 <code>jina-embeddings-v3</code> 的經驗，並討論 <code>jina-embeddings-v4</code> 和 <code>jina-reranker-v3</code> 的計劃改進。</p><h2 id=\"modernberts-parameter-efficiency\">ModernBERT 的參數效率</h2><p>讓我們首先研究 ModernBERT 在參數效率方面的做法 - 它引入了最近 LLM 發展中的幾個關鍵見解。ModernBERT 利用了三個核心策略：更深但更窄的架構、受控的詞彙表大小，以及從較小模型開始的漸進式模型擴展。</p><h3 id=\"deep-and-thin-architecture\">深而窄的架構</h3><p>ModernBERT-large 有 28 層，比 <code>jina-XLM-RoBERTa</code> 和 <code>RoBERTa-large</code> 的 24 層更深。有趣的是，儘管層數更多，它的參數數量仍與 <code>RoBERTa-large</code> 相當。<code>jina-XLM-RoBERTa</code> 需要更多參數，因為它要處理 89 種語言，而其他兩個只專注於英語。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/01/deep_and_thin-dark-architecture-outlines-1.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1389\" height=\"547\"><figcaption><span style=\"white-space: pre-wrap;\">對於小型 LLM 來說，深度（層數）比寬度（隱藏單元數）更重要。深而窄的模型結構在捕捉抽象概念方面表現出色，最終能獲得更好的性能。</span></figcaption></figure><p>transformer 的大部分參數來自注意力層和全連接層。ModernBERT 通過\"變窄\"來保持競爭力 - 它在 28 層中使用 2,624 個隱藏單元，相比之下 RoBERTa-large 在 24 層中使用 4,096 個單元。這種\"更深\"但更窄的設置使它們能夠在不膨脹模型的情況下達到性能目標。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ModernBERT-large</th>\n<th><code>jina-XLM-RoBERTa</code></th>\n<th><code>RoBERTa-large</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>參數量</td>\n<td>400M</td>\n<td>550M</td>\n<td>355M</td>\n</tr>\n<tr>\n<td>隱藏狀態</td>\n<td>1,024</td>\n<td>1,024</td>\n<td>1,024</td>\n</tr>\n<tr>\n<td>中間維度</td>\n<td>2,624</td>\n<td>4,096</td>\n<td>4,096</td>\n</tr>\n<tr>\n<td>注意力頭數</td>\n<td>16</td>\n<td>16</td>\n<td>16</td>\n</tr>\n<tr>\n<td>層數</td>\n<td>28</td>\n<td>24</td>\n<td>24</td>\n</tr>\n<tr>\n<td>詞彙表大小</td>\n<td>50,368</td>\n<td>250,002</td>\n<td>50,265</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>這種方法與 Meta 的 <a href=\"https://openreview.net/pdf?id=EIGbXbxcUQ&ref=jina-ai-gmbh.ghost.io\">MobileLLM</a> 研究結果一致，該研究發現對於較小的模型來說，在捕捉複雜模式和提升性能方面，深度比寬度更重要。本質上，通過更多 transformer 層處理信息的能力比擁有更寬的層進行並行處理更有價值。</p><p>讓我們看看這種深而窄架構的性能數據。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/01/performance_comparison_general.v3.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"872\" height=\"371\"><figcaption><span style=\"white-space: pre-wrap;\">與使用傳統淺而寬架構的同類模型相比，ModernBERT 在檢索和 STS 等關鍵任務上表現更好 - 同時保持類似的參數數量。</span></figcaption></figure>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ModernBERT-large</th>\n<th><code>jina-XLM-RoBERTa</code></th>\n<th><code>RoBERTa-large</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STS12</td>\n<td>72.6</td>\n<td><strong>72.7</strong></td>\n<td>68.9</td>\n</tr>\n<tr>\n<td>STS13</td>\n<td><strong>84.9</strong></td>\n<td>83.9</td>\n<td>81.0</td>\n</tr>\n<tr>\n<td>STS14</td>\n<td>77.5</td>\n<td><strong>77.7</strong></td>\n<td>74.8</td>\n</tr>\n<tr>\n<td>STS15</td>\n<td>84.8</td>\n<td><strong>85.8</strong></td>\n<td>84.1</td>\n</tr>\n<tr>\n<td>STS16</td>\n<td>79.4</td>\n<td><strong>79.6</strong></td>\n<td>78.6</td>\n</tr>\n<tr>\n<td>STS17</td>\n<td><strong>87.5</strong></td>\n<td>87.2</td>\n<td>87.2</td>\n</tr>\n<tr>\n<td>TRECCOVID</td>\n<td><strong>61.1</strong></td>\n<td>59.6</td>\n<td>49.3</td>\n</tr>\n<tr>\n<td>FiQA</td>\n<td><strong>44.4</strong></td>\n<td>40.0</td>\n<td>40.7</td>\n</tr>\n<tr>\n<td>NFCorpus</td>\n<td><strong>32.6</strong></td>\n<td>30.6</td>\n<td>27.9</td>\n</tr>\n<tr>\n<td>SciFact</td>\n<td><strong>68.6</strong></td>\n<td>65.5</td>\n<td>63.1</td>\n</tr>\n<tr>\n<td>平均值</td>\n<td><strong>69.3</strong></td>\n<td>68.2</td>\n<td>65.6</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>以 <code>jina-XLM-RoBERTa</code> 為例 - 它建立在 <code>RoBERTa-large</code> 的淺而寬架構之上，但將詞彙表從 5 萬擴大到 25 萬個 token，並在更多數據上訓練。然而 ModernBERT 仍然略勝一籌，這表明架構的改變在效率方面產生了實質性的差異。</p><h3 id=\"vocabulary-size-matters\">詞彙表大小很重要</h3><p>首先，讓我們看看 transformer 中詞彙表參數是如何計算的。對於任何 transformer，<code>詞彙表參數 = 不同 token 的數量 × 隱藏維度</code>。以 <code>jina-XLM-RoBERTa</code> 為例：有 25 萬個 token 和 1,024 維度，僅用於詞彙編碼就需要 2.56 億參數 - 這還是在處理任何實際語言任務之前！</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/01/tokenizer-dark-outline.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"3757\" height=\"715\"><figcaption><span style=\"white-space: pre-wrap;\">在 transformers 中，第一層使用權重矩陣（即詞彙權重）將 tokens 映射到隱藏狀態。如果使用所有 UTF-8 編碼點（1,112,064）和 1,024 個隱藏維度，你需要巨大的 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>1,112,064 × 1,024 = 1 B</span></code><span style=\"white-space: pre-wrap;\"> 參數僅用於 token 轉換。雖然更大的 LLM（超過 100B 參數）可以處理這種開銷，但對較小的模型來說是一個嚴重的限制。這就是為什麼我們使用 BPE 這樣的分詞器，它可以有效地將常見的 UTF-8 編碼點合併成單個 tokens。</span></figcaption></figure><p>但是這裡有一個重點：<strong>詞彙權重不會參與注意力機制——它們只是查詢表。</strong>對於在固定參數預算下工作的 SLM 來說，更大的詞彙表意味著用於實際進行語言處理的注意力層可用參數更少。這解釋了為什麼僅支援英語的 ModernBERT-large 雖然較小卻優於多語言的 <code>jina-XLM-RoBERTa</code>——<code>jina-XLM-RoBERTa</code> 分配了更多參數（47%！）來支援多種語言。ModernBERT 專注的詞彙表不僅提升了性能，還加快了推理速度，使其特別適合資源受限的應用場景。</p><p>所以現在如果我們只看核心模型參數（不包括詞彙權重），ModernBERT 實際上比同類模型擁有更多的計算能力：ModernBERT 在真正的語言建模上比 <code>jina-XLM-RoBERTa</code> 多投入了 19% 的參數，比 <code>RoBERTa-large</code> 多 15%！</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>模型規格</th>\n<th>ModernBERT-large</th>\n<th><code>jina-XLM-RoBERTa</code></th>\n<th><code>RoBERTa-large</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>語言支援</td>\n<td>僅英語</td>\n<td>89 種語言</td>\n<td>僅英語</td>\n</tr>\n<tr>\n<td>詞彙表大小</td>\n<td>50.4K</td>\n<td>250K</td>\n<td>50.3K</td>\n</tr>\n<tr>\n<td>總參數量</td>\n<td>400M</td>\n<td>550M</td>\n<td>355M</td>\n</tr>\n<tr>\n<td>詞彙參數量</td>\n<td>51M</td>\n<td>256M</td>\n<td>51M</td>\n</tr>\n<tr>\n<td>詞彙參數比例</td>\n<td>13%</td>\n<td>47%</td>\n<td>14%</td>\n</tr>\n<tr>\n<td>核心模型參數</td>\n<td><b>349M</b></td>\n<td>294M</td>\n<td>304M</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h3 id=\"model-upscaling-by-weight-tiling\">通過「權重平鋪」進行模型擴展</h3><p>在構建 <a href=\"https://huggingface.co/jinaai/jina-bert-implementation?ref=jina-ai-gmbh.ghost.io\"><code>jina-BERT-v2</code></a> 骨幹網路時，我們發現從頭開始訓練 SLM 需要大量資源且複雜。ModernBERT 通過一種稱為<strong>權重平鋪</strong>的智能初始化方法解決了這個問題——本質上是從其較小的基礎版本的權重引導 ModernBERT-large。</p><p>這種技術並不完全是新的——它建立在 DeepMind 的 <a href=\"https://gpt3demo.com/apps/deepmind-gopher?ref=jina-ai-gmbh.ghost.io\">Gopher</a> 工作的基礎上，在微軟的 <a href=\"https://www.microsoft.com/en-us/research/blog/phi-2-the-surprising-power-of-small-language-models/?ref=jina-ai-gmbh.ghost.io\">Phi-2 模型</a>中也有出現。但它在這裡的應用對解決 SLM 訓練瓶頸特別有效。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/01/deep_and_thin-dark.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1877\" height=\"1308\"><figcaption><span style=\"white-space: pre-wrap;\">ModernBERT 使用 Gopher 團隊的深度初始化策略，從 22 層擴展到 28 層。對於那些額外的層（23-28），他們使用 ModernBERT-base 原始 22 層的權重進行初始化。對於每一層的權重矩陣，他們使用 Phi-2 的中心平鋪方法。它是這樣工作的：他們把 ModernBERT-base 的權重放在 ModernBERT-large 矩陣的正中間。對於仍然空著的邊緣部分？他們循環包裹原始權重來填充它們。</span></figcaption></figure><p>這種初始化策略給 ModernBERT-large 帶來了顯著優勢——它不是從頭開始，而是利用了較小版本預先學習的模式。它在<a href=\"https://arxiv.org/pdf/2112.11446?ref=jina-ai-gmbh.ghost.io\">這個規模範圍內擴展語言模型</a>特別有效。</p><blockquote>我們發現熱啟動模型能夠迅速從較高的初始損失（由於增加的參數）恢復，達到接近基礎模型的損失。我們能夠將 417M 參數擴展超過 3 倍，並保持比從頭開始訓練的等效模型更好的性能，這意味著收益不僅限於訓練初期。然而，在更大的規模下，收斂時的相對收益會減少，特別是在寬度擴展方面。</blockquote><p>循環權重包裹不僅僅是為了方便——它與注意力矩陣自然呈現的周期性模式很好地契合。Gopher 的研究表明，這種方法在 SLM（不到 9B 參數）中特別有效，儘管當你進入更大模型領域時，這些好處開始逐漸減少。</p><h2 id=\"modernberts-code-modeling\">ModernBERT 的程式碼建模</h2><p>ModernBERT 通過其程式碼優化的分詞器和訓練數據，為程式碼理解帶來了專門的方法。這種針對程式碼處理的微調在理解和檢索任務中都取得了成效。</p><p>我們使用 <code>jina-embeddings-v2-code</code> 語料庫進行了基準測試，比較了三個模型作為骨幹：<code>ModernBERT</code>、<code>jina-XLM-RoBERTa</code> 和 <code>RoBERTa-large</code>。測試使用 <a href=\"https://github.com/github/CodeSearchNet?ref=jina-ai-gmbh.ghost.io\">CodeSearchNet</a> ——將文本描述與程式碼片段匹配。ModernBERT 在各方面都優於其他兩種選擇。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/01/code_search_net.v3.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"787\" height=\"489\"><figcaption><span style=\"white-space: pre-wrap;\">這個差距是有道理的—— </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-XLM-RoBERTa</span></code><span style=\"white-space: pre-wrap;\"> 和 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>RoBERTa-large</span></code><span style=\"white-space: pre-wrap;\"> 在訓練過程中都沒有接觸過程式語言。與此同時，ModernBERT-large 訓練了兩萬億個 tokens，包括大量的程式碼。這種對程式語法和模式的接觸使它在程式碼相關任務中具有明顯優勢。</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-XLM-RoBERTa</span></code><span style=\"white-space: pre-wrap;\"> 略優於 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>RoBERTa-large</span></code><span style=\"white-space: pre-wrap;\">，可能是因為其更大的多語言訓練數據——相同的架構，更多的接觸。儘管如此，兩者都明顯落後於 ModernBERT-large。</span></figcaption></figure>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>任務</th>\n<th>ModernBERT-large</th>\n<th><code>jina-XLM-RoBERTa</code></th>\n<th><code>RoBERTa-large</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AdvRetrieval</td>\n<td>0.342</td>\n<td><strong>0.363</strong></td>\n<td>0.331</td>\n</tr>\n<tr>\n<td>QueryRetrieval.python</td>\n<td>0.521</td>\n<td><strong>0.530</strong></td>\n<td>0.525</td>\n</tr>\n<tr>\n<td>QueryRetrieval java</td>\n<td><strong>0.679</strong></td>\n<td>0.633</td>\n<td>0.644</td>\n</tr>\n<tr>\n<td>QueryRetrieval.javascript</td>\n<td>0.755</td>\n<td><strong>0.768</strong></td>\n<td>0.732</td>\n</tr>\n<tr>\n<td>QueryRetrieval.php</td>\n<td><strong>0.815</strong></td>\n<td>0.781</td>\n<td>0.755</td>\n</tr>\n<tr>\n<td>QueryRetrieval.ruby</td>\n<td>0.729</td>\n<td><strong>0.744</strong></td>\n<td>0.722</td>\n</tr>\n<tr>\n<td>QueryRetrieval.go</td>\n<td><strong>0.833</strong></td>\n<td>0.809</td>\n<td>0.796</td>\n</tr>\n<tr>\n<td>Retrieval.go</td>\n<td><strong>0.778</strong></td>\n<td>0.750</td>\n<td>0.759</td>\n</tr>\n<tr>\n<td>Retrieval.java</td>\n<td><strong>0.840</strong></td>\n<td>0.792</td>\n<td>0.796</td>\n</tr>\n<tr>\n<td>Retrieval.javascript</td>\n<td><strong>0.817</strong></td>\n<td>0.792</td>\n<td>0.757</td>\n</tr>\n<tr>\n<td>Retrieval.php</td>\n<td><strong>0.852</strong></td>\n<td>0.805</td>\n<td>0.796</td>\n</tr>\n<tr>\n<td>Retrieval.python</td>\n<td><strong>0.849</strong></td>\n<td>0.816</td>\n<td>0.787</td>\n</tr>\n<tr>\n<td>Retrieval.ruby</td>\n<td><strong>0.849</strong></td>\n<td>0.796</td>\n<td>0.803</td>\n</tr>\n<tr>\n<td>Avg.</td>\n<td><strong>0.743</strong></td>\n<td>0.721</td>\n<td>0.708</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h3 id=\"the-tokenizer-edge\">分詞器的優勢</h3><p>讓我們深入了解為什麼 ModernBERT 能夠很好地處理程式碼 - 它使用了專門針對程式碼進行訓練的 <a href=\"https://huggingface.co/docs/transformers/en/model_doc/olmo?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">OLMo tokenizer</a>，而不是標準的 BERT/RoBERTa 分詞器。</p><p>分詞器將 UTF-8 文本分解為可映射到向量的詞符 - 這些是模型實際處理的內容。在訓練期間，它會學習將經常出現的字符序列組合成單個詞符。差異在哪裡？標準分詞器可能會將 <code>init</code> 分解為 <code>in</code> + <code>it</code>，忽略了程式設計的上下文。但 ModernBERT 的程式碼感知分詞器可以完整保留它。</p><p>關於空格處理，事情變得更有趣：ModernBERT 將 Python 的前導空格保留為單個詞符，並區分 4 個和 8 個空格的差異 - 這對程式碼結構至關重要。而 <strong><code>jina-XLM-RoBERTa</code> 將所有連續空格合併為單個 <code>_</code>，RoBERTa-large 則將每個空格都視為獨立的詞符。</strong>這意味著在處理程式碼時，ModernBERT 的編碼器可以獲得更乾淨、更有意義的輸入，而其他模型則在處理零碎、連貫性較差的詞符。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/01/code_tokens-cheat-2.svg\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"3156\" height=\"1247\"><figcaption><span style=\"white-space: pre-wrap;\">ModernBERT 將 Python 的前導空格保留為單個詞符，並區分 4 個和 8 個空格的差異 - 這對程式碼結構至關重要；而其他模型則在處理零碎、連貫性較差的詞符。</span></figcaption></figure><h2 id=\"modernberts-long-context-handling\">ModernBERT 的長文本處理能力</h2><p>ModernBERT 在處理長文本方面取得了重大進展，這要歸功於其龐大的訓練語料庫（3000 億個詞符，每個樣本包含 8,192 個詞符）以及結合全局和局部注意力等先進技術。</p><p>為了評估長文檔處理能力，我們使用了 <a href=\"https://huggingface.co/datasets/Shitao/MLDR?ref=jina-ai-gmbh.ghost.io\">MLDR 數據集</a> - 這是一個涵蓋 13 種語言的綜合長文本基準。由於 ModernBERT 目前僅支持英語，我們專注於 MLDR 的英語子集來對比 ModernBERT 和 <code>jina-XLM-RoBERTa</code>。雖然這兩個模型都能處理 8K 詞符的輸入，但由於 <code>RoBERTa-large</code> 的 512 詞符限制不足以進行長文本分析，因此在這個基準測試中被排除。</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ModernBERT-large</th>\n<th><code>jina-XLM-RoBERTa</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MLDR-en</td>\n<td><strong>0.351</strong></td>\n<td>0.290</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>ModernBERT 的卓越表現不僅歸功於其大量的長文本訓練，更重要的是得益於其創新的全局和局部注意力機制組合。與在每一層都應用計算成本高昂的全局注意力的 <code>jina-XLM-RoBERTa</code> 不同，ModernBERT 採用了更高效的方法。它在全局注意力（每三層使用一次，<code>theta</code> 值為 160,000）和局部注意力（使用 128 詞符的滑動窗口，<code>theta</code> 值為 100,000）之間交替。這種混合策略在保持高性能的同時大大減少了訓練時間。</p><blockquote>在 ModernBERT 中，每三層採用全局注意力，RoPE theta 值為 160,000，其餘層使用 128 詞符的局部滑動窗口注意力，RoPE theta 值為 10,000。—— <a href=\"https://arxiv.org/pdf/2412.13663?ref=jina-ai-gmbh.ghost.io\">ModernBERT</a></blockquote><h2 id=\"the-bitter-lesson\">痛苦的教訓？</h2><p>擴展定律和<a href=\"http://www.incompleteideas.net/IncIdeas/BitterLesson.html?ref=jina-ai-gmbh.ghost.io\">痛苦的教訓</a>表明，性能的主要改進主要來自增加參數數量和訓練數據。這一原則指導我們擴展語料庫並使用 LoRA 進行特定任務適配。</p><p>然而，ModernBERT 的成功表明我們低估了架構優化的力量。它證明了 SLM 可以通過更好的數據模型效率來實現卓越的結果，而不一定要增加參數。最近的<a href=\"https://arxiv.org/pdf/2408.11868?ref=jina-ai-gmbh.ghost.io\">Stella Embeddings 技術報告</a>強化了這一發現，表明當前的嵌入模型訓練方法可以在不增加語料庫或模型規模的情況下得到改進。</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/plot--4-.svg\" class=\"kg-image\" alt=\"Graph showing Scaling Law of Embedding Models with 'Parameter Size' on the x-axis and 'MTEB Performance' on the y-axis, featu\" loading=\"lazy\" width=\"949\" height=\"949\"><figcaption><span style=\"white-space: pre-wrap;\">嵌入模型的擴展定律。圖中展示了英語任務的平均 MTEB 性能與模型參數數量的關係。每個點代表一個嵌入模型。趨勢線代表所有模型，多語言模型以青色突出顯示。可以看到 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\"> 相比同規模模型展現出優異的性能，同時相比其前身 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2</span></code><span style=\"white-space: pre-wrap;\"> 也顯示出超線性的改進。該圖表是通過從 MTEB 排行榜中選取前 100 個嵌入模型創建的，排除了沒有大小信息的模型（通常是封閉源或專有模型）。明顯的惡意提交也被過濾掉了。</span></figcaption></figure><p>展望未來，隨著我們對數據利用的深入理解和 ModernBERT 技術的實施，我們預計計算成本和模型規模都將降低。短期內，我們可以實施 ModernBERT 論文中概述的直接改進 - 特別是整合更多與程式碼相關的數據並採用適合程式碼的分詞器。更複雜的改變，如切換到深而窄的架構或從較小的模型引導大型模型，將需要從頭開始構建骨幹模型 - 這是一個中期計劃。</p><p>雖然 ModernBERT 的效率令人矚目，但其僅限文本的限制指出了未來的挑戰。隨著多模態嵌入模型的普及，我們的下一個挑戰是開發更智能、更快速、更具能力的搜尋基礎模型，以處理多模態應用的輸入。這些應用需要更長的上下文窗口 - 這是一個尚待解決的效率挑戰。</p><h2 id=\"conclusion\">結論</h2><p>在本文中，我們探討了 ModernBERT 如何通過三個關鍵創新推進 BERT 家族模型：其深而窄的架構、優化的分詞器以及使用權重平鋪的高效擴展。這些改進使 ModernBERT 能夠在相對緊湊的規模下提供出色的性能，在各種任務中超越 <code>RoBERTa-large</code> 和 <code>jina-XLM-RoBERTa</code>。ModernBERT 證明了架構改進可能比參數規模更重要，為更高效的模型開闢了道路。其成功運用權重平鋪表明，漸進式擴展可以在保持或甚至提升性能的同時降低訓練成本。此外，其緊湊的詞彙表和針對性優化表明，在資源有限的環境下，專門的 SLM 具有越來越多的機會。</p>",
  "comment_id": "678cc6a18f6bb40001a63537",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/01/modernbert.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-01-19T10:32:17.000+01:00",
  "updated_at": "2025-01-22T08:31:26.000+01:00",
  "published_at": "2025-01-22T08:31:26.000+01:00",
  "custom_excerpt": "Bigger training data, efficient parameter sizing, and a deep-but-thin architecture, ModernBERT sets a direction for future BERT-like models.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "678e14a78f6bb40001a63595",
      "name": "Nan Wang",
      "slug": "nan",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/01/avartar_2024.jpeg",
      "cover_image": null,
      "bio": "Co-founder & CTO @JinaAI | Ex-Zalando & Tencent | Build AI models & systems | Open-source enthusiast | Speaker & contributor (40+ talks) | PhD in Computational Neuroscience @ Ruhr University Bochum",
      "website": null,
      "location": "Global",
      "facebook": null,
      "twitter": "@nanwang_t",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/nan/"
    },
    {
      "id": "632ade4a3e4e55003d525971",
      "name": "Alex C-G",
      "slug": "alexcg",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/09/alex.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/twitter_banner.jpg",
      "bio": "Open-source Evangelist @ Jina AI. Old, grim, and full of Vim",
      "website": null,
      "location": "Berlin, Germany",
      "facebook": null,
      "twitter": "@alexcg",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/alexcg/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "678e14a78f6bb40001a63595",
    "name": "Nan Wang",
    "slug": "nan",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/01/avartar_2024.jpeg",
    "cover_image": null,
    "bio": "Co-founder & CTO @JinaAI | Ex-Zalando & Tencent | Build AI models & systems | Open-source enthusiast | Speaker & contributor (40+ talks) | PhD in Computational Neuroscience @ Ruhr University Bochum",
    "website": null,
    "location": "Global",
    "facebook": null,
    "twitter": "@nanwang_t",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/nan/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/what-should-we-learn-from-modernbert/",
  "excerpt": "更大的訓練資料、高效的參數配置，以及深而窄的架構，ModernBERT 為未來類 BERT 模型指出了發展方向。",
  "reading_time": 10,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}