{
  "slug": "can-embedding-reranker-models-compare-numbers",
  "id": "66a15523ac62ce0001aa02c8",
  "uuid": "7e5e7622-20e9-4060-9b1d-8a3b4e2588ba",
  "title": "Les modèles d'Embedding/Reranker peuvent-ils comparer des nombres ?",
  "html": "<p>Voici une question qui m'a été posée aujourd'hui à la conférence ICML à Vienne.</p><p>Pendant la pause café, un utilisateur de Jina m'a abordé avec une question issue de discussions récentes dans la communauté LLM. Il m'a demandé si notre modèle d'embedding pouvait déterminer que 9.11 est <em>plus petit</em> que 9.9, une tâche où de nombreux LLM se trompent.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">9.11 is bigger than 9.9. <a href=\"https://t.co/zBrdLGAoH2?ref=jina-ai-gmbh.ghost.io\">pic.twitter.com/zBrdLGAoH2</a></p>— Riley Goodside (@goodside) <a href=\"https://twitter.com/goodside/status/1812977352085020680?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">July 15, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><p>« Honnêtement, je ne sais pas », ai-je répondu. Alors qu'il expliquait l'importance de cette capacité pour son application et suggérait que <strong>la tokenization pourrait être la source du problème</strong>, j'acquiesçais - mon esprit fourmillait déjà d'idées pour une expérience qui révélerait la réponse.</p><p>Dans cet article, je souhaite tester si notre modèle d'embedding, <code>jina-embeddings-v2-base-en</code> (sorti en octobre 2023), et le Reranker, <code>jina-reranker-v2-multilingual</code> (sorti en juin 2024), peuvent comparer précisément les nombres. Pour élargir le champ au-delà de la simple comparaison entre 9.11 et 9.9, j'ai conçu une série d'expériences incluant différents types de nombres : petits entiers, grands nombres, décimaux, nombres négatifs, devises, dates et heures. L'objectif est d'évaluer l'efficacité de nos modèles dans le traitement de différents formats numériques.</p><h2 id=\"experimental-setup\">Protocole expérimental</h2><p>L'implémentation complète est disponible dans le Colab ci-dessous :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/11kUxYhHMLqYhw5HVKEYdHv0EfdZIyBBy?ref=jina-ai-gmbh.ghost.io#scrollTo=G7Cy9zSb2Ukg\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://ssl.gstatic.com/colaboratory-static/common/7f9df66b1941b18be03f2115a7ab9255/img/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://colab.research.google.com/img/colab_favicon_256px.png\" alt=\"\"></div></a></figure><p>La conception de l'expérience est assez simple. Par exemple, pour vérifier si le modèle d'embedding comprend les nombres entre [1, 100]. Les étapes sont les suivantes :</p><ol><li><strong>Construire les Documents</strong> : Générer des documents \"chaînes littérales\" pour chaque nombre de <code>1</code> à <code>100</code>.</li><li><strong>Envoyer à l'API d'Embedding</strong> : Utiliser <a href=\"https://jina.ai/embeddings?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">l'API d'Embedding</a> pour obtenir les embeddings de chaque document.</li><li><strong>Calculer la Similarité Cosinus</strong> : Calculer la similarité cosinus par paires pour chaque couple de documents afin de créer une matrice de similarité.</li><li><strong>Faire un Nuage de Points</strong> : Visualiser les résultats avec un nuage de points. Chaque élément $(i, j)$ dans la matrice de similarité est cartographié en un point avec : Axe X : $(i - j)$ ; Axe Y : la valeur de similarité de $(i, j)$</li></ol><p>Si le delta $(i - j)$ est zéro, c'est-à-dire $i = j$, alors la similarité sémantique devrait être maximale. À mesure que le delta $(i - j)$ augmente, la similarité devrait diminuer. <strong>Idéalement, la similarité devrait être linéairement proportionnelle à la valeur delta.</strong> Si nous ne pouvons pas observer une telle linéarité, alors il est probable que le modèle ne comprenne pas les nombres et puisse produire des erreurs comme considérer que 9.11 est supérieur à 9.9.</p><p>Le modèle Reranker suit une procédure similaire. La différence principale est que nous parcourons les documents construits, en définissant chacun comme <code>query</code> en ajoutant le prompt <code>\"what is the closest item to...\"</code> et en classant tous les autres comme <code>documents</code>. Le score de pertinence renvoyé par <a href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">l'API Reranker</a> est utilisé directement comme mesure de similarité sémantique. L'implémentation principale ressemble à ceci.</p><pre><code class=\"language-python\">def rerank_documents(documents):\n    reranker_url = \"https://api.jina.ai/v1/rerank\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Initialize similarity matrix\n    similarity_matrix = np.zeros((len(documents), len(documents)))\n\n    for idx, d in enumerate(documents):\n        payload = {\n            \"model\": \"jina-reranker-v2-base-multilingual\",\n            \"query\": f\"what is the closest item to {d}?\",\n            \"top_n\": len(documents),\n            \"documents\": documents\n        }\n    ...</code></pre><h2 id=\"can-models-compare-numbers-between-1-2-3-100\">Les Modèles Peuvent-ils Comparer les Nombres Entre [1, 2, 3, ..., 100] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--0-100-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--0-100---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">Nuage de points avec moyenne et variance sur chaque delta. Gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; Droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i) for i in range(1, 101)]</span></code></p></figcaption></figure><h3 id=\"how-to-read-these-plots\">Comment Lire Ces Graphiques</h3><p>Avant de poursuivre avec d'autres expériences, laissez-moi d'abord expliquer comment lire correctement ces graphiques. Tout d'abord, mon observation des deux graphiques ci-dessus est que le modèle d'embedding performe bien, tandis que le modèle reranker ne s'en sort pas aussi bien. Alors, que regardons-nous et pourquoi ?</p><p>L'axe X représente le delta des indices $(i,j)$, ou $i-j$, lorsque nous échantillonnons uniformément $d_i$ et $d_j$ de nos ensembles de documents. Ce delta varie de $[-100, 100]$. Puisque notre ensemble de documents est trié par construction, c'est-à-dire que plus $|i-j|$ est petit, plus $d_i$ et $d_j$ sont sémantiquement proches ; plus $i$ et $j$ sont éloignés, plus la similarité entre $d_i$ et $d_j$ est faible. C'est pourquoi vous voyez la similarité (représentée par l'axe Y) atteindre un pic à $X=0$ puis diminuer linéairement en se déplaçant à gauche et à droite.</p><p>Idéalement, cela devrait créer un pic prononcé ou une forme de \"flèche vers le haut\" comme <code>^</code>. Cependant, ce n'est pas toujours le cas. Si vous fixez l'axe X à un point, disons $X=25$, et regardez le long de l'axe Y, vous trouverez des valeurs de similarité allant de 0,80 à 0,95. Cela signifie que $\\mathrm{sim}(d_27, d_2)$ peut être 0,81 alors que $\\mathrm{sim}(d_42, d_17)$ peut être 0,91 bien que leurs delta soient tous de 25.</p><p>La ligne de tendance cyan montre la similarité moyenne à chaque valeur X avec l'écart-type. Notez également que la similarité devrait diminuer linéairement car notre ensemble de documents est espacé uniformément, assurant des intervalles égaux entre les documents contigus.</p><p>Notez que les graphiques d'embedding seront <strong>toujours symétriques, avec la plus grande valeur Y de 1,0</strong> à $X=0$. Ceci est dû au fait que la similarité cosinus est symétrique pour $d_i$ et $d_j$, et $\\cos(0)=1$.</p><p>En revanche, les graphiques du reranker sont <strong>toujours asymétriques</strong> en raison des différents rôles de la requête et des documents dans le modèle reranker. <strong>La valeur maximale n'est probablement pas 1,0</strong> car $X=0$ signifie que nous utilisons le reranker pour calculer le score de pertinence de <code>\"what is the closest item to 4\"</code> vs <code>\"4\"</code>. Si vous y réfléchissez, il n'y a aucune garantie que $X=0$ conduise à la valeur Y maximale.</p><h2 id=\"can-models-compare-negative-numbers-between10099981\">Les Modèles Peuvent-ils Comparer les Nombres Négatifs Entre [-100, -99, -98, ..., -1] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in---100--1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in---100--1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">Nuage de points avec moyenne et variance sur chaque delta. Gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; Droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">. Ici nous voulons tester si le modèle peut déterminer la similarité sémantique dans l'espace négatif. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(-i) for i in range(1, 101)]</span></code></p></figcaption></figure><h2 id=\"can-models-compare-numbers-with-larger-intervals-1000-2000-3000-100000\">Les Modèles Peuvent-ils Comparer les Nombres avec de Plus Grands Intervalles [1000, 2000, 3000, ..., 100000] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--1000-100000-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--1000-100000---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> Ici, nous voulons tester si le modèle peut déterminer la similarité sémantique lorsque nous comparons des nombres avec un intervalle de 1000. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i*1000) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> Diagramme de dispersion avec moyenne et variance pour chaque delta. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-numbers-from-an-arbitrary-range-eg-376-377-378-476\">Les modèles peuvent-ils comparer des nombres d'une plage arbitraire, par exemple [376, 377, 378, ..., 476] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--376-476-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--376-476---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> Ici, nous voulons tester si le modèle peut déterminer la similarité sémantique lorsque nous comparons des nombres dans une plage arbitraire, nous déplaçons donc les nombres vers une plage aléatoire </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i+375) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> . Diagramme de dispersion avec moyenne et variance pour chaque delta. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-large-numbers-between-4294967296-4294967297-4294967298-4294967396\">Les modèles peuvent-ils comparer de grands nombres entre [4294967296, 4294967297, 4294967298, ..., 4294967396] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--4294967296-4294967396---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--4294967296-4294967396-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> Ici, nous voulons tester si le modèle peut déterminer la similarité sémantique lorsque nous comparons de très grands nombres. Similaire à l'idée de la dernière expérience, nous déplaçons la plage vers un grand nombre. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i+4294967296) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> Diagramme de dispersion avec moyenne et variance pour chaque delta. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-float-numbers-between-00001-00002-00003-01-wo-fixed-digits\">Les modèles peuvent-ils comparer des nombres décimaux entre [0.0001, 0.0002, 0.0003, ...,0.1] ? (sans digits fixes)</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--0.0001-0.01-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--0.0001-0.01-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> Ici, nous voulons tester si le modèle peut déterminer la similarité sémantique lorsque nous comparons des nombres décimaux. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i/1000) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> Diagramme de dispersion avec moyenne et variance pour chaque delta. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-currency-numbers-between-1-2-3-100\">Les modèles peuvent-ils comparer des montants monétaires entre [$1, $2, $3, ..., $100] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in---1---100-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in---1---100-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> Ici, nous voulons tester si le modèle peut déterminer la similarité sémantique lorsque nous comparons des nombres monétaires. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = ['$'+str(i) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> Diagramme de dispersion avec moyenne et variance pour chaque delta. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-date-between-2024-07-24-2024-07-25-2024-07-26-2024-10-31\">Les modèles peuvent-ils comparer des dates entre [2024-07-24, 2024-07-25, 2024-07-26, ..., 2024-10-31] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-date-between-2024-07-24-and-2024-10-31.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-date-between-2024-07-24-and-2024-10-31.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> Ici, nous voulons tester si le modèle peut déterminer la similarité sémantique lorsque nous comparons des nombres au format date, c'est-à-dire AAAA-MM-JJ. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>today = datetime.today(); documents = [(today + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(100)]</span></code><span style=\"white-space: pre-wrap;\"> Diagramme de dispersion avec moyenne et variance pour chaque delta. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-time-between-190007-190008-190009-203907\">Les modèles peuvent-ils comparer des heures entre [19:00:07, 19:00:08, 19:00:09,..., 20:39:07] ?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-date-between-19_00_07-and-20_39_07.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-time-between-19_00_07-and-20_39_07.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> Ici, nous voulons tester si le modèle peut détecter la similarité sémantique lors de la comparaison de nombres au format horaire, c'est-à-dire </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>hh:mm:ss</span></code><span style=\"white-space: pre-wrap;\">. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>now = datetime.now(); documents = [(now + timedelta(minutes=i)).strftime('%H:%M:%S') for i in range(100)]</span></code><span style=\"white-space: pre-wrap;\"> Nuage de points avec moyenne et variance sur chaque delta. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"observations\">Observations</h2><p>Voici quelques observations tirées des graphiques ci-dessus :</p><h3 id=\"reranker-models\"><strong>Modèles Reranker</strong></h3><ul><li>Les modèles Reranker ont du mal à comparer les nombres. Même dans le cas le plus simple de comparaison de nombres entre [1, 100], leurs performances sont médiocres.</li><li>Il est important de noter la construction spéciale de la requête utilisée pour nos rerankers, c'est-à-dire <code>what is the closest item to x</code>, car cela peut également influencer les résultats.</li></ul><h3 id=\"embedding-models\"><strong>Modèles d'Embedding</strong></h3><ul><li>Les modèles d'embedding fonctionnent assez bien pour comparer de petits nombres entiers dans l'intervalle [1, 100] ou des nombres négatifs dans [-100, 1]. Cependant, leurs performances se dégradent significativement lors du décalage de cette plage vers d'autres valeurs, de l'ajout d'intervalles supplémentaires ou du traitement de nombres flottants plus grands ou plus petits.</li><li>Des pics réguliers peuvent être observés à certains intervalles, généralement tous les 10 pas. Ce comportement peut être lié à la façon dont le tokenizer traite les chaînes, potentiellement en tokenisant une chaîne en \"10\" ou \"1\" et \"0\".</li></ul><h3 id=\"date-and-time-understanding\"><strong>Compréhension des Dates et Heures</strong></h3><ul><li>Fait intéressant, les modèles d'embedding semblent avoir une bonne compréhension des dates et des heures, les comparant correctement la plupart du temps. Pour les graphiques de dates, des pics apparaissent tous les 30/31 pas, correspondant au nombre de jours dans un mois. Pour les graphiques temporels, des pics apparaissent tous les 60 pas, correspondant aux minutes dans une heure.</li><li>Les modèles reranker semblent également capturer cette compréhension dans une certaine mesure.</li></ul><h3 id=\"visualizing-similarity-to-zero\">Visualisation de la Similarité avec \"Zéro\"</h3><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-text\">Mis à jour le 29 juillet 2024</div></div><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/1S9qZQ0jjdKLNUT2GKqPbU4ogpDe6g9Qh?ref=jina-ai-gmbh.ghost.io#scrollTo=nvAX2GOpCiRt\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://ssl.gstatic.com/colaboratory-static/common/00df39d73993c0a4c5694ba86c20cc85/img/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://colab.research.google.com/img/colab_favicon_256px.png\" alt=\"\"></div></a></figure><p>Une autre expérience intéressante, probablement plus intuitive, consiste à visualiser directement le score de similarité ou de pertinence entre n'importe quel nombre et zéro (c'est-à-dire l'origine). En fixant le point de référence comme l'embedding de zéro, nous voulons voir si la similarité sémantique diminue linéairement à mesure que les nombres augmentent. Pour le reranker, nous pouvons fixer la requête à <code>\"0\"</code> ou <code>\"What is the closest number to number zero?\"</code> et classer tous les nombres pour voir si leurs scores de pertinence diminuent à mesure que les nombres augmentent. Les résultats sont présentés ci-dessous :</p><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Embedding-representation.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Rerank-Documents.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">Ici, nous fixons l'\"embedding d'origine\" à l'embedding de \"zéro\" et vérifions si la similarité sémantique entre n'importe quel nombre et zéro est proportionnelle à la valeur du nombre. Plus précisément, nous utilisons </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i) for i in range(2048)]</span></code><span style=\"white-space: pre-wrap;\">. Le nuage de points avec moyenne et variance pour chaque delta est montré. À gauche : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\"> ; À droite : </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"conclusion\">Conclusion</h2><p>Cet article illustre comment nos modèles d'embedding et de reranking actuels gèrent les comparaisons de nombres. Malgré la configuration expérimentale relativement simple, elle expose certaines failles fondamentales dans les modèles actuels et fournit des informations précieuses pour le développement de notre prochain embedding et reranker.</p><p>Deux facteurs clés déterminent si un modèle peut comparer précisément les nombres : </p><p><strong>Premièrement, la tokenization :</strong> Si le vocabulaire n'inclut que les chiffres 0-9, alors 11 pourrait être tokenisé en tokens séparés 1 et 1, ou comme un seul token 11. Ce choix impacte la compréhension des valeurs numériques par le modèle.</p><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-10.jpg\" width=\"1520\" height=\"1430\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/07/Untitled-10.jpg 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/07/Untitled-10.jpg 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-10.jpg 1520w\" sizes=\"(min-width: 720px) 720px\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-1234.jpg\" width=\"1502\" height=\"1420\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/07/Untitled-1234.jpg 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/07/Untitled-1234.jpg 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-1234.jpg 1502w\" sizes=\"(min-width: 720px) 720px\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">Différents tokenizers entraînent différentes interprétations de 9.11. Cela peut affecter l'apprentissage contextuel en aval. Source : </span><a href=\"https://huggingface.co/spaces/Xenova/the-tokenizer-playground?ref=jina-ai-gmbh.ghost.io\"><span style=\"white-space: pre-wrap;\">The Tokenizer Playground sur HuggingFace.</span></a></p></figcaption></figure><p><strong>Deuxièmement, les données d'entraînement :</strong> Le corpus d'entraînement influence significativement les capacités de raisonnement numérique du modèle. Par exemple, si les données d'entraînement incluent principalement de la documentation logicielle ou des dépôts GitHub où le versionnage sémantique est courant, le modèle pourrait interpréter que 9.11 est supérieur à 9.9, car 9.11 est la version mineure suivant 9.9.</p><p>La capacité arithmétique des modèles de recherche dense, tels que les embeddings et les rerankers, est cruciale pour les tâches impliquant RAG et la recherche et le raisonnement avancés. De fortes capacités de raisonnement numérique peuvent améliorer significativement la qualité de la recherche, particulièrement lors du traitement de données structurées comme JSON.</p>",
  "comment_id": "66a15523ac62ce0001aa02c8",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/07/number-heading.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-07-24T21:25:23.000+02:00",
  "updated_at": "2024-07-29T18:47:03.000+02:00",
  "published_at": "2024-07-25T00:42:49.000+02:00",
  "custom_excerpt": "A lot of LLMs can't figure out that 9.11 is actually smaller than 9.9. Can our embedding and reranker models do any better?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/can-embedding-reranker-models-compare-numbers/",
  "excerpt": "De nombreux LLMs ne parviennent pas à comprendre que 9.11 est en réalité plus petit que 9.9. Nos modèles d'embedding et de reranking peuvent-ils faire mieux ?",
  "reading_time": 10,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Rows of numbered wooden pieces on a white background, ranging from single digits to high numbers.",
  "feature_image_caption": null
}