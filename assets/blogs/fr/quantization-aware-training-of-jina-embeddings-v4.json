{
  "slug": "quantization-aware-training-of-jina-embeddings-v4",
  "id": "685d4b76f1bef30001fc5449",
  "uuid": "6b06b483-2d13-4f1d-8d9d-147fa6dffe4b",
  "title": "Formation tenant compte de la quantification de jina-embeddings-v4",
  "html": "<p>La quantification est une méthode largement utilisée pour résoudre les problèmes de mise à l'échelle en IA. Le nom peut sembler compliqué, mais il s'agit simplement d'arrondir les nombres pour qu'ils prennent moins de place. Cela signifie des vecteurs de modèles (Embeddings) plus petits qui prennent moins de mémoire et d'espace de stockage, et une récupération d'informations plus rapide car il faut moins de temps pour comparer les vecteurs. La quantification est une technique purement numérique qui ne se soucie pas du type de données que votre modèle traite ni de vos cas d'utilisation. Elle peut donc apporter des améliorations sans nécessiter beaucoup de connaissances spécialisées coûteuses.</p><p>On pourrait s'attendre à ce que la quantification implique de bons vieux compromis et que rien ne soit gratuit, où nous devons sacrifier une certaine précision. Dans cet article, nous allons vous montrer un moyen de la rendre <strong>sans perte</strong> grâce à l'<em>apprentissage tenant compte de la quantification</em> (QAT). Cette technique est utilisée dans <code>jina-embeddings-v4</code> pour fournir des modèles plus petits qui sont nécessaires dans les applications où l'espace est critique.</p><h2 id=\"overview-of-quantization-techniques\">Aperçu des techniques de quantification</h2><p>La quantification de modèle signifie généralement l'une des quatre choses suivantes :</p><ul><li>Quantification post-formation (<strong>PTQ</strong>)</li><li>Formation pour des sorties de modèles quantifiés (<strong>Output QAT</strong>)</li><li>Formation pour des modèles entièrement quantifiés (<strong>Full QAT</strong>)</li><li>Distiller un nouveau modèle quantifié à partir d'un modèle non quantifié existant</li></ul><p>La quantification post-formation (<strong>PTQ</strong>) accepte le modèle de modèles entraîné tel quel et ne le modifie en aucune façon. Il s'agit simplement de jeter les chiffres les moins significatifs des valeurs à virgule flottante produites par le modèle. Nous arrondissons simplement les nombres et les mettons parfois à l'échelle dans une plage.</p><p><strong>Output QAT</strong> signifie affiner le modèle de modèles pour produire des vecteurs de précision réduite optimaux. Cela signifie modifier le modèle, mais cela ne change pas la précision des poids du modèle, et ne réduit donc pas sa taille. Seule la taille du vecteur de sortie est réduite.</p><p><strong>Full QAT</strong> commence avec un modèle de pleine précision entièrement formé et réduit la précision des poids du modèle, puis affine les performances de ce modèle modifié. Cela produit un modèle significativement plus petit ainsi que des modèles plus petits, au prix d'un certain affinage.</p><p>La <strong>distillation</strong> est le processus de formation d'un nouveau modèle pour qu'il corresponde aux performances d'un modèle existant. Cela signifie créer un nouveau modèle conçu dès le départ comme quantifié, puis utiliser le modèle existant pour générer autant de données de formation que nécessaire pour l'entraîner jusqu'à ce qu'il fonctionne aussi près que possible du modèle existant.</p><p>Les avantages de ces quatre approches sont résumés dans le tableau ci-dessous :</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Approche</th>\n<th>Modèles plus compacts ?</th>\n<th>Nécessite une formation ?</th>\n<th>Compression du modèle ?</th>\n<th>Inférence plus rapide ?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>PTQ</strong></td>\n<td><strong>✓</strong></td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Output QAT</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Full QAT</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td><strong>Distillation</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><em>(vers un modèle plus petit)</em></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Les quatre approches produisent des modèles plus compacts, mais à part la PTQ, toutes nécessitent une formation supplémentaire, tandis que seules la Full QAT et la distillation produisent de nouveaux modèles plus rapides. La Full QAT et la distillation sont beaucoup plus coûteuses à mettre en œuvre car elles nécessitent beaucoup plus de formation que l'Output QAT.</p><p>Dans cet article, nous n'allons examiner que la PTQ et l'Output QAT, qui ne modifient pas la taille ou la vitesse du modèle de modèles.</p><h2 id=\"experimental-setup\">Configuration expérimentale</h2><p>Pour ces expériences, notre modèle de base est <code>jina-embeddings-v4</code> avec l'adaptateur de récupération, qui produit des vecteurs à virgule flottante de précision 32 bits (FP32) en 2048 dimensions. Chaque modèle fait donc 8196 octets, soit 8 Ko.</p><p>Nous avons étudié plusieurs conditions expérimentales en utilisant des tâches d'évaluation de la récupération de requêtes-documents de la suite <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR benchmark</a>. Le processus de récupération utilise la similarité cosinus entre les vecteurs pour trouver et classer les documents qui correspondent le mieux aux requêtes.</p><ul><li><strong>Base de référence</strong> — Les performances des vecteurs de modèles <code>jina-embeddings-v4</code> sans aucune quantification. Ces expériences ont toutes utilisé une version bêta du modèle, et les performances de la version sont légèrement meilleures.</li><li><strong>PTQ</strong> — Nous avons quantifié les vecteurs de sortie en vecteurs binaires sans modifier le modèle.</li><li><strong>Output QAT</strong> — Nous avons quantifié les vecteurs de sortie et appliqué un affinage à l'adaptateur de récupération pour améliorer ses performances dans des conditions quantifiées.</li></ul><h3 id=\"quantization-levels\">Niveaux de quantification</h3><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"816\" height=\"636\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image.png 816w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Figure 1 : Comparaison des tailles de modèles post-quantification.</span></figcaption></figure><p>Nous avons expérimenté quatre niveaux de quantification différents.</p><ul><li><strong>Entiers 8 bits</strong> — Les valeurs FP32 sont réduites à des entiers dans la plage de -128 à 127, ce qui réduit les modèles de 4 fois à <strong>2048 octets</strong>.</li><li><strong>Entiers 4 bits</strong> - Identique aux entiers 4 bits, mais nous mappons à la plage de -8 à 7, ce qui réduit la taille des vecteurs d'un facteur 8, à <strong>1024 octets</strong>.</li><li><strong>Quantification trinaire</strong> — Toutes les valeurs sont mappées à l'une des trois valeurs : -1, 0, 1. Stocké de manière optimale, cela réduit chaque dimension à 1,6 bit, ce qui réduit la taille des vecteurs de modèles d'environ 40 fois à environ <strong>230 octets</strong>.</li><li><strong>Quantification binaire</strong> — Nous convertissons les valeurs scalaires FP32 en un bit, en utilisant le type de données <code>torch.sign</code>, qui ne fournit que deux valeurs, prenant un bit à stocker. Cela réduit les vecteurs de modèles 2048 dimensions de 8192 octets à <strong>128 octets</strong>, une réduction de 64 fois.</li></ul><h3 id=\"scaling\">Mise à l'échelle</h3><p>Pour la quantification binaire, la quantification est très simple : si une valeur de vecteur est supérieure à 0 ou positive, elle est mappée à 1. Sinon, elle est mappée à -1.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-1.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1159\" height=\"221\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-1.png 1159w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Figure 2 : Quantification binaire. Toutes les valeurs négatives deviennent -1, toutes les autres 1.</span></figcaption></figure><p>Pour les autres scénarios de quantification, nous avons normalisé les valeurs dans une plage, puis arrondi à la valeur la plus proche autorisée par le niveau de quantification. Les vecteurs de modèles sont constitués de nombres d'échelle entre -∞ et +∞ (ou, en pratique, de très grands nombres positifs et négatifs). Nous utilisons deux nombres, $max$ et $min$, pour mettre à l'échelle les valeurs pour la quantification.</p><p>Pour la quantification trinaire, nous prenons chaque composante de vecteur $v$ et la traduisons comme suit :</p><ul><li>si $v$ ≥ $max$, $v$ devient 1.</li><li>si $v$ ≤ $min$, $v$ devient -1.</li><li>si $min$ &lt; $v$ &lt; $max$, $v$ devient 0.</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-2.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1030\" height=\"220\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-2.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-2.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-2.png 1030w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Figure 3 : Quantification trinaire. Un intervalle est défini et les valeurs à l'intérieur deviennent 0. Toutes les valeurs inférieures deviennent -1, et toutes les valeurs supérieures 1.</span></figcaption></figure><p>Pour les entiers 4 bits :</p><ul><li>si $v$ ≥ $max$, $v$ devient 7.</li><li>si $v$ ≤ $min$, $v$ devient -8.</li><li>si $min$ &lt; $v$ &lt; $max$, $v$ devient $16*(v - min)/(max - min) - 8$, puis arrondi à l'entier le plus proche. Cela met l'échelle la valeur dans la plage $[-8,7]$.</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-3.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1023\" height=\"221\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-3.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-3.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-3.png 1023w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Figure 4 : Quantification 4 bits. Un intervalle est défini et toutes les valeurs sont normalisées dans la plage définie [-8,7].</span></figcaption></figure><p></p><p>Pour les entiers 8 bits :</p><ul><li>si $v$ ≥ $max$, $v$ devient 127.</li><li>si $v$ ≤ $min$, $v$ devient -128.</li><li>si $min$ &lt; $v$ &lt; $max$, $v$ devient $256*(v - min)/(max - min) - 128$, arrondi à l'entier le plus proche. Cela met l'échelle la valeur dans la plage $[-128,127]$.</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-4.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1023\" height=\"219\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/06/image-4.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/06/image-4.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/06/image-4.png 1023w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Figure 5 : Quantification 8 bits. Un intervalle est défini et toutes les valeurs sont normalisées dans la plage définie [-128,127].</span></figcaption></figure><p>Pour calculer $max$ et $min$, nous avons utilisé deux approches :</p><ul><li><strong>Min/Max</strong> — Nous avons traité nos données par lots, et pour chaque lot, nous avons identifié la composante de vecteur la plus élevée et la plus basse, en définissant $max$ sur la plus élevée et $min$ sur la plus basse.</li><li><strong>Moyenne mobile sur les lots</strong> — Pour chaque lot, nous avons calculé la moyenne et l'écart type des composantes de vecteur. Nous avons maintenu une moyenne mobile à la fois de la moyenne et de l'écart type au fur et à mesure que nous traitions tous les lots. Si $avg$ est la moyenne mobile actuelle des valeurs moyennes des lots, et $std$ est la moyenne mobile actuelle des écarts types, alors pour chaque lot :</li></ul><p>$max = avg + std$<br>$min = avg - std$</p><h3 id=\"qat-fine-tuning\">Affinage QAT</h3><p>Pour les expériences PTQ, nous avons utilisé le modèle tel quel et quantifié les modèles qu'il a produits en utilisant les méthodes décrites ci-dessus.</p><p>Pour l'Output QAT, nous avons affiné le modèle en utilisant l'<em>estimation directe</em>. Cela signifie que nous inversons le processus de quantification, en restaurant la pleine précision aux valeurs, avant de calculer la perte (c'est-à-dire l'erreur), puis nous utilisons cette métrique de perte pour affiner le modèle.</p><p>Nous avons affiné dans chaque cas pendant 10 000 étapes, en sauvegardant un point de contrôle tous les 500 étapes. Nous avons ensuite conservé le point de contrôle avec le score le plus élevé sur le banc d’essai <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a>.</p><h3 id=\"asymmetric-quantization\">Quantification asymétrique</h3><p>La quantification post-formation (PTQ) et la quantification Output Aware Training (QAT) réduisent la taille des vecteurs du modèle d' 向量模型 (Embeddings), mais ne réduisent pas la taille du modèle ni la vitesse d’inférence ; toutes les économies se trouvent dans la taille des modèles d' 向量模型 (Embeddings) de document stockés et la vitesse de récupération.</p><p>Par conséquent, nous avons testé la quantification des vecteurs de requête et le fait de les laisser non quantifiés au moment de la récupération, car cela ne change pas la taille des vecteurs d' 向量模型 (Embeddings) stockés de toute façon.</p><h2 id=\"results\">Résultats</h2><p>Nous avons testé neuf conditions au total, résumées dans les tableaux ci-dessous :</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Nom de la condition</th>\n<th>Affinage</th>\n<th>Niveau de quantification</th>\n<th>Stratégie de mise à l’échelle</th>\n<th>Requêtes quantifiées</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Référence</td>\n<td>❌</td>\n<td>s.o.</td>\n<td>s.o.</td>\n<td>s.o.</td>\n</tr>\n<tr>\n<td>PTQ Les deux</td>\n<td>❌</td>\n<td>Binaire</td>\n<td>s.o.</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>PTQ Documents uniquement</td>\n<td>❌</td>\n<td>Binaire</td>\n<td>s.o.</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>QAT Binaire</td>\n<td><strong>✓</strong></td>\n<td>Binaire</td>\n<td>s.o.</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT Documents binaires uniquement</td>\n<td><strong>✓</strong></td>\n<td>Binaire</td>\n<td>s.o.</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>QAT Ternaire</td>\n<td><strong>✓</strong></td>\n<td>Ternaire</td>\n<td>Moyenne glissante</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 4 bits</td>\n<td><strong>✓</strong></td>\n<td>4 bits</td>\n<td>Moyenne glissante</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT 8 bits</td>\n<td><strong>✓</strong></td>\n<td>8 bits</td>\n<td>Moyenne glissante</td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>QAT Min./Max. 8 bits</td>\n<td><strong>✓</strong></td>\n<td>8 bits</td>\n<td>Min./Max.</td>\n<td><strong>✓</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p><em>Tableau 2 : Conditions expérimentales</em></p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Nom de la condition</th>\n<th>Score moyen</th>\n<th>Différence par rapport à la référence</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Référence</td>\n<td>60,10</td>\n<td>s.o.</td>\n</tr>\n<tr>\n<td>PTQ Binaire</td>\n<td>58,33</td>\n<td>-1,78</td>\n</tr>\n<tr>\n<td>PTQ Documents binaires uniquement</td>\n<td>59,08</td>\n<td>-1,02</td>\n</tr>\n<tr>\n<td>QAT Binaire</td>\n<td>59,22</td>\n<td>-0,89</td>\n</tr>\n<tr>\n<td>QAT Documents binaires uniquement</td>\n<td>60,81</td>\n<td>+0,70</td>\n</tr>\n<tr>\n<td>QAT Ternaire</td>\n<td>59,49</td>\n<td>-0,62</td>\n</tr>\n<tr>\n<td>QAT 4 bits</td>\n<td>61,73</td>\n<td>+1,62</td>\n</tr>\n<tr>\n<td>QAT 8 bits</td>\n<td>61,67</td>\n<td>+1,56</td>\n</tr>\n<tr>\n<td>QAT Min./Max. 8 bits</td>\n<td>61,29</td>\n<td>+1,19</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p><em>Tableau 3 : Score moyen (en % correct) pour chaque condition sur les douze bancs d’essai NanoBEIR.</em></p><p>Vous pouvez voir dans le tableau ci-dessus que l’affinage pour la quantification améliore les scores. La seule différence entre les conditions <strong>PTQ Binaire</strong> et <strong>QAT Binaire</strong> est l’affinage, et la différence de score est significative. De même, nous constatons une amélioration de près de 2 % des scores entre les conditions <strong>PTQ Documents binaires uniquement</strong> et <strong>QAT Documents binaires uniquement</strong>, qui ne se distinguent que par le même affinage.</p><p>Sans surprise, nous constatons également que les scores s’améliorent généralement moins nous quantifions, la quantification à 4 bits étant meilleure que la ternaire, et la ternaire meilleure que la binaire. Cependant, passer à 8 bits ne semble rien avoir amélioré.</p><p>Nous n’avons testé le fait de laisser les requêtes non quantifiées que dans les cas binaires, mais cela semble améliorer les performances.</p><p>Enfin, nos tests suggèrent que la méthode de mise à l’échelle de la moyenne glissante surpasse l’approche min./max. simpliste.</p><h2 id=\"conclusion\">Conclusion</h2><p>La quantification présente des avantages opérationnels importants pour les modèles d' 向量模型 (Embeddings), en réduisant considérablement la taille des vecteurs d' 向量模型 (Embeddings) et en accélérant la recherche d’informations. Bien que la quantification post-formation simple (PTQ) offre des avantages immédiats en termes de mémoire et de stockage, nos expériences démontrent que la formation tenant compte de la quantification (QAT) atténue considérablement les pertes de précision inévitables. L’affinage a toujours donné de meilleurs scores.</p><p>Le degré de quantification a un impact direct sur les performances, ce qui est ce à quoi on s’attendrait d’une méthode basée sur la réduction de la précision des valeurs. Une quantification moins agressive (p. ex., 4 bits) surpasse généralement les méthodes plus agressives (p. ex., binaire), mais étonnamment, il n’y a pas eu de différence significative de performances entre la quantification à 8 bits et à 4 bits. Il semblerait que tant que vous n’atteignez pas un certain seuil d’imprécision, il y ait peu de différence entre une quantification plus ou moins importante.</p><p>Les stratégies de mise à l’échelle sont également importantes, la méthode de la moyenne glissante affichant des résultats supérieurs à une approche min./max. fixe. L’utilisation de valeurs de mise à l’échelle relatives aux données semble fonctionner beaucoup mieux et mérite d’être explorée davantage.</p><p>La quantification peut vous permettre de tirer davantage de vos modèles d' 向量模型 (Embeddings) pour moins cher. Bien que cet article n’explore pas toutes les options de quantification, il en explore deux qui sont facilement accessibles et qui ont de réels avantages à offrir. Nous nous efforçons d’affiner et d’améliorer les stratégies de quantification afin de réduire davantage les coûts des utilisateurs, et nous prévoyons de publier prochainement la prise en charge binaire de <code>jina-embeddings-v4</code>.</p>",
  "comment_id": "685d4b76f1bef30001fc5449",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/06/Heading---2025-06-30T114820.483.webp",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-06-26T15:30:30.000+02:00",
  "updated_at": "2025-06-30T21:14:36.000+02:00",
  "published_at": "2025-06-30T21:14:36.000+02:00",
  "custom_excerpt": "Quantization gives smaller embeddings. We show you fine-tuned quantization gives you even lossless embeddings.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "64ae64a4733bc60001949ca4",
      "name": "Andrei Ungureanu",
      "slug": "andrei",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2023/07/Me.jpg",
      "cover_image": null,
      "bio": "Software / AI Engineer, with a passion for content creation.",
      "website": null,
      "location": "Beijing, China",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/andrei/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/quantization-aware-training-of-jina-embeddings-v4/",
  "excerpt": "La quantification permet d'obtenir des 向量模型 (Embeddings) plus petits. Nous vous montrons qu'une quantification affinée vous offre des 向量模型 (Embeddings) encore plus compacts, voire sans perte.",
  "reading_time": 8,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}