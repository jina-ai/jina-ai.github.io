{
  "slug": "a-deep-dive-into-tokenization",
  "id": "65afb3ee8da8040001e17061",
  "uuid": "02d119e4-ed5f-4edf-8b66-65aea1386d96",
  "title": "Une analyse approfondie de la tokenisation",
  "html": "<p>Il existe de nombreux obstacles à la compréhension des modèles d'IA, certains étant assez importants, et ils peuvent entraver la mise en œuvre des processus d'IA. Mais le premier que beaucoup rencontrent est de comprendre ce que nous entendons par <strong>tokens</strong>.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/tokenizer?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Tokenizer API</div><div class=\"kg-bookmark-description\">Free API to tokenize texts, count and get first/last-N tokens.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-tokenize-api.png\" alt=\"\"></div></a></figure><p>L'un des paramètres pratiques les plus importants dans le choix d'un modèle de langage IA est la taille de sa fenêtre contextuelle — la taille maximale du texte d'entrée — qui est donnée en tokens, et non en mots ou en caractères ou toute autre unité automatiquement reconnaissable.</p><p>De plus, les services d'embedding sont généralement facturés « par token », ce qui signifie que les tokens sont importants pour comprendre votre facture.</p><p>Cela peut être très déroutant si vous ne savez pas clairement ce qu'est un token.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png\" class=\"kg-image\" alt=\"Grille tarifaire actuelle de Jina Embeddings (février 2024).\" loading=\"lazy\" width=\"2000\" height=\"1036\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/01/Screenshot-2024-01-31-at-15.13.41.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/01/Screenshot-2024-01-31-at-15.13.41.png 2000w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Grille tarifaire actuelle de Jina Embeddings (février 2024). Notez que les prix sont indiqués par « 1M tokens ».</span></figcaption></figure><p>Mais de tous les aspects déroutants de l'IA moderne, les tokens sont probablement les moins compliqués. Cet article tentera de clarifier ce qu'est la tokenisation, ce qu'elle fait et pourquoi nous procédons ainsi.</p><h2 id=\"tldr\">tl;dr</h2><p>Pour ceux qui veulent ou ont besoin d'une réponse rapide pour calculer combien de tokens acheter auprès de Jina Embeddings ou estimer combien ils devront en acheter, voici les statistiques que vous recherchez.</p><h3 id=\"tokens-per-english-word\">Tokens par mot en anglais</h3><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Un appel à l'API Jina Embeddings v2 pour les modèles anglais utilisera <b><strong style=\"white-space: pre-wrap;\">environ</strong></b> <b><strong style=\"white-space: pre-wrap;\">10% de tokens en plus</strong></b> que le nombre de mots dans votre texte, <b><strong style=\"white-space: pre-wrap;\">plus deux tokens par embedding</strong></b>.</div></div><p>Lors des tests empiriques, décrits plus loin dans cet article, divers textes anglais ont été convertis en tokens à un taux d'environ 10% de tokens de plus que de mots, en utilisant les modèles anglais uniquement de Jina Embeddings. Ce résultat était assez robuste.</p><p>Les modèles Jina Embeddings v2 ont une fenêtre contextuelle de 8192 tokens. Cela signifie que si vous passez à un modèle Jina un texte anglais de plus de 7 400 mots, il y a de fortes chances qu'il soit tronqué.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">La taille maximale d'entrée pour <b><strong style=\"white-space: pre-wrap;\">Jina Embeddings v2 pour l'anglais</strong></b> est d'environ <b><strong style=\"white-space: pre-wrap;\">7 400 mots</strong></b>.</div></div><h3 id=\"tokens-per-chinese-character\">Tokens par caractère chinois</h3><p>Pour le chinois, les résultats sont plus variables. Selon le type de texte, les ratios varient de 0,6 à 0,75 tokens par caractère chinois (汉字). Les textes anglais donnés à Jina Embeddings v2 pour le chinois produisent environ le même nombre de tokens que Jina Embeddings v2 pour l'anglais : environ 10% de plus que le nombre de mots.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">La taille maximale d'entrée en chinois pour <b><strong style=\"white-space: pre-wrap;\">Jina Embeddings v2 pour le chinois et l'anglais</strong></b> est d'environ <b><strong style=\"white-space: pre-wrap;\">10 500 caractères</strong></b> (<b><strong style=\"white-space: pre-wrap;\">字数</strong></b>), soit <b><strong style=\"white-space: pre-wrap;\">0,6 à 0,75 tokens par caractère chinois, plus deux par embedding.</strong></b></div></div><h3 id=\"tokens-per-german-word\">Tokens par mot en allemand</h3><p>Les ratios mots-tokens en allemand sont plus variables qu'en anglais mais moins qu'en chinois. Selon le genre du texte, j'ai obtenu en moyenne 20% à 30% de tokens de plus que de mots. Donner des textes anglais à Jina Embeddings v2 pour l'allemand et l'anglais utilise un peu plus de tokens que les modèles anglais uniquement et chinois/anglais : 12% à 15% de tokens de plus que de mots.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Jina Embeddings v2 pour l'allemand et l'anglais comptera <b><strong style=\"white-space: pre-wrap;\">20% à 30% de tokens de plus que de mots, plus deux par embedding</strong></b>. La taille maximale du contexte d'entrée est d'environ <b><strong style=\"white-space: pre-wrap;\">6 300 mots allemands</strong></b>.</div></div><h3 id=\"caution\">Attention !</h3><p>Ce sont des calculs simples, mais ils devraient être approximativement corrects pour la plupart des textes en langage naturel et la plupart des utilisateurs. En fin de compte, nous pouvons seulement promettre que le nombre de tokens sera toujours inférieur ou égal au nombre de caractères dans votre texte, plus deux. Il sera pratiquement toujours beaucoup moins que cela, mais nous ne pouvons pas promettre un compte spécifique à l'avance.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\"><b><strong style=\"white-space: pre-wrap;\">Les résultats peuvent varier !</strong></b><br><br>Ce sont des estimations basées sur des calculs statistiquement naïfs. Nous ne garantissons pas le nombre de tokens que prendra une requête particulière.</div></div><p>Si vous avez seulement besoin de conseils sur le nombre de tokens à acheter pour Jina Embeddings, vous pouvez vous arrêter ici. D'autres modèles d'embedding, d'entreprises autres que Jina AI, peuvent ne pas avoir les mêmes ratios token-mot et token-caractère-chinois que les modèles Jina, mais ils ne seront généralement pas très différents dans l'ensemble.</p><p>Si vous voulez comprendre pourquoi, le reste de cet article est une plongée plus profonde dans la tokenisation pour les modèles de langage.</p><h2 id=\"words-tokens-numbers\">Mots, Tokens, Nombres</h2><p>La tokenisation fait partie du traitement du langage naturel depuis plus longtemps que l'existence des modèles d'IA modernes.</p><p>C'est un peu un cliché de dire que tout dans un ordinateur n'est que des nombres, mais c'est aussi majoritairement vrai. Le langage, cependant, n'est pas naturellement qu'un ensemble de nombres. Il peut s'agir de parole, composée d'ondes sonores, ou d'écriture, composée de marques sur du papier, ou même d'une image d'un texte imprimé ou d'une vidéo de quelqu'un utilisant la langue des signes. Mais la plupart du temps, quand nous parlons d'utiliser des ordinateurs pour traiter le langage naturel, nous parlons de textes composés de séquences de caractères : lettres (a, b, c, etc.), chiffres (0, 1, 2…), ponctuation et espaces, dans différentes langues et encodages textuels.</p><p>Les ingénieurs informatiques appellent cela des « chaînes de caractères ».</p><p>Les modèles de langage IA prennent des séquences de nombres comme entrée. Donc, vous pourriez écrire la phrase :</p><blockquote><em>What is today's weather in Berlin?</em></blockquote><p>Mais, après tokenisation, le modèle IA reçoit comme entrée :</p><pre><code class=\"language-python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>La tokenisation est le processus de conversion d'une chaîne d'entrée en une séquence spécifique de nombres que votre modèle IA peut comprendre.</p><p>Lorsque vous utilisez un modèle IA via une API web qui facture les utilisateurs par token, chaque requête est convertie en une séquence de nombres comme celle ci-dessus. Le nombre de tokens dans la requête est la longueur de cette séquence de nombres. Donc, demander à Jina Embeddings v2 pour l'anglais de vous donner un embedding pour \"<em>What is today's weather in Berlin?</em>\" vous coûtera 11 tokens car il a converti cette phrase en une séquence de 11 nombres avant de la passer au modèle IA.</p><p>Les modèles IA basés sur l'<a href=\"https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)?ref=jina-ai-gmbh.ghost.io\">architecture Transformer</a> ont une <strong>fenêtre contextuelle</strong> de taille fixe dont la taille est mesurée en tokens. Parfois, on l'appelle « fenêtre d'entrée », « taille de contexte » ou « longueur de séquence » (particulièrement sur le <a href=\"https://huggingface.co/spaces/mteb/leaderboard?ref=jina-ai-gmbh.ghost.io\">leaderboard MTEB de Hugging Face</a>). Cela signifie la taille maximale de texte que le modèle peut voir à la fois.</p><p>Donc, si vous voulez utiliser un modèle d'embedding, c'est la taille d'entrée maximale autorisée.</p><p>Les modèles Jina Embeddings v2 ont tous une fenêtre contextuelle de 8 192 tokens. D'autres modèles auront des fenêtres contextuelles différentes (généralement plus petites). Cela signifie que quelle que soit la quantité de texte que vous y mettez, le tokenizer associé à ce modèle Jina Embeddings doit le convertir en pas plus de 8 192 tokens.</p><h2 id=\"mapping-language-to-numbers\">Mapping du langage vers les nombres</h2><p>La façon la plus simple d'expliquer la logique des tokens est celle-ci :</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">Un token est un nombre qui représente une partie d'une chaîne de caractères.</div></div><p>Pour les modèles de langage naturel, la partie de la chaîne qu'un token représente est un mot, une partie d'un mot, ou un signe de ponctuation. Les espaces ne reçoivent généralement aucune représentation explicite dans la sortie du tokenizer.</p><p>La tokenisation fait partie d'un groupe de techniques de traitement du langage naturel appelées <a href=\"https://en.wikipedia.org/wiki/Text_segmentation?ref=jina-ai-gmbh.ghost.io\"><em>segmentation de texte</em></a>, et le module qui effectue la tokenisation est appelé, très logiquement, un <strong>tokenizer</strong>.</p><p>Pour montrer comment fonctionne la tokenisation, nous allons tokeniser quelques phrases en utilisant le plus petit modèle Jina Embeddings v2 pour l'anglais : <code>jina-embeddings-v2-small-en</code>. L'autre modèle anglais uniquement de Jina Embeddings — <code>jina-embeddings-v2-base-en</code> — utilise le même tokenizer, donc il n'y a pas d'intérêt à télécharger des mégaoctets supplémentaires de modèle IA que nous n'utiliserons pas dans cet article.</p><p>Tout d'abord, installez le module <code>transformers</code> dans votre environnement Python ou notebook. Utilisez le</p>L'indicateur <code>-U</code> permet de s'assurer que vous passez à la dernière version, car ce modèle ne fonctionnera pas avec certaines versions plus anciennes :</p><pre><code class=\"language-bash\">pip install -U transformers\n</code></pre><p>Ensuite, téléchargez <a href=\"https://huggingface.co/jinaai/jina-embeddings-v2-small-en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\"><code>jina-embeddings-v2-small-en</code></a> en utilisant <code>AutoModel.from_pretrained</code> :</p><pre><code class=\"language-Python\">from transformers import AutoModel\n\nmodel = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-small-en', trust_remote_code=True)\n</code></pre><p>Pour tokeniser une chaîne de caractères, utilisez la méthode <code>encode</code> de l'objet membre <code>tokenizer</code> du modèle :</p><pre><code class=\"language-Python\">model.tokenizer.encode(\"What is today's weather in Berlin?\")\n</code></pre><p>Le résultat est une liste de nombres :</p><pre><code class=\"language-Python\">[101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102]\n</code></pre><p>Pour reconvertir ces nombres en chaînes de caractères, utilisez la méthode <code>convert_ids_to_tokens</code> de l'objet <code>tokenizer</code> :</p><pre><code class=\"language-Python\">model.tokenizer.convert_ids_to_tokens([101, 2054, 2003, 2651, 1005, 1055, 4633, 1999, 4068, 1029, 102])\n</code></pre><p>Le résultat est une liste de chaînes :</p><pre><code class=\"language-Python\">['[CLS]', 'what', 'is', 'today', \"'\", 's', 'weather', 'in',\n 'berlin', '?', '[SEP]']\n</code></pre><p>Notez que le tokenizer du modèle a :</p><ol><li>Ajouté <code>[CLS]</code> au début et <code>[SEP]</code> à la fin. C'est nécessaire pour des raisons techniques et signifie que <strong>chaque demande d'embedding coûtera deux tokens supplémentaires</strong>, en plus du nombre de tokens que le texte nécessite.</li><li>Séparé la ponctuation des mots, transformant « <em>Berlin?</em> » en : <code>berlin</code> et <code>?</code>, et « <em>today's</em> » en <code>today</code>, <code>'</code>, et <code>s</code>.</li><li>Mis tout en minuscules. Tous les modèles ne le font pas, mais cela peut aider lors de l'entraînement en anglais. Cela peut être moins utile dans les langues où la capitalisation a une signification différente.</li></ol><p>Différents algorithmes de comptage de mots dans différents programmes peuvent compter les mots de cette phrase différemment. OpenOffice compte ceci comme six mots. L'algorithme de segmentation de texte Unicode (<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode Standard Annex #29</a>) compte sept mots. D'autres logiciels peuvent arriver à d'autres nombres, selon la façon dont ils gèrent la ponctuation et les clitiques comme « 's ».</p><p>Le tokenizer de ce modèle produit neuf tokens pour ces six ou sept mots, plus les deux tokens supplémentaires nécessaires à chaque requête.</p><p>Maintenant, essayons avec un nom de lieu moins courant que Berlin :</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"I live in Kinshasa.\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>Le résultat :</p><pre><code class=\"language-Python\">['[CLS]', 'i', 'live', 'in', 'kin', '##sha', '##sa', '.', '[SEP]']\n</code></pre><p>Le nom « Kinshasa » est divisé en trois tokens : <code>kin</code>, <code>##sha</code>, et <code>##sa</code>. Le <code>##</code> indique que ce token n'est pas le début d'un mot.</p><p>Si nous donnons au tokenizer quelque chose de complètement étranger, le nombre de tokens par rapport au nombre de mots augmente encore plus :</p><pre><code class=\"language-Python\">token_ids = model.tokenizer.encode(\"Klaatu barada nikto\")\ntokens = model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n\n['[CLS]', 'k', '##la', '##at', '##u', 'bar', '##ada', 'nik', '##to', '[SEP]']\n</code></pre><p>Trois mots deviennent huit tokens, plus les tokens <code>[CLS]</code> et <code>[SEP]</code>.</p><p>La tokenisation en allemand est similaire. Avec le modèle <a href=\"https://jina.ai/news/ich-bin-ein-berliner-german-english-bilingual-embeddings-with-8k-token-length/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Jina Embeddings v2 pour l'allemand</a>, nous pouvons tokeniser une traduction de « What is today's weather in Berlin? » de la même manière qu'avec le modèle anglais.</p><pre><code class=\"language-Python\">german_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-de', trust_remote_code=True)\ntoken_ids = german_model.tokenizer.encode(\"Wie wird das Wetter heute in Berlin?\")\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>Le résultat :</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Wie', 'wird', 'das', 'Wetter', 'heute', 'in', 'Berlin', '?', '&lt;/s&gt;']\n</code></pre><p>Ce tokenizer est légèrement différent de celui de l'anglais car <code>&lt;s&gt;</code> et <code>&lt;/s&gt;</code> remplacent <code>[CLS]</code> et <code>[SEP]</code> mais servent la même fonction. De plus, le texte n'est pas normalisé en minuscules — les majuscules et minuscules restent telles quelles — car la capitalisation a une signification différente en allemand par rapport à l'anglais.</p><p>(Pour simplifier cette présentation, j'ai supprimé un caractère spécial indiquant le début d'un mot.)</p><p>Maintenant, essayons une phrase plus complexe <a href=\"https://www.welt.de/politik/deutschland/plus249565102/Proteste-der-Landwirte-Die-Krux-mit-den-Foerdermitteln.html?ref=jina-ai-gmbh.ghost.io\">tirée d'un texte de journal</a> :</p><blockquote>Ein Großteil der milliardenschweren Bauern-Subventionen bleibt liegen – zu genervt sind die Landwirte von bürokratischen Gängelungen und Regelwahn.</blockquote><pre><code>sentence = \"\"\"\nEin Großteil der milliardenschweren Bauern-Subventionen\nbleibt liegen – zu genervt sind die Landwirte von \nbürokratischen Gängelungen und Regelwahn.\n\"\"\"\ntoken_ids = german_model.tokenizer.encode(sentence)\ntokens = german_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)</code></pre><p>Le résultat tokenisé :</p><pre><code class=\"language-python\">['&lt;s&gt;', 'Ein', 'Großteil', 'der', 'mill', 'iarden', 'schwer', \n 'en', 'Bauern', '-', 'Sub', 'ventionen', 'bleibt', 'liegen', \n '–', 'zu', 'gen', 'ervt', 'sind', 'die', 'Landwirte', 'von', \n 'büro', 'krat', 'ischen', 'Gän', 'gel', 'ungen', 'und', 'Regel', \n 'wahn', '.', '&lt;/s&gt;']\n</code></pre><p>Ici, vous voyez que de nombreux mots allemands ont été divisés en plus petits morceaux et pas nécessairement selon les règles grammaticales allemandes. En conséquence, un long mot allemand qui ne compterait que comme un seul mot pour un compteur de mots peut représenter un nombre quelconque de tokens pour le modèle AI de Jina.</p><p>Faisons de même en chinois, en traduisant « What is today's weather in Berlin? » par :</p><blockquote>柏林今天的天气怎么样？</blockquote><pre><code>chinese_model = AutoModel.from_pretrained('jinaai/jina-embeddings-v2-base-zh', trust_remote_code=True)\ntoken_ids = chinese_model.tokenizer.encode(\"柏林今天的天气怎么样？\")\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>Le résultat tokenisé :</p><pre><code class=\"language-Python\">['&lt;s&gt;', '柏林', '今天的', '天气', '怎么样', '？', '&lt;/s&gt;']\n</code></pre><p>En chinois, il n'y a généralement pas d'espaces entre les mots dans le texte écrit, mais le tokenizer de Jina Embeddings regroupe souvent plusieurs caractères chinois ensemble :</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Token string</th>\n<th>Pinyin</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>柏林</td>\n<td>Bólín</td>\n<td>Berlin</td>\n</tr>\n<tr>\n<td>今天的</td>\n<td>jīntiān de</td>\n<td>today's</td>\n</tr>\n<tr>\n<td>天气</td>\n<td>tiānqì</td>\n<td>weather</td>\n</tr>\n<tr>\n<td>怎么样</td>\n<td>zěnmeyàng</td>\n<td>how</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Utilisons une phrase plus complexe <a href=\"https://news.mingpao.com/pns/%e6%b8%af%e8%81%9e/article/20240116/s00002/1705335848777/%e7%81%a3%e5%8d%80%e7%86%b1%e6%90%9c-%e7%a9%97%e5%9c%b0%e9%90%b5%e6%8e%a8%e6%89%8b%e6%a9%9f%e3%80%8c%e9%9d%9c%e9%9f%b3%e4%bb%a4%e3%80%8d-%e7%84%a1%e7%bd%b0%e5%89%87-%e5%b8%82%e6%b0%91%e6%9c%89%e7%a8%b1%e5%85%b7%e8%ad%a6%e7%a4%ba%e4%bd%9c%e7%94%a8-%e6%9c%89%e6%84%9f%e5%af%a6%e6%95%88%e4%b8%8d%e5%a4%a7?ref=jina-ai-gmbh.ghost.io\">d'un journal de Hong Kong</a> :</p><pre><code class=\"language-Python\">sentence = \"\"\"\n新規定執行首日，記者在下班高峰前的下午5時來到廣州地鐵3號線，\n從繁忙的珠江新城站啟程，向機場北方向出發。\n\"\"\"\ntoken_ids = chinese_model.tokenizer.encode(sentence)\ntokens = chinese_model.tokenizer.convert_ids_to_tokens(token_ids)\nprint(tokens)\n</code></pre><p>(Traduction : <em>« Le premier jour de l'entrée en vigueur des nouvelles réglementations, ce journaliste est arrivé à la ligne 3 du métro de Guangzhou à 17h, pendant l'heure de pointe, en partant de la station Zhujiang New Town en direction de l'aéroport. »</em>)</p><p>Le résultat :</p><pre><code class=\"language-python\">['&lt;s&gt;', '新', '規定', '執行', '首', '日', '，', '記者', '在下', '班', \n '高峰', '前的', '下午', '5', '時', '來到', '廣州', '地', '鐵', '3', \n '號', '線', '，', '從', '繁忙', '的', '珠江', '新城', '站', '啟', \n '程', '，', '向', '機場', '北', '方向', '出發', '。', '&lt;/s&gt;']\n</code></pre><p>Ces tokens ne correspondent à aucun dictionnaire spécifique de mots chinois (词典). Par exemple, \"啟程\" - <em>qǐchéng</em> (partir, se mettre en route) serait généralement catégorisé comme un seul mot mais est ici divisé en ses deux caractères constitutifs. De même, \"在下班\" serait normalement reconnu comme deux mots, avec la séparation entre \"在\" - <em>zài</em> (à, pendant) et \"下班\" - <em>xiàbān</em> (la fin de la journée de travail, heure de pointe), et non entre \"在下\" et \"班\" comme l'a fait le tokenizer ici.</p><p>Dans les trois langues, les endroits où le tokenizer découpe le texte ne sont pas directement liés aux endroits logiques où un lecteur humain les séparerait.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">L'algorithme de tokenization n'utilise pas un dictionnaire conventionnel tenant compte de la langue, donc son comportement ne correspond pas à la façon dont les humains comptent les mots.</div></div><p>Ce n'est pas une caractéristique spécifique des modèles Jina Embeddings. Cette approche de la tokenization est presque universelle dans le développement des modèles d'IA. Bien que deux modèles d'IA différents puissent ne pas avoir des tokenizers identiques, dans l'état actuel du développement, ils utiliseront pratiquement tous des tokenizers avec ce type de comportement.</p><p>La section suivante discutera de l'algorithme spécifique utilisé dans la tokenization et la logique qui le sous-tend.</p><h2 id=\"why-do-we-tokenize-and-why-this-way\">Pourquoi tokeniser ? Et pourquoi de cette manière ?</h2><p>Les modèles de langage IA prennent en entrée des séquences de nombres qui représentent des séquences de texte, mais il se passe un peu plus de choses avant d'exécuter le réseau neuronal sous-jacent et de créer un embedding. Lorsqu'on lui présente une liste de nombres représentant de petites séquences de texte, le modèle recherche chaque nombre dans un dictionnaire interne qui stocke un vecteur unique pour chaque nombre. Il les combine ensuite, et cela devient l'entrée du réseau neuronal.</p><p>Cela signifie que le tokenizer <strong>doit</strong> être capable de convertir <strong><em>n'importe quel</em></strong> texte d'entrée que nous lui donnons en tokens qui apparaissent dans le dictionnaire de vecteurs de tokens du modèle. Si nous prenions nos tokens d'un dictionnaire conventionnel, la première fois que nous rencontrerions une faute d'orthographe ou un nom propre rare ou un mot étranger, le modèle entier s'arrêterait. Il ne pourrait pas traiter cette entrée.</p><p>En traitement du langage naturel, on appelle cela le problème du vocabulaire hors-vocabulaire (OOV), et il est omniprésent dans tous les types de textes et toutes les langues. Il existe quelques stratégies pour résoudre le problème OOV :</p><ol><li>L'ignorer. Remplacer tout ce qui n'est pas dans le dictionnaire par un token \"inconnu\".</li><li>Le contourner. Au lieu d'utiliser un dictionnaire qui associe des séquences de texte à des vecteurs, utiliser un qui associe des <em>caractères individuels</em> à des vecteurs. L'anglais n'utilise que 26 lettres la plupart du temps, donc cela doit être plus petit et plus robuste contre les problèmes OOV que n'importe quel dictionnaire.</li><li>Trouver des sous-séquences fréquentes dans le texte, les mettre dans le dictionnaire et utiliser des caractères (tokens d'une seule lettre) pour ce qui reste.</li></ol><p>La première stratégie signifie que beaucoup d'informations importantes sont perdues. Le modèle ne peut même pas apprendre des données qu'il a vues si elles prennent la forme de quelque chose qui n'est pas dans le dictionnaire. Beaucoup de choses dans le texte ordinaire ne sont tout simplement pas présentes dans les plus grands dictionnaires.</p><p>La deuxième stratégie est possible, et les chercheurs l'ont étudiée. Cependant, cela signifie que le modèle doit accepter beaucoup plus d'entrées et doit apprendre beaucoup plus. Cela signifie un modèle beaucoup plus grand et beaucoup plus de données d'entraînement pour un résultat qui ne s'est jamais avéré meilleur que la troisième stratégie.</p><p>Les modèles de langage IA mettent pratiquement tous en œuvre la troisième stratégie sous une forme ou une autre. La plupart utilisent une variante de l'<a href=\"https://huggingface.co/learn/nlp-course/chapter6/6?ref=jina-ai-gmbh.ghost.io\">algorithme Wordpiece</a> <a href=\"https://ieeexplore.ieee.org/document/6289079?ref=jina-ai-gmbh.ghost.io\">[Schuster et Nakajima 2012]</a> ou une technique similaire appelée <a href=\"https://en.wikipedia.org/wiki/Byte_pair_encoding?ref=jina-ai-gmbh.ghost.io\">Byte-Pair Encoding</a> (BPE). [<a href=\"https://www.drdobbs.com/a-new-algorithm-for-data-compression/184402829?ref=jina-ai-gmbh.ghost.io\">Gage 1994</a>, <a href=\"https://aclanthology.org/P16-1162/?ref=jina-ai-gmbh.ghost.io\">Senrich et al. 2016</a>] Ces algorithmes sont <em>agnostiques au langage</em>. Cela signifie qu'ils fonctionnent de la même manière pour toutes les langues écrites sans aucune connaissance au-delà d'une liste complète des caractères possibles. Ils ont été conçus pour des modèles multilingues comme BERT de Google qui prennent n'importe quelle entrée du scraping d'Internet — des centaines de langues et des textes autres que le langage humain comme les programmes informatiques — afin qu'ils puissent être entraînés sans faire de linguistique compliquée.</p><p>Certaines recherches montrent des améliorations significatives en utilisant des tokenizers plus spécifiques et conscients de la langue. [<a href=\"https://aclanthology.org/2021.acl-long.243/?ref=jina-ai-gmbh.ghost.io\">Rust et al. 2021</a>] Mais construire des tokenizers de cette manière prend du temps, de l'argent et de l'expertise. Mettre en œuvre une stratégie universelle comme BPE ou Wordpiece est beaucoup moins cher et plus facile.</p><p>Cependant, en conséquence, il n'y a aucun moyen de savoir combien de tokens représente un texte spécifique autre que de le faire passer par un tokenizer puis de compter le nombre de tokens qui en sortent. Parce que la plus petite sous-séquence possible d'un texte est une lettre, vous pouvez être sûr que le nombre de tokens ne sera pas plus grand que le nombre de caractères (moins les espaces) plus deux.</p><p>Pour obtenir une bonne estimation, nous devons soumettre beaucoup de texte à notre tokenizer et calculer empiriquement combien de tokens nous obtenons en moyenne, par rapport au nombre de mots ou de caractères que nous avons entrés. Dans la section suivante, nous ferons quelques mesures empiriques pas très systématiques pour tous les modèles Jina Embeddings v2 actuellement disponibles.</p><h2 id=\"empirical-estimates-of-token-output-sizes\">Estimations empiriques des tailles de sortie des tokens</h2><p>Pour l'anglais et l'allemand, j'ai utilisé l'algorithme de segmentation de texte Unicode (<a href=\"https://unicode.org/reports/tr29/?ref=jina-ai-gmbh.ghost.io\">Unicode Standard Annex #29</a>) pour obtenir le nombre de mots des textes. Cet algorithme est largement utilisé pour sélectionner des extraits de texte lorsque vous double-cliquez sur quelque chose. C'est ce qui se rapproche le plus d'un compteur de mots objectif universel.</p><p>J'ai installé la <a href=\"https://pypi.org/project/polyglot/?ref=jina-ai-gmbh.ghost.io\">bibliothèque polyglot</a> en Python, qui implémente ce segmenteur de texte :</p><pre><code class=\"language-bash\">pip install -U polyglot\n</code></pre><p>Pour obtenir le nombre de mots d'un texte, vous pouvez utiliser un code comme cet extrait :</p><pre><code class=\"language-python\">from polyglot.text import Text\n\ntxt = \"What is today's weather in Berlin?\"\nprint(len(Text(txt).words))\n</code></pre><p>Le résultat devrait être <code>7</code>.</p><p>Pour obtenir un nombre de tokens, des segments du texte ont été passés aux tokenizers de divers modèles Jina Embeddings, comme décrit ci-dessous, et chaque fois, j'ai soustrait deux du nombre de tokens retournés.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">⚠️</div><div class=\"kg-callout-text\">Les nombres de tokens listés ici <b><strong style=\"white-space: pre-wrap;\">n'incluent pas</strong></b> les deux tokens supplémentaires au début et à la fin de chaque texte tokenisé.</div></div><h3 id=\"english-jina-embeddings-v2-small-en-and-jina-embeddings-v2-base-en\">Anglais<br>(<code>jina-embeddings-v2-small-en</code> et <code>jina-embeddings-v2-base-en</code>)</h3><p>Pour calculer les moyennes, j'ai téléchargé deux corpus de texte anglais depuis <a href=\"https://wortschatz.uni-leipzig.de/en?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Wortschatz Leipzig</a>, une collection de corpus librement téléchargeables dans plusieurs langues et configurations hébergée par l'Université de Leipzig :</p><ul><li>Un corpus d'un million de phrases de données d'actualités en anglais de 2020 (<code>eng_news_2020_1M</code>)</li><li>Un corpus d'un million de phrases de données de <a href=\"https://en.wikipedia.org/?ref=jina-ai-gmbh.ghost.io\">Wikipédia en anglais</a> de 2016 (<code>eng_wikipedia_2016_1M</code>)</li></ul><p>Les deux peuvent être trouvés sur <a href=\"https://wortschatz.uni-leipzig.de/en/download/English?ref=jina-ai-gmbh.ghost.io\">leur page de téléchargements en anglais</a>.</p><p>Pour la diversité, j'ai également téléchargé la <a href=\"https://www.gutenberg.org/ebooks/135?ref=jina-ai-gmbh.ghost.io\">traduction Hapgood des <em>Misérables</em> de Victor Hugo</a> depuis Project Gutenberg, et une copie de la version King James de la Bible, traduite en anglais en 1611.</p><p>Pour chacun des quatre textes, j'ai compté les mots en utilisant le segmenteur Unicode implémenté dans <code>polyglot</code>, puis compté les tokens créés par <code>jina-embeddings-v2-small-en</code>, en soustrayant deux tokens pour chaque requête de tokenization. Les résultats sont les suivants :</p>\n<!--kg-card-begin: html-->\n<table id=\"6f07d5d4-ca08-466e-92fc-e784a932e4d0\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"4b8c4003-8ef9-4ac5-8df3-ef7662ab4d3b\"><th id=\"wvl`\" class=\"simple-table-header-color simple-table-header\">Texte</th><th id=\"|<X;\" class=\"simple-table-header-color simple-table-header\">Nombre de mots<br>(Segmenteur Unicode)<br></th><th id=\"GHal\" class=\"simple-table-header-color simple-table-header\">Nombre de tokens<br>(Jina Embeddings v2 <br>pour l'anglais)<br></th><th id=\"h]mu\" class=\"simple-table-header-color simple-table-header\">Ratio tokens/mots<br>(à 3 décimales)<br></th></tr></thead><tbody><tr id=\"7e9eda1b-54b6-40f3-be6f-b233f161e2b5\"><td id=\"wvl`\" class=\"\"><code>eng_news_2020_1M</code></td><td id=\"|<X;\" class=\"\">22 825 712</td><td id=\"GHal\" class=\"\">25 270 581</td><td id=\"h]mu\" class=\"\">1,107</td></tr><tr id=\"a81dfe1d-9143-4306-9bf3-4891ca8fb019\"><td id=\"wvl`\" class=\"\"><code>eng_wikipedia_2016_1M</code></td><td id=\"|<X;\" class=\"\">24 243 607</td><td id=\"GHal\" class=\"\">26 813 877</td><td id=\"h]mu\" class=\"\">1,106</td></tr><tr id=\"d2fff413-6e0d-4ab2-9626-4d618d99af91\"><td id=\"wvl`\" class=\"\"><code>les_miserables_en</code></td><td id=\"|<X;\" class=\"\">688 911</td><td id=\"GHal\" class=\"\">764 121</td><td id=\"h]mu\" class=\"\">1,109</td></tr><tr id=\"eb304e43-4fd3-4e02-9993-13fb0307f544\"><td id=\"wvl`\" class=\"\"><code>kjv_bible</code></td><td id=\"|<X;\" class=\"\">1 007 651</td><td id=\"GHal\" class=\"\">1 099 335</td><td id=\"h]mu\" class=\"\">1,091</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>L'utilisation de chiffres précis ne signifie pas que c'est un résultat précis. Le fait que des documents de genres si différents aient tous entre 9 % et 11 % de tokens de plus que de mots indique que vous pouvez probablement vous attendre à environ 10 % de tokens de plus que de mots, selon le segmenteur Unicode. Les traitements de texte ne comptent souvent pas la ponctuation, alors que le segmenteur Unicode le fait, donc vous ne pouvez pas vous attendre à ce que les décomptes de mots des logiciels de bureautique correspondent nécessairement à ceci.</p><h3 id=\"german-jina-embeddings-v2-base-de\">Allemand<br>(<code>jina-embeddings-v2-base-de</code>)</h3><p>Pour l'allemand, j'ai téléchargé trois corpus depuis la <a href=\"https://wortschatz.uni-leipzig.de/en/download/German?ref=jina-ai-gmbh.ghost.io\">page allemande de Wortschatz Leipzig</a> :</p><ul><li><code>deu_mixed-typical_2011_1M</code> — Un million de phrases provenant d'un mélange équilibré de textes de différents genres, datant de 2011.</li><li><code>deu_newscrawl-public_2019_1M</code> — Un million de phrases de textes d'actualités de 2019.</li><li><code>deu_wikipedia_2021_1M</code> — Un million de phrases extraites de Wikipédia en allemand en 2021.</li></ul><p>Et pour la diversité, j'ai également téléchargé les <a href=\"https://deutschestextarchiv.de/search?q=Kapital&in=metadata&ref=jina-ai-gmbh.ghost.io\">trois volumes du <em>Capital</em> de Karl Marx</a> depuis les <a href=\"https://www.deutschestextarchiv.de/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Archives de textes allemands</a>.</p><p>J'ai ensuite suivi la même procédure que pour l'anglais :</p>\n<!--kg-card-begin: html-->\n<table id=\"ad695a91-f35b-4215-bd4d-5d1415bb9812\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"7786decb-f68d-433d-8f58-3861d0350027\"><th id=\"UGp`\" class=\"simple-table-header-color simple-table-header\" style=\"width:234.2265625px\">Texte</th><th id=\"|qln\" class=\"simple-table-header-color simple-table-header\">Nombre de mots<br>(Segmenteur Unicode)<br></th><th id=\"YXZX\" class=\"simple-table-header-color simple-table-header\">Nombre de tokens<br>(Jina Embeddings v2 <br>pour l'allemand et l'anglais)<br></th><th id=\"oEoQ\" class=\"simple-table-header-color simple-table-header\">Ratio tokens/mots<br>(à 3 décimales)<br></th></tr></thead><tbody><tr id=\"9cb48640-64db-4783-8bfe-c78412022a21\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_mixed-typical_2011_1M</code></td><td id=\"|qln\" class=\"\">7 924 024</td><td id=\"YXZX\" class=\"\">9 772 652</td><td id=\"oEoQ\" class=\"\">1,234</td></tr><tr id=\"32fee905-17dc-4c2c-a32d-5e6508b033bc\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_newscrawl-public_2019_1M</code></td><td id=\"|qln\" class=\"\">17 949 120</td><td id=\"YXZX\" class=\"\">21 711 555</td><td id=\"oEoQ\" class=\"\">1,210</td></tr><tr id=\"35d0c8c4-7912-4d61-829a-bb39b643aa1c\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>deu_wikipedia_2021_1M</code></td><td id=\"|qln\" class=\"\">17 999 482</td><td id=\"YXZX\" class=\"\">22 654 901</td><td id=\"oEoQ\" class=\"\">1,259</td></tr><tr id=\"19e10367-e070-4dcc-8cbe-cfc75c43e0f9\"><td id=\"UGp`\" class=\"\" style=\"width:234.2265625px\"><code>marx_kapital</code></td><td id=\"|qln\" class=\"\">784 336</td><td id=\"YXZX\" class=\"\">1 011 377</td><td id=\"oEoQ\" class=\"\">1,289</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>Ces résultats ont une plus grande dispersion que le modèle anglais uniquement, mais suggèrent toujours que le texte allemand produira, en moyenne, 20 % à 30 % de tokens de plus que de mots.</p><p>Les textes anglais produisent plus de tokens avec le tokenizer allemand-anglais qu'avec celui uniquement anglais :</p>\n<!--kg-card-begin: html-->\n<table id=\"c31b2079-e921-4e06-a24b-8ed60ae63d8d\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"fe722fdd-ab88-44b4-9f3b-43c62eb3ccb5\"><th id=\"Nc<l\" class=\"simple-table-header-color simple-table-header\" style=\"width:187.78125px\">Texte</th><th id=\"R@A^\" class=\"simple-table-header-color simple-table-header\">Nombre de mots<br>(Segmenteur Unicode)<br></th><th id=\"UUfl\" class=\"simple-table-header-color simple-table-header\">Nombre de tokens<br>(Jina Embeddings v2 <br>pour l'allemand et l'anglais)<br></th><th id=\"iTZS\" class=\"simple-table-header-color simple-table-header\">Ratio tokens/mots<br>(à 3 décimales)<br></th></tr></thead><tbody><tr id=\"3461fd8c-ca39-4670-8f0e-e38a4958464a\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_news_2020_1M</code></td><td id=\"R@A^\" class=\"\">24 243 607</td><td id=\"UUfl\" class=\"\">27 758 535</td><td id=\"iTZS\" class=\"\">1,145</td></tr><tr id=\"48770d4d-5855-4f5f-934f-5b2900aa56c3\"><td id=\"Nc<l\" class=\"\" style=\"width:187.78125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"R@A^\" class=\"\">22 825 712</td><td id=\"UUfl\" class=\"\">25 566 921</td><td id=\"iTZS\" class=\"\">1,120</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>Vous devriez vous attendre à avoir besoin de 12 % à 15 % de tokens de plus que de mots pour intégrer des textes anglais avec le modèle bilingue allemand/anglais plutôt qu'avec celui uniquement anglais.</p><h3 id=\"chinese-jina-embeddings-v2-base-zh\">Chinois<br>(<code>jina-embeddings-v2-base-zh</code>)</h3><p>Le chinois est généralement écrit sans espaces et n'avait pas de notion traditionnelle de \"mots\" avant le XXe siècle. Par conséquent, la taille d'un texte chinois est généralement mesurée en caractères (<strong>字数</strong>). Donc, au lieu d'utiliser le segmenteur Unicode, j'ai mesuré la longueur des textes chinois en supprimant tous les espaces puis en obtenant simplement la longueur en caractères.</p><p>J'ai téléchargé trois corpus depuis la <a href=\"https://wortschatz.uni-leipzig.de/en/download/Chinese?ref=jina-ai-gmbh.ghost.io\">page des corpus chinois de Wortschatz Leipzig</a> :</p><ul><li><code>zho_wikipedia_2018_1M</code> — Un million de phrases de Wikipédia en chinois, extraites en 2018.</li><li><code>zho_news_2007-2009_1M</code> — Un million de phrases de sources d'actualités chinoises, collectées de 2007 à 2009.</li><li><code>zho-trad_newscrawl_2011_1M</code> — Un million de phrases de sources d'actualités qui utilisent exclusivement des caractères chinois traditionnels (繁體字).</li></ul><p>De plus, pour plus de diversité, j'ai également utilisé <em>L'Histoire véritable d'Ah Q</em> (阿Q正傳), une nouvelle de Lu Xun (魯迅) écrite au début des années 1920. J'ai téléchargé la <a href=\"https://www.gutenberg.org/ebooks/25332?ref=jina-ai-gmbh.ghost.io\">version en caractères traditionnels depuis Project Gutenberg</a>.</p>\n<!--kg-card-begin: html-->\n<table id=\"dace0ca3-97c0-481e-98e2-d2724b7bbe66\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"adc6e6ff-8afd-4915-8884-0894546a13dc\"><th id=\"bCvb\" class=\"simple-table-header-color simple-table-header\" style=\"width:223.6953125px\">Texte</th><th id=\"CaUc\" class=\"simple-table-header-color simple-table-header\">Nombre de caractères<br>(字数)<br></th><th id=\"CQ{d\" class=\"simple-table-header-color simple-table-header\">Nombre de tokens<br>(Jina Embeddings v2 <br>pour le chinois et l'anglais)<br></th><th id=\"_};C\" class=\"simple-table-header-color simple-table-header\">Ratio tokens/caractères<br>(à 3 décimales)<br></th></tr></thead><tbody><tr id=\"e75154ce-a33e-4af1-a983-4c4213f93c0e\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_wikipedia_2018_1M</code></td><td id=\"CaUc\" class=\"\">45 116 182</td><td id=\"CQ{d\" class=\"\">29 193 028</td><td id=\"_};C\" class=\"\">0,647</td></tr><tr id=\"605560a8-5c77-4add-a3e4-4615779b571a\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho_news_2007-2009_1M</code></td><td id=\"CaUc\" class=\"\">44 295 314</td><td id=\"CQ{d\" class=\"\">28 108 090</td><td id=\"_};C\" class=\"\">0,635</td></tr><tr id=\"6e23944e-a480-4978-8550-a83404b218c4\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>zho-trad_newscrawl_2011_1M</code></td><td id=\"CaUc\" class=\"\">54 585 819</td><td id=\"CQ{d\" class=\"\">40 290 982</td><td id=\"_};C\" class=\"\">0,738</td></tr><tr id=\"50abbb96-06f7-4308-9c66-7c18f2a67721\"><td id=\"bCvb\" class=\"\" style=\"width:223.6953125px\"><code>Ah_Q</code></td><td id=\"CaUc\" class=\"\">41 268</td><td id=\"CQ{d\" class=\"\">25 346</td><td id=\"_};C\" class=\"\">0,614</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<p>Cette variation dans les ratios tokens/caractères est inattendue, et particulièrement la valeur aberrante pour le corpus en caractères traditionnels mérite une enquête plus approfondie. Néanmoins, nous pouvons conclure que pour le chinois, vous devriez vous attendre à avoir besoin de <em>moins</em> de tokens qu'il n'y a de caractères dans votre texte. Selon votre contenu, vous pouvez vous attendre à avoir besoin de 25 % à 40 % de moins.</p><p>Les textes anglais dans Jina Embeddings v2 pour le chinois et l'anglais ont produit à peu près le même nombre de tokens que dans le modèle anglais uniquement :</p>\n<!--kg-card-begin: html-->\n<table id=\"061e7c3f-d109-476d-85fb-db3b369e4f35\" class=\"simple-table\"><thead class=\"simple-table-header\"><tr id=\"1200d074-3353-4815-ab66-a90e93ec349d\"><th id=\"v\\xv\" class=\"simple-table-header-color simple-table-header\" style=\"width:184.53125px\">Text</th><th id=\"qlUV\" class=\"simple-table-header-color simple-table-header\" style=\"width:165.3125px\">Word count<br>(Unicode Segmenter)<br></th><th id=\"=]?F\" class=\"simple-table-header-color simple-table-header\">Token count<br>(Jina Embeddings v2 for Chinese and English)<br></th><th id=\"<rlw\" class=\"simple-table-header-color simple-table-header\">Ratio of tokens to words<br>(to 3 decimal places)<br></th></tr></thead><tbody><tr id=\"2fe4e02d-94fd-4513-bfcb-7f85d66b6883\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_news_2020_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">24 243 607</td><td id=\"=]?F\" class=\"\">26 890 176</td><td id=\"<rlw\" class=\"\">1,109</td></tr><tr id=\"e7f937f4-b156-4f5d-9e0b-3041d07b1b20\"><td id=\"v\\xv\" class=\"\" style=\"width:184.53125px\"><code>eng_wikipedia_2016_1M</code></td><td id=\"qlUV\" class=\"\" style=\"width:165.3125px\">22 825 712</td><td id=\"=]?F\" class=\"\">25 060 352</td><td id=\"<rlw\" class=\"\">1,097</td></tr></tbody></table>\n<!--kg-card-end: html-->\n<h2 id=\"taking-tokens-seriously\">Prendre les tokens au sérieux</h2><p>Les tokens sont une structure importante pour les modèles de langage d'IA, et la recherche se poursuit dans ce domaine.</p><p>L'un des domaines où les modèles d'IA se sont révélés révolutionnaires est la découverte qu'ils sont très robustes face aux données bruitées. Même si un modèle particulier n'utilise pas la stratégie de tokenisation optimale, si le réseau est assez grand, dispose de suffisamment de données et est correctement entraîné, il peut apprendre à faire la bonne chose à partir d'entrées imparfaites.</p><p>Par conséquent, on consacre beaucoup moins d'efforts à l'amélioration de la tokenisation que dans d'autres domaines, mais cela pourrait changer.</p><p>En tant qu'utilisateur d'embeddings, qui les achète via une <a href=\"https://jina.ai/embeddings/?ref=jina-ai-gmbh.ghost.io\">API comme Jina Embeddings</a>, vous ne pouvez pas savoir précisément combien de tokens vous aurez besoin pour une tâche spécifique et devrez peut-être faire vos propres tests pour obtenir des chiffres solides. Mais les estimations fournies ici — environ 110 % du nombre de mots pour l'anglais, environ 125 % du nombre de mots pour l'allemand, et environ 70 % du nombre de caractères pour le chinois — devraient être suffisantes pour une budgétisation de base.</p>",
  "comment_id": "65afb3ee8da8040001e17061",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/01/Untitled-design--25-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-01-23T13:41:18.000+01:00",
  "updated_at": "2024-08-14T11:38:01.000+02:00",
  "published_at": "2024-01-31T16:10:14.000+01:00",
  "custom_excerpt": "Tokenization, in LLMs, means chopping input texts up into smaller parts for processing. So why are embeddings billed by the token?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "632ae7353e4e55003d52598e",
    "name": "Scott Martens",
    "slug": "scott",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
    "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
    "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
    "website": "https://jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/a-deep-dive-into-tokenization/",
  "excerpt": "La tokenisation, dans les LLMs, signifie découper les textes d'entrée en plus petites parties pour leur traitement. Alors pourquoi les embeddings sont-ils facturés au token ?",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Colorful speckled grid pattern with a mix of small multicolored dots on a black background, creating a mosaic effect.",
  "feature_image_caption": null
}