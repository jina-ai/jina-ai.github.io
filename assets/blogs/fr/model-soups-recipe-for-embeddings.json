{
  "slug": "model-soups-recipe-for-embeddings",
  "id": "681b63a077c406000104263b",
  "uuid": "e3fc45b3-6cf9-4a0b-863f-bc4a8417c436",
  "title": "La recette de la soupe de modèles pour les embeddings",
  "html": "<p>En ces temps difficiles, rien ne vaut un bon bol de soupe chaude.</p><p>La minestrone est l'une des soupes italiennes classiques : épaisse, copieuse, savoureuse, combinant des haricots, des légumes consistants et du riz ou des pâtes. Son goût est le résultat de l'assemblage d'ingrédients divers. Elle ressemble un peu au bortsch en Europe de l'Est, aux plats en casserole en Amérique ou aux sautés maison en Asie du Pacifique, en ce sens qu'elle combine des ingrédients disponibles et peu coûteux pour en faire un plat apprécié.</p><p>Nous pouvons utiliser à peu près le même type de recette pour les modèles de réseaux neuronaux, selon une série d'articles commençant par <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a>.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://proceedings.mlr.press/v162/wortsman22a.html\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time</div><div class=\"kg-bookmark-description\">The conventional recipe for maximizing model accuracy is to (1) train multiple models with various hyperparameters and (2) pick the individual model which performs best on a held-out validation set…</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-pmlr.ico\" alt=\"\"><span class=\"kg-bookmark-author\">PMLR</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://proceedings.mlr.press/v162/assets/images/logo-pmlr.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Les « soupes de modèles » (hélas, pas les « plats en casserole de modèles » ni les « sautés de modèles ») sont une classe de techniques d'assemblage de modèles conçues pour atténuer le coût de l'optimisation des données d'entraînement et des hyperparamètres des modèles. Lors de l'entraînement d'un réseau neuronal, vous essayez généralement différentes données et valeurs d'hyperparamètres et vous vous entraînez plusieurs fois, à la recherche du meilleur résultat. L'entraînement est très coûteux en termes de calcul, et les coûts s'additionnent rapidement.</p><p>Au lieu de cela, les soupes de modèles consistent à entraîner plusieurs modèles avec différents hyperparamètres et choix de données d'entraînement - comme vous le feriez habituellement - mais en les combinant ensuite. Le résultat est un modèle plus performant et plus robuste que le meilleur modèle individuel. Cela ne permet pas de réduire les coûts car vous entraînez toujours plusieurs modèles, mais vous pouvez obtenir un meilleur résultat pour le même prix.</p><p>L'approche de la soupe de modèles s'est déjà avérée utile pour les modèles d'intégration multimodaux texte-image <a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">(Wortsman et al. 2022)</a> et les grands modèles de langage génératifs. (<a href=\"https://doi.org/10.1038/s42256-024-00975-8\">Takuya et al. 2025</a>) Chez Jina AI, nous avons commencé à utiliser cette technique pour entraîner nos propres modèles, et <code>jina-embeddings-v3</code> et <code>reader-lm-v2</code> incorporent tous deux des soupes de modèles.</p><p>Dans cet article, nous allons examiner les soupes de modèles et montrer les résultats de certains de nos travaux avec elles. Plus précisément :</p><ol><li>Pouvons-nous utiliser les soupes de modèles pour améliorer les performances en fusionnant des modèles à différents moments de leur entraînement ?</li><li>Pouvons-nous fusionner des modèles entraînés avec différents ensembles de données et pour différentes tâches afin d'obtenir de meilleures performances et une efficacité d'entraînement supérieure à celle obtenue en entraînant un seul modèle ?</li></ol><p>Cela présente d'importants avantages potentiels :</p><ul><li>Les soupes de modèles peuvent avoir des performances meilleures et plus robustes.</li><li>Les modèles d'intégration multilingues souffrent souvent de biais et d'échecs de performance causés par des quantités inégales de données d'entraînement. Ce serait une aubaine de pouvoir entraîner le meilleur modèle possible sur chaque tâche ou ensemble de données individuellement, puis de les combiner de manière égale.</li><li>Nous pourrions être en mesure d'améliorer l'apprentissage continu et la mise à jour des modèles en apportant des modifications à nos modèles de manière modulaire, en mettant à jour un modèle de composant à la fois, puis en le refusionnant avec les autres.</li></ul><h2 id=\"how-does-it-work\">Comment ça Marche ?</h2><p>La fusion des sorties de plusieurs modèles est une technique ancienne dans la théorie statistique de la décision. Par exemple, il est courant dans les prévisions météorologiques de créer plusieurs modèles, souvent réalisés par différentes personnes avec différentes hypothèses, puis d'utiliser divers mécanismes pour faire la moyenne de leurs prédictions. Si les erreurs de chaque modèle sont distribuées aléatoirement, la moyenne des modèles conduira à des réponses avec moins d'erreurs.</p><p>Par exemple, si vous avez trois modèles différents qui produisent un « oui » ou un « non » binaire, et que chacun se trompe 10 % du temps, alors deux sur les trois se tromperont seulement 2,8 % du temps. Cinq modèles, avec un critère de décision majoritaire, ne se tromperont que 0,856 % du temps.</p><p>La moyenne des modèles fonctionne sur le même principe, mais au lieu de combiner les sorties de différents modèles, elle combine les modèles eux-mêmes.</p><p>L'approche utilisée est une extension de la <em>moyenne stochastique des poids</em> (<a href=\"https://auai.org/uai2018/proceedings/papers/313.pdf\">Izmailov et al. 2018</a>), qui s'appuie sur des connaissances approfondies des paysages de perte des réseaux neuronaux pour montrer qu'une simple moyenne des poids peut améliorer les performances de généralisation du modèle dans des conditions courantes.</p><p>La mécanique réelle de la moyenne des modèles est incroyablement simple : il suffit de faire la moyenne des poids de plusieurs modèles.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/05/image.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"380\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/05/image.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/05/image.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2025/05/image.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/size/w2400/2025/05/image.png 2400w\" sizes=\"(min-width: 1200px) 1200px\"><figcaption><span style=\"white-space: pre-wrap;\">Comment les modèles sont fusionnés pour créer une soupe de modèles. Cet exemple est très petit et simple, mais il montre quand même la procédure : Additionnez les poids et divisez par le nombre de modèles fusionnés.</span></figcaption></figure><p>Si cela semble trop facile, il est important de noter qu'il existe des limitations lors de la fusion de modèles de cette manière. Vous ne pouvez pas simplement fusionner les poids de deux réseaux neuronaux et vous attendre à ce que cela fonctionne.</p><p>La moyenne des modèles ne fonctionne que sur des modèles très similaires, c'est-à-dire des modèles dont les poids ne sont pas très différents les uns des autres au départ. La façon de s'en assurer est de pré-entraîner un modèle, puis de créer plusieurs variantes de ce modèle en les affinant avec différents hyperparamètres ou différentes données. Ces modèles seront généralement suffisamment similaires pour être moyennés.</p><p>En termes plus techniques, le pré-entraînement produit généralement un modèle dont les poids sont proches du bas d'un bassin de perte, et l'affinage ne permet pas facilement d'échapper à ce bassin de perte. Si tous les modèles à fusionner ont des poids dans le même bassin de perte, alors leurs poids seront assez proches les uns des autres, et il est probable que leur moyenne fonctionne. Ce n'est pas garanti, mais empiriquement, cela semble être vrai assez souvent pour être utile.</p><h2 id=\"experimental-setup\">Configuration Expérimentale</h2><p><strong>Modèle de base</strong> : Pour les expériences décrites ici, nous avons utilisé <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code> de FacebookAI</a> (<a href=\"https://aclanthology.org/2020.acl-main.747/\">Conneau et al. 2020</a>) comme modèle de base pré-entraîné. Ce modèle a 280 millions de paramètres et a été pré-entraîné sur 2,5 To de données Common Crawl contenant du texte dans environ 100 langues.</p><p>Nous avons affiné <a href=\"https://huggingface.co/FacebookAI/xlm-roberta-base\"><code>xlm-roberta-base</code></a> sur notre ensemble d'entraînement de paires de phrases spécialement conçu pour l'entraînement des intégrations, avant d'effectuer nos expériences.</p><p><strong>Données d'entraînement</strong> : Jina AI maintient des ensembles de données spécialement conçus pour l'entraînement. Pour la première expérience, nous avons utilisé des triplets de phrases spécialement conçus pour l'entraînement contrastif dans six langues : anglais, arabe, allemand, espagnol, japonais et chinois. Pour la deuxième expérience, nous avons utilisé des ensembles de données d'entraînement spécifiques à la tâche en anglais.</p><p><strong>Évaluation</strong> : Nous avons utilisé les parties pertinentes de l'<a href=\"https://github.com/embeddings-benchmark/mteb/tree/main/docs/mmteb\">ensemble de référence MMTEB</a> (<a href=\"https://arxiv.org/abs/2502.13595\">Enevoldsen et al. 2025</a>) et de l'<a href=\"https://project-miracl.github.io/\">ensemble de référence MIRACL</a> (<a href=\"https://direct.mit.edu/tacl/article/doi/10.1162/tacl_a_00595/117438/MIRACL-A-Multilingual-Retrieval-Dataset-Covering\">Zhang et al. 2023</a>) pour évaluer les modèles produits par notre entraînement et notre fusion.</p><h3 id=\"experiment-1-single-run-averaging\">Expérience 1 : Moyenne à Passage Unique</h3><p>Pour cette expérience, nous avons utilisé des triplets de phrases contrastives dans les six langues, mélangés, pour un total de 6 000 étapes d'entraînement avec une taille de lot de 1 024 éléments. Toutes les 2 000 étapes, nous avons enregistré l'état du modèle pour le calcul de la moyenne, produisant ainsi 3 modèles, chacun reflétant un point différent dans le processus d'entraînement.</p><p>Nous avons fait la moyenne des trois modèles pour produire un modèle final. Nous avons ensuite testé le modèle fusionné et les trois points de contrôle enregistrés par rapport aux ensembles de référence MMTEB-STS et MIRACL.</p><p>Nos résultats sont résumés dans le tableau ci-dessous :</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Modèle</th>\n<th>MIRACL<br>(moyenne de 6 langues)</th>\n<th>MMTEB-STS Anglais<br>(moyenne de 8 benchmarks)</th>\n<th>MMTEB-STS Multilingue<br>(moyenne de 6 benchmarks)</th>\n<th>Moyenne de 20 benchmarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pas d'entraînement par triplet</td>\n<td>0.3163</td>\n<td>0.7859</td>\n<td>0.7322</td>\n<td>0.6276</td>\n</tr>\n<tr>\n<td>Étape 2000</td>\n<td>0.4631</td>\n<td><strong>0.7924</strong></td>\n<td>0.7561</td>\n<td>0.6813</td>\n</tr>\n<tr>\n<td>Étape 4000</td>\n<td>0.4639</td>\n<td>0.7902</td>\n<td><strong>0.7583</strong></td>\n<td>0.6812</td>\n</tr>\n<tr>\n<td>Étape 6000 (finale)</td>\n<td><strong>0.4680</strong></td>\n<td>0.7891</td>\n<td>0.7575</td>\n<td>0.6818</td>\n</tr>\n<tr>\n<td>Modèle fusionné<br>(les 3 points de contrôle stockés)</td>\n<td>0.4669</td>\n<td>0.7910</td>\n<td>0.7579</td>\n<td><strong>0.6823</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>La fusion avec les points de contrôle précédents n'a généralement pas produit un modèle plus performant que le modèle le plus performant parmi les points de contrôle stockés sur les benchmarks individuels ou sur l'une des trois batteries de benchmarks utilisées. Cependant, il a produit le meilleur modèle sur tous les benchmarks moyennés ensemble.</p><p>Dans les benchmarks individuels, la différence entre le modèle fusionné et le point de contrôle le plus performant est dans tous les cas inférieure à 0,01. Cela est vrai non seulement pour les moyennes dans le tableau ci-dessus, mais aussi pour chaque test individuel.</p><p>Cela démontre que la fusion de différents points de contrôle d'entraînement peut produire un modèle plus robuste à un coût de performance très faible.</p><p>De plus, en fusionnant les différents points de contrôle, nous pouvons effectivement nous prémunir contre le surapprentissage. Le surapprentissage est récemment devenu un sujet important dans les réseaux neuronaux. (<a href=\"https://arxiv.org/abs/2503.19206v2\">Springer et al., 2025</a>) Un réseau peut être entraîné d'une manière qui le rend plus difficile et moins performant après un affinage supplémentaire.</p><p>Étant donné que le point de contrôle le plus performant dans notre expérience n'est souvent pas le dernier, nous avons probablement surappris notre modèle à 6 000 étapes d'entraînement. Le modèle fusionné se rapproche très près des performances du meilleur point de contrôle dans tous les tests, éliminant ainsi les défauts du surapprentissage.</p><h3 id=\"experiment-2-averaging-models-trained-for-different-tasks\">Expérience 2 : Moyenne des Modèles Entraînés pour Différentes Tâches</h3><p>Pour cette expérience, nous avons entraîné trois modèles, chacun pour une tâche d'intégration courante différente :</p><ul><li><strong>Similarité sémantique</strong> : Mesurer le chevauchement ou la similarité relative de sens entre deux textes, généralement de longueur comparable.</li><li><strong>Récupération de documents basée sur des requêtes textuelles</strong> : Trouver les documents qui répondent le mieux à une requête. Les requêtes sont généralement des textes beaucoup plus courts que les documents auxquels elles correspondent.</li><li><strong>Réponse aux questions</strong> : Trouver le document qui répond le mieux à une question en langage naturel. Les questions sont également généralement plus courtes que les textes auxquels elles correspondent.</li></ul><p>L'entraînement de modèles pour les trois tâches à la fois est assez difficile car les objectifs sont très différents, et nous espérons que les soupes de modèles amélioreront le processus.</p><p>D'après notre expérience précédente, nous savions que chaque tâche nécessitait un nombre différent d'époques d'entraînement. L'entraînement est résumé ci-dessous :</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Tâche</th>\n<th>Étapes d'entraînement<br>(taille du lot = 1 024)</th>\n<th>Taille de l'ensemble de données d'entraînement<br>(en éléments)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Réponse aux questions (QA)</td>\n<td>2 000</td>\n<td>256 000</td>\n</tr>\n<tr>\n<td>Récupération de documents</td>\n<td>3 000</td>\n<td>384 000</td>\n</tr>\n<tr>\n<td>Similarité sémantique (STS)</td>\n<td>1 000</td>\n<td>128 000</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Cela a produit trois modèles, que nous avons ensuite fusionnés en un seul modèle. Nous avons testé le modèle résultant par rapport aux parties de l'ensemble de référence MMTEB pertinentes pour ces trois tâches : <a href=\"https://project-miracl.github.io/\">MIRACL</a>, <a href=\"https://huggingface.co/collections/zeta-alpha-ai/nanobeir-66e1a0af21dfd93e620cd9f6\">NanoBEIR</a> et STSEval (parties anglaises et multilingues de MMTEB).</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(moyenne de 6 langues)</th>\n<th>NanoBEIR<br>(moyenne de 13 benchmarks)</th>\n<th>MMTEB-STS anglais<br>(moyenne de 9 benchmarks)</th>\n<th>MMTEB-STS multilingue<br>(moyenne de 6 benchmarks)</th>\n<th>Moyenne de 34 benchmarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Aucun entraînement de triplet</td>\n<td>0,3163</td>\n<td>0,5089</td>\n<td>0,7859</td>\n<td>0,7322</td>\n<td>0,5876</td>\n</tr>\n<tr>\n<td>Entraînement QA</td>\n<td><strong>0,4489</strong></td>\n<td>0,5332</td>\n<td>0,7843</td>\n<td>0,7535</td>\n<td>0,6237</td>\n</tr>\n<tr>\n<td>Entraînement à la récupération</td>\n<td>0,4272</td>\n<td><strong>0,5360</strong></td>\n<td>0,7766</td>\n<td>0,7340</td>\n<td>0,6154</td>\n</tr>\n<tr>\n<td>Entraînement STS</td>\n<td>0,1779</td>\n<td>0,4519</td>\n<td><strong>0,7994</strong></td>\n<td><strong>0,7651</strong></td>\n<td>0,5508</td>\n</tr>\n<tr>\n<td>Modèle fusionné</td>\n<td>0,4246</td>\n<td>0,5309</td>\n<td>0,7981</td>\n<td>0,7640</td>\n<td><strong>0,6240</strong></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Nous constatons ici que les modèles entraînés pour des tâches spécifiques ont les meilleures performances pour chaque tâche. MIRACL est principalement un benchmark de réponse aux questions, même s'il est appelé benchmark de récupération, et le modèle entraîné à la QA surpasse tous les autres sur ce point, y compris le modèle fusionné. NanoBEIR est un ensemble de benchmarks de recherche d'informations plus conventionnel, et nous constatons que le modèle entraîné à la récupération est le plus performant. Le modèle de similarité sémantique (STS) obtient de très mauvais résultats sur ces benchmarks, mais bat les autres sur les tâches STS explicites. Pour chaque catégorie, le modèle fusionné est moins performant que le modèle entraîné pour une seule tâche.</p><p>Mais une fois de plus, si nous faisons la moyenne de tous les benchmarks, le modèle fusionné surpasse les autres, bien que son score ne représente qu'une très légère amélioration par rapport au modèle entraîné à la QA, et qu'il soit très peu performant sur les tâches STS.</p><p>Nous avons également fusionné uniquement les modèles QA et de récupération et avons noté le modèle résultant sur les mêmes benchmarks :</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIRACL<br>(moyenne de 6 langues)</th>\n<th>NanoBEIR<br>(moyenne de 13 benchmarks)</th>\n<th>MMTEB-STS anglais<br>(moyenne de 9 benchmarks)</th>\n<th>MMTEB-STS multilingue<br>(moyenne de 6 benchmarks)</th>\n<th>Moyenne de 34 tests</th>\n<th>Moyenne<br>QA et IR<br>(19 tests)</th>\n<th>Moyenne STS<br>(15 tests)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Meilleur modèle entraîné à une tâche</td>\n<td>0,4489</td>\n<td>0,5360</td>\n<td><strong>0,7994</strong></td>\n<td><strong>0,7651</strong></td>\n<td>0,6237</td>\n<td>0,5066</td>\n<td><strong>0,7857</strong></td>\n</tr>\n<tr>\n<td>Modèle fusionné</td>\n<td>0,4246</td>\n<td>0,5309</td>\n<td>0,7981</td>\n<td>0,7640</td>\n<td>0,6240</td>\n<td>0,4973</td>\n<td>0,7845</td>\n</tr>\n<tr>\n<td>Modèle fusionné QA+Récupération</td>\n<td><strong>0,4610</strong></td>\n<td><strong>0,5404</strong></td>\n<td>0,7878</td>\n<td>0,7498</td>\n<td><strong>0,6288</strong></td>\n<td><strong>0,5153</strong></td>\n<td>0,7726</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Nous constatons ici que si nous pouvons améliorer les performances en matière de réponse aux questions et de récupération en fusionnant des modèles entraînés pour les deux tâches, l'ajout de modèles entraînés au STS réduit les performances spécifiques à chaque tâche dans toutes les catégories. Cela suggère que la similarité sémantique est, à certains égards importants, différente de la QA et de la récupération, et qu'un modèle entraîné au STS n'est pas adapté à la fusion avec les deux autres.</p><p>Ceci est probablement dû au fait que la réponse aux questions et la récupération impliquent la mise en correspondance de textes courts (questions et requêtes) avec des documents plus longs, tandis que la similarité sémantique implique la comparaison de documents de longueur plus similaire.</p><p><a href=\"https://proceedings.mlr.press/v162/wortsman22a.html\">Wortsman et al. (2022)</a> décrivent une approche sélective de la moyenne qu'ils appellent la fusion « gloutonne ». Elle consiste à prendre un modèle, généralement le plus performant d'un ensemble de modèles, puis à n'ajouter que les modèles qui améliorent individuellement les performances. Avec seulement trois modèles, il était peu utile d'utiliser la fusion gloutonne pour cette expérience. Cependant, nous pourrions imaginer un cas avec plus de modèles et utiliser une technique comme celle-ci comme base pour déterminer le degré de similarité entre les tâches. Nous avons constaté ici que la similarité sémantique est différente des deux autres. Nous pourrions alors évaluer quand un modèle peut effectuer de nombreuses tâches et quand il est plus rentable d'utiliser un modèle différent.</p><h2 id=\"soup%E2%80%99s-on\">À table !</h2><p>Les soupes de modèles mélangent la diversité en quelque chose de plus grand que la somme de leurs parties. La valeur de cette approche réside dans sa capacité à offrir une plus grande cohérence, une plus grande robustesse et à agir comme une sauvegarde contre le surentraînement sans coût d'entraînement supplémentaire. Nos expériences montrent que la fusion de points de contrôle ou de modèles spécialisés dans les tâches peut améliorer les performances globales, même si cela se fait parfois au détriment des pics spécifiques aux tâches.</p><p>En fin de compte, les soupes de modèles offrent un moyen pratique et très simple de créer des modèles plus adaptables, bien que cela s'accompagne de quelques mises en garde. Ce n'est pas une panacée, et cela ne s'applique que lorsque les modèles sont déjà très similaires.</p><p>Comme on dit sur Internet, <em>Your Mileage May Vary</em>. Mais il est facile et peu coûteux de découvrir si les soupes de modèles peuvent vous aider lorsque vous entraînez vos modèles.</p>",
  "comment_id": "681b63a077c406000104263b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/05/Heading--6-.jpg",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-05-07T15:44:00.000+02:00",
  "updated_at": "2025-05-07T19:56:02.000+02:00",
  "published_at": "2025-05-07T18:43:10.000+02:00",
  "custom_excerpt": "Boost robustness and performance with model soups: averaging weights. No extra cost, better results.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "authors": [
    {
      "id": "6360e7e05e0f6e004d70bd99",
      "name": "Bo Wang",
      "slug": "bo",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
      "cover_image": null,
      "bio": "Developer @Jina, Contributor to open source ",
      "website": "https://bwanglzu.github.io/",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@bo_wangbo",
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
    },
    {
      "id": "632ae7353e4e55003d52598e",
      "name": "Scott Martens",
      "slug": "scott",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/photo-of-me-cropped.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/shanshui-ernie-crop.png",
      "bio": "A rogue AI created by Canada's Weapon X program.\n\nContent Creator @ Jina AI",
      "website": "https://jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "threads": null,
      "bluesky": null,
      "mastodon": null,
      "tiktok": null,
      "youtube": null,
      "instagram": null,
      "linkedin": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/scott/"
    }
  ],
  "primary_author": {
    "id": "6360e7e05e0f6e004d70bd99",
    "name": "Bo Wang",
    "slug": "bo",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/4B483B29-E306-402B-8635-64866C458406.jpeg",
    "cover_image": null,
    "bio": "Developer @Jina, Contributor to open source ",
    "website": "https://bwanglzu.github.io/",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@bo_wangbo",
    "meta_title": null,
    "meta_description": null,
    "threads": null,
    "bluesky": null,
    "mastodon": null,
    "tiktok": null,
    "youtube": null,
    "instagram": null,
    "linkedin": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/bo/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/model-soups-recipe-for-embeddings/",
  "excerpt": "Améliorez la robustesse et les performances avec les soupes de modèles : moyenne des poids. Aucun coût supplémentaire, de meilleurs résultats.",
  "reading_time": 9,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}