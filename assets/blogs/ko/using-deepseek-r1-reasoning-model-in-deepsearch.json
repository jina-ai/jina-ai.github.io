{
  "slug": "using-deepseek-r1-reasoning-model-in-deepsearch",
  "id": "67dd5037143bda0001036423",
  "uuid": "3ebc2ba7-b65b-408b-9466-ca902b28756a",
  "title": "DeepSeek R1 추론 모델을 DeepSearch에서 사용하기",
  "html": "<p>우리의 관점에서 DeepSearch는 본질적으로 큰 while-loop입니다. (<a href=\"https://jina.ai/news/a-practical-guide-to-implementing-deepsearch-deepresearch\">링크</a>) 최대 토큰 예산이 주어지면, 최상의 답을 찾을 때까지 검색, 읽기, 생각하기를 반복합니다. LLM의 주요 작업 중 하나는 현재 메모리 상태를 기반으로 다음에 취할 행동을 결정하는 것입니다. 계속 검색해야 할까요? 웹페이지를 읽어야 할까요? 아니면 질문에 직접 답해야 할까요?</p><p>우리의 <a href=\"https://github.com/jina-ai/node-DeepResearch\">node-deepresearch</a> 구현에서는 행동을 선택하기 위해 <em>표준</em> LLM(<code>gemini-2.0-flash</code>)을 사용합니다. 추론 과정이 프롬프트 엔지니어링을 통해 명시적으로 개략되고, 선택된 행동이 JSON 객체로 반환되는 sequence-in, sequence-out 방식으로 작동하기 때문에 \"표준\"이라고 부릅니다. 그래서 자연스러운 질문이 생깁니다: 이 의사결정 단계를 전용 추론 모델로 대체하면 DeepSearch의 성능이 향상될까요?</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/04/Heading--91-.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1200\" height=\"630\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/04/Heading--91-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/04/Heading--91-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2025/04/Heading--91-.png 1200w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">우리의 DeepSearch 구현에서 큰 while-loop의 행동-결정 단계는 현재 컨텍스트와 메모리를 기반으로 다음 행동이 무엇이어야 하는지 결정합니다.</span></figcaption></figure><p>이 포스트에서는 이 의사결정 단계에서 <code>gemini-2.0-flash</code>를 대체하기 위해 추론 LLM인 <a href=\"https://github.com/deepseek-ai/DeepSeek-R1\">DeepSeek R1</a> 671b를 사용하는 것을 탐구합니다. R1의 추론 능력이 웹 검색과 결과 분석의 복잡한 문제를 해결하는 데 도움이 될 것이라고 믿습니다.</p><p>이 개념을 테스트하기 위해, 실용적인 예시로 3일간의 종합적인 휴가 일정을 계획하도록 하고 그 성능을 평가해보았습니다. 딥 서치 작업을 수행하는 에이전트는 인간과 같은 종류의 문제에 직면할 수 있으므로, 우리의 휴가 작업에서 모델은 다음과 같은 문제를 마주할 수 있습니다:</p><ul><li><strong>지식 격차(다른 정보에 의존하는 정보)</strong>: 예를 들어, 에펠탑을 방문하고 싶지만 공휴일에 문을 여는지 모릅니다. 탑의 휴일 일정과 프랑스 공휴일 날짜를 모두 찾아야 합니다.</li><li><strong>잘못되거나 오래된 정보</strong>: 2020년의 여행 블로그에서 로마의 특정 레스토랑이 일요일에 영업한다고 제안했지만, 도착해보니 영업시간이 변경되어 이제는 일요일에 문을 닫습니다.</li><li><strong>모순된 정보</strong>: 한 여행 웹사이트는 뉴욕의 특정 호텔이 무료 조식을 제공한다고 주장하는 반면, 다른 사이트는 조식이 객실 요금에 포함되지 않는다고 명시합니다.</li><li><strong>모호한 정보</strong>: 여행 포럼 게시물에서 \"바르셀로나 근처의 훌륭한 해변\"을 언급하지만 어떤 해변인지 구체적으로 명시하거나 명확한 방향을 제공하지 않아 정확한 위치를 파악하기 어렵습니다.</li></ul><p>R1은 복잡한 작업을 실행 가능한 단계로 분해하고, 격차와 불일치를 식별하며, 차단된 웹사이트와 구독자 벽과 같은 장애물을 탐색할 수 있습니다. 필요한 지식을 수집하고 답변을 종합하는 추론 능력을 가지고 있습니다. 하지만 혼자서 휴가를 계획할 수는 없습니다 — 그것은 웹을 검색하고 검색 결과를 이해하는 것이 필요합니다. 이 작업을 수행할 수 있도록 프레임워크를 구축하고 능력을 향상시켜야 합니다.</p><h2 id=\"implementation\">구현</h2><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/18sqU8_eWqFleKqpd-SnGDNmZ_P1KLfXw?usp=sharing#scrollTo=2jFWdbnp_6ws\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon-32.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/colab_favicon_256px-7.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">노트북을 실행하려면 무료 </span><a href=\"https://jina.ai\"><span style=\"white-space: pre-wrap;\">Jina AI</span></a><span style=\"white-space: pre-wrap;\">와 </span><a href=\"https://openrouter.ai\"><span style=\"white-space: pre-wrap;\">OpenRouter</span></a><span style=\"white-space: pre-wrap;\"> API 키가 필요합니다.</span></p></figcaption></figure><p>R1이 우리 에이전트의 엔진이지만, 우리는 여기에 몇 가지 도구, 상태 객체, 그리고 물론 (꽤 큰) 프롬프트도 추가합니다. 다음은 단순화된 표현입니다:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/03/image-29.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1639\" height=\"2256\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/03/image-29.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/03/image-29.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2025/03/image-29.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2025/03/image-29.png 1639w\" sizes=\"(min-width: 720px) 720px\"></figure><ul><li><strong>도구들</strong>은 모델이 웹을 검색하고 스크랩하기 위해 호출할 수 있으며, 결과는 상태에 저장됩니다.</li><li><strong>상태</strong>는 도구 결과, 작업 상태, 지식을 추적합니다. 프롬프트 자체에 저장됩니다.</li><li><strong>단일 프롬프트</strong>는 작업과 수행 방법을 지정하는 지침을 제공하고 상태를 저장합니다.</li></ul><p>이들 각각에 대해 나중에 자세히 살펴보겠습니다, 특히 프롬프트에 대해서는요. 하지만 간단히 말하면, 시스템은 다음과 같이 작동합니다:</p><p>채워지지 않은 상태 객체가 있는 프롬프트로 시작합니다. 작업이 진행 중인 동안(즉, 답변을 생성하려고 시도하는 동안) 에이전트는 답변을 생성할 때까지 다음 루프를 실행합니다:</p><ol><li>모델이 프롬프트에서 작업과 상태를 검토하고, 답변을 얻기 위해 도구를 가장 잘 사용하는 방법을 추론합니다.</li><li>모델은 상태(<code>IN PROGRESS</code> 또는 <code>DONE</code>), 메모리 업데이트, 도구 호출, 답변(초기에는 <code>null</code>)을 지정하는 JSON 객체를 출력합니다.</li><li>에이전트는 도구를 비동기적으로 호출하고 결과는 3단계의 JSON 객체와 함께 프롬프트에 다시 임베딩됩니다.</li><li>이 새로운 정보가 포함된 프롬프트는 다시 모델에 입력되어 다른 루프를 실행합니다.</li></ol><p>모델이 출력에서 답변을 제공하는 즉시 작업이 종료되고 답변이 전달됩니다.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">에이전트가 실제로 어떻게 작동하는지 더 잘 이해하려면 <a href=\"https://colab.research.google.com/drive/18sqU8_eWqFleKqpd-SnGDNmZ_P1KLfXw?usp=sharing#scrollTo=2jFWdbnp_6ws\">노트북</a>을 직접 시도해보고 각 반복에서의 출력을 검토해보시기 바랍니다.</div></div><p>이제 고수준 개요를 살펴보았으니, 도구, 상태, 프롬프트를 차례로 살펴보겠습니다:</p><h2 id=\"tools\">도구</h2><p>R1이 혼자서는 웹을 검색하거나 스크랩할 수 없기 때문에, Jina의 Reader API를 사용하여 기능을 확장합니다. 여기에는 두 가지 모드가 포함됩니다:</p><ul><li><strong>검색 모드</strong>: 관련 용어를 웹에서 검색하고 검색 엔진 결과를 반환합니다(각 결과의 URL, 제목, 설명 포함).</li><li><strong>읽기 모드</strong>: 검색 결과에서 페이지를 스크랩하고 Markdown 형식으로 반환합니다.</li></ul><p>R1의 제한된 컨텍스트 윈도우 때문에, 전체 페이지를 프롬프트의 <code>Tool Results</code> 섹션에 그냥 넣을 수는 없습니다. 모델에 전달하기 전에 가장 관련성 있는 정보만 선택하기 위한 추가 도구가 필요합니다:</p><ul><li><a href=\"https://python.langchain.com/docs/concepts/text_splitters/\"><strong>LangChain recursive character text splitter</strong></a>: <code>RecursiveCharacterTextSplitter</code>로 긴 출력을 단락과 문장 단위로 재귀적으로 분할하여 원하는 세그먼트 크기를 얻습니다. 이를 통해 출력이 R1의 제한된 컨텍스트 윈도우에서 쉽게 처리될 수 있습니다.</li><li><a href=\"https://jina.ai/reranker\"><strong>Jina Reranker</strong></a>: <code>jina-reranker-v2-base-multilingual</code>로 세그먼트의 순위를 재조정하고 상위 순위 세그먼트를 하나의 결과로 결합합니다.</li></ul><p>안타깝게도, DeepSeek R1은 <code>o3-mini</code>처럼 도구를 지원하지 않습니다. 예를 들어, <code>o3-mini</code>에서는 다음과 같이 사용할 수 있습니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-python\">def scrape_page(url: str):\n    \"\"\"Scrape a web page with Jina Reader\"\"\"\n\ntools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"scrape_page\",\n            \"description\": \"Scrape the content of a webpage\",\n            \"parameters\": {\n                \"url\": {\"type\": \"string\", \"description\": \"The URL to scrape\"}\n            }\n        }\n    }\n]\n\nclient = OpenAI()\nresponse = client.completions.create(\n    model=\"o3-mini\",\n    prompt=f\"Scrape www.skyscanner.net/routes/gr/de/germany-to-crete.html\",\n    tools=tools\n)\n</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">도구 사용을 지원하는 o3-mini 코드 예시</span></p></figcaption></figure><p>하지만 R1에서는 이렇게 하기가 쉽지 않습니다: API에 전달할 수 있는 <code>tools</code> 매개변수가 없고, 응답의 일부로 구조화된 <code>tool_calls</code>를 반환하지 않습니다. 간단히 말해서, 도구를 사용하도록 훈련되지 않았습니다(<a href=\"https://github.com/deepseek-ai/DeepSeek-R1/issues/9\">그리고 곧 지원할 예정도 없습니다</a>). 적어도 전통적인 의미에서는 지원하지 않습니다. 하지만 R1에게 도구 호출을 JSON 형식으로 출력하도록 요청하고, 도구 호출 결과를 다시 모델에 피드백하여 분석할 수는 있습니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">You must respond with a valid JSON object containing:\n```json\n{\n  \"tool_calls\": [\n    {\"tool\": \"search\", \"input\": \"Cheapest flights from Germany to Crete May 2025\"},\n    {\"tool\": \"scrape\", \"input\": \"&lt;https://www.skyscanner.net/routes/gr/de/germany-to-crete.html&gt;\"}\n  ]\n}\n```</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">R1의 프롬프트 일부로서의 도구 호출</span></p></figcaption></figure><p>반복 <em>n</em>에서 모델이 도구 호출을 출력하면, 도구가 호출되고 결과가 반복 <em>n+1</em>에서 모델이 추론할 수 있도록 프롬프트의 <code>Tool Results</code> 섹션에 포함됩니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">Tool Results:\n\nSource 1️: search: Cheapest flights from Germany to Crete May 2025\nResult:\n\n```\nTitle: Affordable flights: Germany - Heraklion (Crete) (HER) | Eurowings URL Source: https://www.eurowings.com/en/booking/offers/flights-from/DE/to/GR/HER.html Description: Affordable flights from Germany to Heraklion (Crete) ✈ Eurowings brings you closer to your dream destination from as little as €89.99*. Book now and enjoy.\nTitle: Are you a person or a robot? URL Source: https://www.skyscanner.com/routes/fran/her/frankfurt-to-crete-heraklion.html Description: Book a one-way ticket from Frankfurt to Heraklion Airport from $78 or travel return from just $154. The prices shown are based on availability and could change ...\n```\n</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">독일-크레타 항공편 검색 결과를 보여주는 도구 결과</span></p></figcaption></figure><h2 id=\"state\">상태</h2><p>상태는 태스크 상태(<code>Status</code>)와 모델이 분석하고 업데이트해야 하는 지식(<code>Memory</code>)을 추적합니다. 간단히 말해서, 이는 시스템의 작업 메모리와 메모리 뱅크입니다. 이것은 <code>{{ workspace }}</code>라고 불리는 프롬프트 섹션에 저장되며 처음에는 빈 상태로 시작됩니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">Status: IN_PROGRESS\nMemory: \n... no memory blocks ..\n</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">빈 상태 객체</span></p></figcaption></figure><p>모델이 태스크에 대해 추론하고, 도구를 실행하고, 출력을 수집하면서 상태는 각각 무작위로 할당된 ID를 가진 메모리 블록(도구 출력에서 도출됨)으로 채워집니다. 우리의 휴가 계획 예시에서, 에이전트의 한 반복을 실행한 후 상태는 다음과 같을 수 있습니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">Status: IN_PROGRESS\nMemory: \n&lt;nuz-032&gt;Potential warm May destinations: Malaga (Spain), Crete (Greece), Algarve (Portugal)&lt;/nuz-032&gt;\n&lt;xwj-969&gt;URL to scrape for Crete hotel details: &lt;https://www.tripadvisor.com/HotelsList-Crete-Beachfront-Cheap-Hotels-zfp13280541.html&gt;&lt;/xwj-969&gt;\n&lt;vsc-583&gt;URL to scrape for flight details: &lt;https://www.expedia.com/lp/flights/fra/her/frankfurt-to-heraklion&gt;&lt;/vsc-583&gt;\n</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">DeepSeek R1에 의해 채워진 상태</span></p></figcaption></figure><p>메모리 블록은 모델의 JSON 응답에 <code>memory_updates</code> 리스트를 포함시켜 업데이트됩니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-json\">{\n\t\"memory_updates\": [\n\t  {\"operation\": \"add\", \"content\": \"Round-trip flight from Berlin to Tenerife in May 2025 ranges from €59.99 to €200 round-trip as per the Skyscanner and Iberia sources.\"},\n\t  {\"operation\": \"delete\", \"id\": \"nuz-032\"},\n\t  ...\n\t]\n}</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">R1의 JSON 출력의 일부로서의 메모리 업데이트</span></p></figcaption></figure><ul><li><strong><code>add</code> 연산</strong>은 메모리 블록을 추가하며 중요한 정보(예: 실마리, 발견, 정보 격차, 이미 취한 조치)를 저장하는 데 사용될 수 있습니다.</li><li><strong><code>delete</code> 연산</strong>은 메모리 블록을 삭제하여 모델이 오래되거나, 불필요하거나, 잘못된 정보를 삭제하고 깨끗한 작업 공간을 유지할 수 있게 합니다.</li></ul><div class=\"kg-card kg-callout-card kg-callout-card-yellow\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">우리는 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">replace</code> 연산도 테스트했지만, 모델이 큰 정보 블록을 생성하는 것을 발견했고(<code spellcheck=\"false\" style=\"white-space: pre-wrap;\">replace</code>에 과도하게 의존), 이 옵션을 제거하기로 결정했습니다.</div></div><p>도구 호출을 수행하는 것과 비교하면, R1은 자체 메모리를 관리하는 데 덜 익숙합니다. 모델이 복잡한 수학 문제와 코딩 작업을 추론하도록 특별히 훈련되었지만(이 훈련으로 정확한 JSON 객체를 생성하고 도구 호출을 실행할 수 있음), 메모리와 같은 상태를 관리하도록 훈련되지는 않았습니다(우리가 아는 다른 모델도 마찬가지입니다).</p><p>압축된 메모리와 같은 상태를 사용하여 정보를 저장하는 것은 각 라운드마다 모델의 전체 출력을 저장하는 것보다 여러 가지 장점이 있습니다. 이 접근 방식은 프롬프트 내의 정보를 압축하여 컨텍스트 오버플로우를 방지하면서 관련 지식에 대한 모델의 집중도를 향상시킵니다. 우리는 JSON을 사용합니다. 업데이트하기 쉽지만 JSON은 프롬프트 자체에서 사람이 읽을 수 있는 형식으로 렌더링됩니다.</p><p>그렇다 하더라도, 메모리 관리는 여전히 R1의 핵심 영역을 벗어납니다. 우리는 모델이 메모리 연산을 적절히 처리하도록 지도하기 위해 여러 지시사항을 구현해야 했습니다. 다음은 그와 관련된 우리 프롬프트의 일부입니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">... other contents of the prompt ...\n\n## Memory Block Usage\n- Each memory block has a unique ID in format &lt;abc-123&gt;content&lt;/abc-123&gt;\n- Create separate blocks for distinct pieces of information:\n  * Discovered URLs (both explored and pending)\n  * Information gaps that need investigation\n  * Actions already taken (to avoid repetition)\n  * Promising leads for future exploration\n  * Key facts and findings\n  * Contradictions or inconsistencies found\n- Keep each block focused on a single idea or piece of information\n- Always cite sources when recording information from tool results\n- Use IDs to track and manage your knowledge (e.g., deleting outdated information)\n- Make sure to store sources (URLs) for the facts and findings you store\n\n## Lead Management\n- Since you can only make 3 tool calls per round, store promising leads for later\n- Create dedicated memory blocks for URLs to scrape later\n- Maintain blocks for potential search queries to explore in future rounds\n- Prioritize leads based on relevance to the task\n\n... other contents of the prompt ...</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">프롬프트의 메모리 처리 지시사항</span></p></figcaption></figure><h2 id=\"prompt\">프롬프트</h2><p>우리는 <a href=\"https://jinja.palletsprojects.com/en/stable/templates/\">Jinja 템플릿 형식</a>을 사용하여 프롬프트를 만들었습니다. 여러 섹션으로 구성됩니다:</p><ul><li><strong>컨텍스트</strong> (이 경우, 현재 날짜).</li><li><strong>지시사항</strong>, 모든 작동 방식을 다루고, 사용 가능한 도구를 모델에게 알려줍니다.</li><li><strong>상태</strong>, 위에서 논의됨.</li><li><strong>도구 출력</strong>, <code>search</code>와 <code>scrape</code> 도구로부터.</li></ul><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">{% macro format_tool_results(tool_records) %}\n{% for to in tool_records %}\nSource {{ loop.index }}️: {{ to.tool }}: {{ to.input }}\nResult:\n```\n{{ to.output }}\n```\n{% endfor %}\n{% endmacro %}\n\nThe date: `{{ current_date }}`.\nYou are an information analysis and exploration agent that builds solutions through systematic investigation.\n\n## Investigation Cycle\nYou operate in a continuous investigation cycle:\n\n1. Review current workspace (your memory blocks)\n2. Analyze new tool results (or initial task if first round)\n3. Update memory with new insights and track investigation progress\n4. Decide on next tools to call based on identified leads and information gaps\n5. Repeat until task completion\n\n## Memory Structure\nYour memory persists between investigation cycles and consists of:\n- **Status**: Always the first line, indicates if the task is IN_PROGRESS or DONE\n- **Memory**: A collection of discrete information blocks, each with a unique ID\n\n## Memory Block Usage\n- Each memory block has a unique ID in format &lt;abc-123&gt;content&lt;/abc-123&gt;\n- Create separate blocks for distinct pieces of information:\n  * Discovered URLs (both explored and pending)\n  * Information gaps that need investigation\n  * Actions already taken (to avoid repetition)\n  * Promising leads for future exploration\n  * Key facts and findings\n  * Contradictions or inconsistencies found\n- Keep each block focused on a single idea or piece of information\n- Always cite sources when recording information from tool results\n- Use IDs to track and manage your knowledge (e.g., deleting outdated information)\n- Make sure to store sources (URLs) for the facts and findings you store\n\n## Lead Management\n- Since you can only make 3 tool calls per round, store promising leads for later\n- Create dedicated memory blocks for URLs to scrape later\n- Maintain blocks for potential search queries to explore in future rounds\n- Prioritize leads based on relevance to the task\n\n## Available Tools\n- **search**: Use for broad information gathering on new topics or concepts\n  * Example: {\"tool\": \"search\", \"input\": \"renewable energy statistics 2023\"}\n- **scrape**: Use for extracting specific details from discovered URLs\n  * Example: {\"tool\": \"scrape\", \"input\": \"https://example.com/energy-report\"}\n\n## Tool Usage Guidelines\n- **When to use search**: For new concepts, filling knowledge gaps, or exploring new directions\n- **When to use scrape**: For URLs discovered that likely contain detailed information\n- **Maximum 3 tool calls per round**\n- **Never repeat the exact same tool call**\n- **Always record valuable information from tool results in memory blocks**\n\n## Response Format\nYou must respond with a valid JSON object containing:\n\n```json\n{\n  \"status_update\": \"IN_PROGRESS or DONE\",\n  \"memory_updates\": [\n    {\"operation\": \"add\", \"content\": \"New insight or lead to investigate\"},\n    {\"operation\": \"delete\", \"id\": \"abc-123\"}\n  ],\n  \"tool_calls\": [\n    {\"tool\": \"search\", \"input\": \"specific search query\"},\n    {\"tool\": \"scrape\", \"input\": \"https://discovered-url.com\"}\n  ],\n  \"answer\": \"Your final, comprehensive answer when status is DONE\"\n}\n```\n\n## Important Rules\n- The \"add\" operation creates a new memory block\n\tYou do not need to specify an ID, it will be added automatically by the system.\n- The \"delete\" operation requires the specific ID of the block to remove\n- Never invent or fabricate information - only use facts from your memory or tool results\n- Never make up URLs - only use URLs discovered through tool results\n- CRITICAL: Any information not recorded in your memory blocks will be lost in the next round\n  For example, if you find a potential webpage to scrap, you must store the URL and your intention\n  Example: `{\"operation\": \"add\", \"content\": \"Found relevant URL: https://... to scrape ...\"}`\n- Set status to \"DONE\" only when you have fully addressed the task\n- Only include the \"answer\" field when status is \"DONE\"\n\nTask:\n```\n{{ task }}\n```\n\nCurrent workspace:\n```\n{{ workspace }}\n```\n\nTool Results:\n{{ format_tool_results(tool_records) if tool_records else '... no previous tool results ...'}}\n\nIMPORTANT: Generate a valid JSON response following the format above.\n\nThink carefully about:\n- what information do you need to preserve\n- which tools to call next\n- how to build your answer systematically with focused memory blocks</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">우리의 딥 서치 시스템에서 사용된 전체 프롬프트</span></p></figcaption></figure><div class=\"kg-card kg-callout-card kg-callout-card-yellow\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">프롬프트 상단의 Jinja 매크로 함수는 도구 결과를 더 깔끔한 형식으로 렌더링합니다.</div></div><h2 id=\"evaluation\">평가</h2><p>우리는 휴가 계획 예시로 시스템을 테스트 해보았습니다. 다음은 프롬프트에 포함된 작업입니다:</p><pre><code class=\"language-text\">Help me plan a 3 day holiday in Europe in May for under 2000 EUR\n1. I need specific flight and hotel recommendations.\n2. I want the destination to be warm.\n3. I want to have a beach nearby the hotel.\nI live in Germany.</code></pre><p>다음은 최종 결과입니다(다섯 번의 반복 후):</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">**3-Day Crete Holiday Plan (Total ≈ €600-800)**\n\n✈️ *Flights (From Frankfurt):*  \n- Skyscanner: €154 round trip (May 2025 dates)  \n  Source: &lt;https://www.skyscanner.com/routes/fran/her/frankfurt-to-crete-heraklion.html&gt;  \n- Backup: Eurowings €180 round trip  \n\n🏨 *Beachfront Hotels:*  \n1. **Georgioupolis Beach Hotel**  \n   - Direct beach access, bike rentals €10  \n   - Source: &lt;https://www.tripadvisor.com/HotelsList-Crete-Beachfront-Cheap-Hotels-zfp13280541.html&gt;  \n\n2. **JT Apartments**  \n   - €57/night, 9.5/10 rating, 5-min walk to beach  \n   - Source: &lt;https://www.booking.com/region/gr/crete.html&gt;  \n\n3. **FNK Apartments**  \n   - Sea views, 9.6/10 rating  \n\n💰 *Budget Breakdown:*  \n- Flights: €154  \n- Hotel (3 nights): €171-250  \n- Remaining: €1,600+ for meals/activities  \n\n*Note:* All hotels are &lt;5 mins from beaches. Crete averages 25°C in May (Source: TravelSupermarket).\n</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">5번의 반복 후 휴가 검색 작업 결과</span></p></figcaption></figure><p>그 답변은 그럴듯해 보입니다. 하지만 정말 그럴까요? 결국 모델은 환각을 일으키는 것으로 알려져 있고, 여러 부분이 움직이는 시스템에서는 뭔가 잘못될 가능성이 높습니다. R1의 출력에서 몇 가지 세부 사항을 확인해 보겠습니다:</p><h3 id=\"destination-and-total-budget\">목적지 및 총 예산</h3><p>각 항목의 계산이 모두 맞습니다(각 항목이 정확한지는 아래에서 살펴보겠습니다). 결국 R1은 수학 문제로 훈련을 받았습니다. 목적지도 맞습니다. 크레타는 인기 있는 관광지입니다.</p><h3 id=\"flights\">항공편</h3><p>항공권 가격이 거의 맞지만, 어디서 잘못되었는지 살펴보겠습니다. 우선, 2025년 5월 프랑크푸르트에서 헤라클리온까지 왕복 항공권의 실제 Skyscanner 가격입니다:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2025/03/image-25.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"2384\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2025/03/image-25.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2025/03/image-25.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2025/03/image-25.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2025/03/image-25.png 2048w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">2025년 5월 프랑크푸르트-헤라클리온 항공편에 대한 실제 Skyscanner 검색 결과</span></figcaption></figure><p>가격이 모두 200 EUR 정도이며, 약속된 154 EUR 왕복이 아닙니다! 그러나 이 오류는 어디서 발생했을까요? 로그를 보면 3라운드에서 관련 메모리 블록이 추가된 것을 확인할 수 있습니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-json\">{\"operation\": \"add\", \"content\": \"Crete flight options: Eurowings €89.99* one-way ...\"}</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">독일-크레타 항공편 관련 메모리 블록</span></p></figcaption></figure><p>이 블록은 첨부된 검색 결과에서 유추된 것으로 보입니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">Source 1️: search: Cheapest flights from Germany to Crete May 2025\nResult:\n```\n... other results ...\nTitle: Are you a person or a robot?\nURL Source: https://www.skyscanner.com/routes/fran/her/frankfurt-to-crete-heraklion.html\nDescription: Book a one-way ticket from Frankfurt to Heraklion Airport from $78 or travel \nreturn from just $154. The prices shown are based on availability and could change ...\n```</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">독일-크레타 항공편 검색 결과</span></p></figcaption></figure><p>모델은 이 웹페이지를 스크랩하여 결과를 확인하려 하지 않았지만, 그래도 큰 차이는 없었을 것입니다. 하지만 적어도 검색 결과에 \"5월\"이라는 기간이 포함되지 않았다는 것을 알아차렸어야 했습니다.</p><h3 id=\"hotel\">호텔</h3><p>호텔은 확인됐지만, 개선할 수 있는 사항들을 확인했습니다. 첫째로, 모델이 Georgioupolis Beach Hotel과 FNK Apartments의 가격을 찾는 데 더 많은 노력을 기울였으면 좋았을 것 같습니다 - 다른 정보는 제공하지만 가격이 안타깝게도 누락되어 있습니다. 무슨 말인지 이해하려면, 호텔 추천을 생성하는 데 사용된 <a href=\"https://www.booking.com/region/gr/crete.html\">URL</a>의 원시 출력을 보면 됩니다. 처음과 마지막 결과의 가격만 표시되고 중간 세 개는 건너뛰었습니다:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-markdown\">출처 3️: 스크랩: https://www.booking.com/region/gr/crete.html\n결과:\n```\n더 보기 접기\n\nMoritz 독일\n\n*   ### [JT Apartments](https://www.booking.com/hotel/gr/jt-apatments.html?label=gen173nr-1FCAYoXEIFY3JldGVIM1gEaJUCiAEBmAExuAEZyAEM2AEB6AEB-AECiAIBqAIDuALSvqC-BsACAdICJDc5ZWE5ZDJkLTI2ZWEtNGNiMS04MzNlLTJhNWIyMGI5Y2M3NdgCBeACAQ&amp;sid=f21cdd5fe9eb08dcac7d3a0304f9ccc9)\n\n키사모스\n\n1박당 $57부터\n\n9.5 최고 313개 후기\n\nJT Apartments에 머무시는 것을 강력히 추천합니다. 아파트에 들어섰을 때 pleasant한 surprise가 기다리고 있었습니다. 모든 것이 잘 구비되어 있었습니다. 주변은 조용하고 근처에 슈퍼마켓이 있습니다. 해변까지는 걸어서 금방입니다. 크레타의 가장 아름다운 해변들을 방문하고 싶으시다면 최고의 위치입니다. 덕분에 우리의 체류는 꿈꾸던 그대로였습니다 :)\n\n더 보기 접기\n\nKatarzyna 폴란드\n더 보기 접기\n\nAitor 독일\n\n*   ### [FNK Apartments with Sea View](https://www.booking.com/hotel/gr/f-amp-k-apartments.html?label=gen173nr-1FCAYoXEIFY3JldGVIM1gEaJUCiAEBmAExuAEZyAEM2AEB6AEB-AECiAIBqAIDuALSvqC-BsACAdICJDc5ZWE5ZDJkLTI2ZWEtNGNiMS04MzNlLTJhNWIyMGI5Y2M3NdgCBeACAQ&amp;sid=f21cdd5fe9eb08dcac7d3a0304f9ccc9)\n\n아기아 펠라기아\n\n9.6 최고 64개 후기\n\n우리는 크레타에서 일주일을 보냈습니다. 이 기간 동안 FnK Apartments에 머물렀습니다. Froso와 Konstantinos는 매우 친절하고 훌륭한 호스트였습니다. 질문이나 요구사항이 있을 때마다 항상 도와줄 준비가 되어 있었습니다. 아파트 자체는 아기아 펠라기아와 주변 만의 아름다운 전망을 가지고 있습니다(아름다운 일출도 볼 수 있습니다). FnK Apartments를 적극 추천합니다!!\n\n더 보기 접기\n\nMoritz 독일\n더 보기 접기\n\nmary 미국\n\n*   ### [Artemis Hotel Apartments](https://www.booking.com/hotel/gr/artemis-hersonisos.html?label=gen173nr-1FCAYoXEIFY3JldGVIM1gEaJUCiAEBmAExuAEZyAEM2AEB6AEB-AECiAIBqAIDuALSvqC-BsACAdICJDc5ZWE5ZDJkLTI2ZWEtNGNiMS04MzNlLTJhNWIyMGI5Y2M3NdgCBeACAQ&amp;sid=f21cdd5fe9eb08dcac7d3a0304f9ccc9)\n\n리메나스 헤르소니소스, 헤르소니소스\n\n9.0 훌륭함 419개 후기\n\n환영받는 느낌을 받고, 친구처럼 대우받고, 모든 면에서 도움을 받고 싶다면 이 호텔에 머무시는 것을 강력히 추천합니다. 따뜻하고 매우 개인적인 대우를 해주신 Konstantine께 진심으로 감사드립니다! 다음 크레타 방문 때도 Artemis Hotel에 다시 머물고 싶습니다!\n\n더 보기 접기\n\nIrina 이스라엘\n더 보기 접기\n\nAnn Marie 아일랜드\n\n*   ### [Pinelopi Hotel](https://www.booking.com/hotel/gr/pinelopi.html?label=gen173nr-1FCAYoXEIFY3JldGVIM1gEaJUCiAEBmAExuAEZyAEM2AEB6AEB-AECiAIBqAIDuALSvqC-BsACAdICJDc5ZWE5ZDJkLTI2ZWEtNGNiMS04MzNlLTJhNWIyMGI5Y2M3NdgCBeACAQ&amp;sid=f21cdd5fe9eb08dcac7d3a0304f9ccc9)\n\n플라타네스\n\n7.8 좋음 198개 후기\n\n해변과 가까운 훌륭한 위치, 좋은 타베르나들이 있고 차로 여행하기에도 좋은 위치입니다. 조용한 지역으로 완벽한 휴가를 보내기에 좋습니다. 필요한 모든 것이 갖춰진 넓은 객실. 가격 대비 가치가 훌륭합니다. 수영장 area가 훌륭했고 하루 중 언제든 휴식을 취할 수 있었습니다. 호텔 근처 주차장이 완벽했습니다. 다음에 크레타를 방문할 때도 Pinelopi Hotel에 다시 머물 것입니다.\n\n더 보기 접기\n\nRita 루마니아\n더 보기 접기\n\nKatarzyna 폴란드\n\n*   ### [Elizabeth Suites](https://www.booking.com/hotel/gr/elizabeth-suites.html?label=gen173nr-1FCAYoXEIFY3JldGVIM1gEaJUCiAEBmAExuAEZyAEM2AEB6AEB-AECiAIBqAIDuALSvqC-BsACAdICJDc5ZWE5ZDJkLTI2ZWEtNGNiMS04MzNlLTJhNWIyMGI5Y2M3NdgCBeACAQ&amp;sid=f21cdd5fe9eb08dcac7d3a0304f9ccc9)\n\n카토 다라초\n\n1박당 $74부터\n\n9.1 훌륭함 86개 후기\n\n우리는 훌륭한 숙박을 했는데, 특히 항상 미소를 지으며 매우 도움이 되었던 주인 Epas와 특히 Anna와 같은 직원들 덕분에 더욱 개인적인 경험이 되었습니다. 아침식사를 몇 번 했는데 매우 풍성했습니다. 아파트는 해변과 레스토랑을 가기에 완벽한 위치에 있었습니다. Elizabeth Suites를 강력히 추천합니다. 크레타에서의 첫 휴가를 완벽하게 만들어주었습니다 😊\n\n더 보기 접기\n\nJean 영국\n```</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">booking.com의 크레타 호텔 리스트 원본 스크랩 결과</span></p></figcaption></figure><p>둘째로, Reranker를 사전 정의된 <code>top_n</code> 5개 결과와 함께 사용하면서 추가적인 문제를 발견했습니다 — 스크랩된 페이지에 5개 이상의 관련 결과가 포함되어 있었다는 것입니다. 단순히 상위 5개(또는 임의의 수)의 결과를 가져오는 대신 각 결과의 관련성 점수를 실제로 확인함으로써 이 문제를 해결할 수 있었습니다. 하지만 이상적인 재순위 구성은 작업마다 다릅니다. 이 문제를 해결하는 더 나은 방법은 스크랩된 페이지 전체를 사용하는 것이었을 것입니다 - 하지만 안타깝게도 R1의 제한된 컨텍스트 길이 때문에 이것이 불가능했습니다.</p><h3 id=\"overall-performance-and-potential-improvements\">전반적인 성능과 잠재적 개선사항</h3><p>모델은 처음에는 잘 시작했지만, 특별히 프롬프트를 주지 않는 한 전략을 전환하거나 복잡한 계획을 세우려 하지 않는 것을 발견했습니다. R1은 수학과 코딩 문제(특별히 훈련된 영역)에서는 자연스럽게 이러한 접근 방식을 사용하지만, 검색 작업에는 동일한 추론을 적용하지 않습니다. 이러한 한계를 해결하기 위해 프롬프트를 더 미세 조정하거나 (또는 여러 프롬프트를 사용할 수도 있었지만), 그것은 우리의 주요 목표가 아니었습니다.</p><p>또한 R1이 시간에 민감한 정보를 적절히 처리하지 못한다는 것을 관찰했습니다. 간단히 말해서, 검색 결과에 잘못된 날짜가 명시적으로 언급되지 않으면 모델은 추가 확인 없이 정보가 유효하다고 가정합니다. 예를 들어, 5월 1일 항공편을 계획할 때:</p><ul><li>독일에서 크레타까지 5월 1일 $80: <strong>정확함</strong> - 모델이 이 정보를 신뢰할 수 있습니다.</li><li>독일에서 크레타까지 1월 1일 $80: <strong>부정확함</strong> - 모델이 적절히 식별하고 폐기합니다.</li><li>독일에서 크레타까지 $80: <strong>거짓 양성</strong> - 날짜가 명시되지 않았을 때, 모델은 정보를 확인하지 않고 잘못된 유효성을 가정합니다.</li></ul><p>이 프로젝트를 계속 진행한다면, 다음과 같은 잠재적 개선사항을 고려해볼 수 있습니다:</p><ul><li>메모리 블록 수를 추적하고 상태가 너무 커질 때 모델에게 <strong>항목을 요약</strong>하도록 프롬프트하기.</li><li>탐색을 마치고 쿼리에 응답하기 전에 모델에게 <strong>모든 실마리를 소진</strong>하도록 지시하기.</li><li><strong>시간에 민감한 정보의 확인</strong>을 강조하기.</li><li>검색 도구가 반환한 URL들을 스크랩하여 모델이 <strong>결과를 이중 확인</strong>하도록 하기.</li><li>프롬프트를 다른 모델에 맞게 상당한 리팩토링과 테스트가 필요하겠지만, <strong>더 큰 컨텍스트 윈도우를 지원하는 미래의 추론 모델</strong>로 우리 시스템을 테스트하기.</li></ul><h2 id=\"conclusion\">결론</h2><p>R1이 최근에 출시된 이후로도 상황은 크게 변화했습니다. 매우 저렴한 비용—일부는 $5 정도—으로 추론 모델을 훈련시키는 프로젝트들이 등장했습니다. 이러한 민주화는 전문화된 모델을 훈련시키는 것이 그 어느 때보다 접근하기 쉽다는 것을 의미합니다. R1과의 실험은 추론 중심 LLM이 복잡한 검색 작업을 해결하기 위해 도구들과 함께 어떻게 향상될 수 있는지 계속 탐구해 나가는 데 유용한 기준선을 제공합니다.</p><p>우리의 휴가 계획 예시는 유망한 결과를 보여주었지만(특히 빠른 데모 프로젝트로서는), 수학과 코딩에서의 강점에 비해 검색과 메모리 작업을 처리하는 데 있어 R1의 한계도 드러냈습니다. 시스템이 예산 제약 내에서 성공적으로 여행 계획을 수립했지만, 시간에 민감한 정보 확인이나 사용 가능한 모든 옵션을 철저히 탐색하는 등의 영역에서는 부족함을 보였으며, 이는 모델의 훈련 중점과 다른 도메인에 적용하는 것 사이의 격차를 강조합니다.</p>",
  "comment_id": "67dd5037143bda0001036423",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2025/04/Heading--92-.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2025-03-21T12:40:39.000+01:00",
  "updated_at": "2025-04-01T09:38:45.000+02:00",
  "published_at": "2025-04-01T09:38:45.000+02:00",
  "custom_excerpt": "Standard LLM or reasoning model, which is better for DeepSearch? In this post, we explored using DeepSeek-R1 in the DeepSearch implementation for choosing the next action.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "64ae64a4733bc60001949ca4",
      "name": "Andrei Ungureanu",
      "slug": "andrei",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2023/07/Me.jpg",
      "cover_image": null,
      "bio": "Software / AI Engineer, with a passion for content creation.",
      "website": null,
      "location": "Beijing, China",
      "facebook": null,
      "twitter": null,
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/andrei/"
    },
    {
      "id": "632ade4a3e4e55003d525971",
      "name": "Alex C-G",
      "slug": "alexcg",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/09/alex.jpg",
      "cover_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/11/twitter_banner.jpg",
      "bio": "Open-source Evangelist @ Jina AI. Old, grim, and full of Vim",
      "website": null,
      "location": "Berlin, Germany",
      "facebook": null,
      "twitter": "@alexcg",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/alexcg/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "64ae64a4733bc60001949ca4",
    "name": "Andrei Ungureanu",
    "slug": "andrei",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2023/07/Me.jpg",
    "cover_image": null,
    "bio": "Software / AI Engineer, with a passion for content creation.",
    "website": null,
    "location": "Beijing, China",
    "facebook": null,
    "twitter": null,
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/andrei/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/using-deepseek-r1-reasoning-model-in-deepsearch/",
  "excerpt": "일반 LLM과 추론 모델 중 DeepSearch에 어떤 것이 더 나을까요? 이 글에서는 다음 행동을 선택하기 위한 DeepSearch 구현에서 DeepSeek-R1을 사용하는 것을 탐구해보았습니다.",
  "reading_time": 17,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": null,
  "feature_image_caption": null
}