{
  "slug": "can-embedding-reranker-models-compare-numbers",
  "id": "66a15523ac62ce0001aa02c8",
  "uuid": "7e5e7622-20e9-4060-9b1d-8a3b4e2588ba",
  "title": "임베딩/리랭커 모델은 숫자를 비교할 수 있을까?",
  "html": "<p>이것은 오늘 비엔나의 ICML 학회에서 받은 질문이었습니다.</p><p>커피 브레이크 시간에 한 Jina 사용자가 최근 LLM 커뮤니티에서 나온 논의와 관련된 질문을 했습니다. 그는 우리의 임베딩 모델이 9.11이 9.9보다 <em>작다는</em> 것을 알 수 있는지 물었는데, 이는 많은 LLM이 반대로 판단하는 과제입니다.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">9.11 is bigger than 9.9. <a href=\"https://t.co/zBrdLGAoH2?ref=jina-ai-gmbh.ghost.io\">pic.twitter.com/zBrdLGAoH2</a></p>— Riley Goodside (@goodside) <a href=\"https://twitter.com/goodside/status/1812977352085020680?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">July 15, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><p>\"솔직히 모르겠네요\"라고 답했습니다. 그가 자신의 애플리케이션에서 이 기능의 중요성을 설명하고 <strong>토큰화가 문제의 근원일 수 있다</strong>고 제안했을 때, 저는 동의하며 고개를 끄덕였습니다 - 이미 답을 찾기 위한 실험 아이디어가 머릿속에서 떠오르고 있었죠.</p><p>이 글에서는 우리의 임베딩 모델인 <code>jina-embeddings-v2-base-en</code> (2023년 10월 출시)과 Reranker 모델인 <code>jina-reranker-v2-multilingual</code> (2024년 6월 출시)이 숫자를 정확하게 비교할 수 있는지 테스트해보고자 합니다. 9.11과 9.9의 단순 비교를 넘어서, 작은 정수, 큰 수, 소수점, 음수, 통화, 날짜, 시간 등 다양한 유형의 숫자를 포함하는 실험을 설계했습니다. 목표는 우리 모델이 다양한 숫자 형식을 처리하는 효과를 평가하는 것입니다.</p><h2 id=\"experimental-setup\">실험 설정</h2><p>전체 구현은 아래 Colab에서 확인할 수 있습니다:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/11kUxYhHMLqYhw5HVKEYdHv0EfdZIyBBy?ref=jina-ai-gmbh.ghost.io#scrollTo=G7Cy9zSb2Ukg\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://ssl.gstatic.com/colaboratory-static/common/7f9df66b1941b18be03f2115a7ab9255/img/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://colab.research.google.com/img/colab_favicon_256px.png\" alt=\"\"></div></a></figure><p>실험 설계는 매우 간단합니다. 예를 들어, 임베딩 모델이 [1, 100] 사이의 숫자를 이해하는지 확인하기 위한 단계는 다음과 같습니다:</p><ol><li><strong>문서 구성</strong>: <code>1</code>부터 <code>100</code>까지 각 숫자에 대한 \"문자열 리터럴\" 문서를 생성합니다.</li><li><strong>임베딩 API로 전송</strong>: <a href=\"https://jina.ai/embeddings?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">임베딩 API</a>를 사용하여 각 문서의 임베딩을 얻습니다.</li><li><strong>코사인 유사도 계산</strong>: 모든 두 문서 쌍의 코사인 유사도를 계산하여 유사도 행렬을 만듭니다.</li><li><strong>산점도 작성</strong>: 결과를 산점도로 시각화합니다. 유사도 행렬의 각 요소 $(i, j)$는 다음과 같이 매핑됩니다: X축: $(i - j)$; Y축: $(i, j)$의 유사도 값</li></ol><p>델타 $(i - j)$가 0이면, 즉 $i = j$이면 의미적 유사도가 가장 높아야 합니다. 델타 $(i - j)$가 증가할수록 유사도는 감소해야 합니다. <strong>이상적으로는 유사도가 델타 값에 선형적으로 비례해야 합니다.</strong> 이러한 선형성이 관찰되지 않는다면, 모델이 숫자를 이해하지 못해 9.11이 9.9보다 크다와 같은 오류를 발생시킬 수 있습니다.</p><p>Reranker 모델도 비슷한 절차를 따릅니다. 주요 차이점은 구성된 문서들을 반복하며 각각을 <code>query</code>로 설정하고 <code>\"what is the closest item to...\"</code>라는 프롬프트를 앞에 붙이고 나머지를 <code>documents</code>로 랭킹하는 것입니다. <a href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">Reranker API</a>가 반환하는 관련성 점수를 의미적 유사도 측정값으로 직접 사용합니다. 핵심 구현은 다음과 같습니다.</p><pre><code class=\"language-python\">def rerank_documents(documents):\n    reranker_url = \"https://api.jina.ai/v1/rerank\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Initialize similarity matrix\n    similarity_matrix = np.zeros((len(documents), len(documents)))\n\n    for idx, d in enumerate(documents):\n        payload = {\n            \"model\": \"jina-reranker-v2-base-multilingual\",\n            \"query\": f\"what is the closest item to {d}?\",\n            \"top_n\": len(documents),\n            \"documents\": documents\n        }\n    ...</code></pre><h2 id=\"can-models-compare-numbers-between-1-2-3-100\">모델이 [1, 2, 3, ..., 100] 사이의 숫자를 비교할 수 있을까요?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--0-100-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--0-100---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">각 델타에 대한 평균과 분산을 보여주는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i) for i in range(1, 101)]</span></code></p></figcaption></figure><h3 id=\"how-to-read-these-plots\">이 그래프를 읽는 방법</h3><p>더 많은 실험으로 넘어가기 전에, 먼저 이 그래프들을 제대로 읽는 방법을 설명하겠습니다. 우선, 위의 두 그래프에서 관찰한 바로는 임베딩 모델은 잘 수행되지만, reranker 모델은 그만큼 좋지 않은 성능을 보입니다. 그럼 우리가 무엇을 보고 있고 왜 그런 것일까요?</p><p>X축은 문서 집합에서 균일하게 샘플링된 $d_i$와 $d_j$의 인덱스 $(i,j)$ 또는 $i-j$의 델타를 나타냅니다. 이 델타는 $[-100, 100]$ 범위입니다. 우리의 문서 집합은 구성상 정렬되어 있기 때문에, $|i-j|$가 작을수록 $d_i$와 $d_j$는 의미적으로 더 가깝고, $i$와 $j$가 멀어질수록 $d_i$와 $d_j$ 사이의 유사도는 낮아집니다. 그래서 유사도(Y축으로 표현)가 $X=0$에서 피크를 보이고 좌우로 이동할수록 선형적으로 감소하는 것을 볼 수 있습니다.</p><p>이상적으로는 이것이 날카로운 피크나 <code>^</code>와 같은 \"위쪽 화살표\" 모양을 만들어야 합니다. 하지만 항상 그런 것은 아닙니다. X축의 한 지점, 예를 들어 $X=25$를 고정하고 Y축을 따라 보면, 0.80에서 0.95 사이의 유사도 값을 찾을 수 있습니다. 이는 델타가 모두 25임에도 불구하고 $\\mathrm{sim}(d_27, d_2)$는 0.81일 수 있고 $\\mathrm{sim}(d_42, d_17)$는 0.91일 수 있다는 것을 의미합니다.</p><p>청록색 추세선은 각 X값에서의 평균 유사도와 표준편차를 보여줍니다. 또한 우리의 문서 집합이 균등하게 간격을 두고 있어 연속된 문서 사이에 동일한 간격이 보장되므로 유사도는 선형적으로 감소해야 합니다.</p><p>임베딩 그래프는 <strong>항상 대칭이며, $X=0$에서 가장 큰 Y값인 1.0</strong>을 가진다는 점에 유의하세요. 이는 코사인 유사도가 $d_i$와 $d_j$에 대해 대칭이고 $\\cos(0)=1$이기 때문입니다.</p><p>반면에 reranker 그래프는 쿼리와 문서가 reranker 모델에서 서로 다른 역할을 하기 때문에 <strong>항상 비대칭</strong>입니다. <strong>최대값이 1.0이 아닐 수 있습니다</strong>. 왜냐하면 $X=0$은 reranker를 사용하여 <code>\"what is the closest item to 4\"</code>와 <code>\"4\"</code>의 관련성 점수를 계산한다는 의미이기 때문입니다. 생각해보면, $X=0$이 최대 Y값으로 이어진다는 보장이 없습니다.</p><h2 id=\"can-models-compare-negative-numbers-between10099981\">모델이 [-100, -99, -98, ..., -1] 사이의 음수를 비교할 수 있을까요?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in---100--1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in---100--1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">각 델타에 대한 평균과 분산을 보여주는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">. 여기서는 모델이 음수 공간에서 의미적 유사도를 판단할 수 있는지 테스트하고자 합니다. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(-i) for i in range(1, 101)]</span></code></p></figcaption></figure><h2 id=\"can-models-compare-numbers-with-larger-intervals-1000-2000-3000-100000\">모델이 더 큰 간격의 숫자 [1000, 2000, 3000, ..., 100000]를 비교할 수 있을까요?</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--1000-100000-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--1000-100000---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> 여기서는 1000 단위로 간격이 있는 숫자들을 비교할 때 모델이 의미적 유사성을 파악할 수 있는지 테스트하고자 합니다. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i*1000) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> 각 델타에 대한 평균과 분산을 나타내는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-numbers-from-an-arbitrary-range-eg-376-377-378-476\">모델이 임의의 범위의 숫자를 비교할 수 있나요? 예: [376, 377, 378, ..., 476]</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--376-476-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--376-476---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> 여기서는 임의의 범위에서 숫자를 비교할 때 모델이 의미적 유사성을 파악할 수 있는지 테스트하기 위해 임의의 범위로 숫자를 이동시켰습니다 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i+375) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> . 각 델타에 대한 평균과 분산을 나타내는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-large-numbers-between-4294967296-4294967297-4294967298-4294967396\">모델이 큰 숫자를 비교할 수 있나요? [4294967296, 4294967297, 4294967298, ..., 4294967396]</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--4294967296-4294967396---1-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--4294967296-4294967396-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> 여기서는 매우 큰 숫자를 비교할 때 모델이 의미적 유사성을 파악할 수 있는지 테스트하고자 합니다. 이전 실험과 유사한 아이디어로 범위를 더 큰 숫자로 이동시켰습니다. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i+4294967296) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> 각 델타에 대한 평균과 분산을 나타내는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-float-numbers-between-00001-00002-00003-01-wo-fixed-digits\">모델이 소수를 비교할 수 있나요? [0.0001, 0.0002, 0.0003, ...,0.1] (고정 자릿수 없이)</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in--0.0001-0.01-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in--0.0001-0.01-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> 여기서는 소수를 비교할 때 모델이 의미적 유사성을 파악할 수 있는지 테스트하고자 합니다. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i/1000) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> 각 델타에 대한 평균과 분산을 나타내는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-currency-numbers-between-1-2-3-100\">모델이 화폐 단위의 숫자를 비교할 수 있나요? [$1, $2, $3, ..., $100]</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-numbers-in---1---100-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-numbers-in---1---100-.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> 여기서는 화폐 단위의 숫자를 비교할 때 모델이 의미적 유사성을 파악할 수 있는지 테스트하고자 합니다. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = ['$'+str(i) for i in range(1, 101)]</span></code><span style=\"white-space: pre-wrap;\"> 각 델타에 대한 평균과 분산을 나타내는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-date-between-2024-07-24-2024-07-25-2024-07-26-2024-10-31\">모델이 날짜를 비교할 수 있나요? [2024-07-24, 2024-07-25, 2024-07-26, ..., 2024-10-31]</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-date-between-2024-07-24-and-2024-10-31.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-date-between-2024-07-24-and-2024-10-31.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\"> 여기서는 YYYY-MM-DD 형식의 날짜를 비교할 때 모델이 의미적 유사성을 파악할 수 있는지 테스트하고자 합니다. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>today = datetime.today(); documents = [(today + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(100)]</span></code><span style=\"white-space: pre-wrap;\"> 각 델타에 대한 평균과 분산을 나타내는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"can-models-compare-time-between-190007-190008-190009-203907\">모델이 시간을 비교할 수 있나요? [19:00:07, 19:00:08, 19:00:09,..., 20:39:07]</h2><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Delta-of-a-pair-of-date-between-19_00_07-and-20_39_07.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Delta-of-a-pair-of-time-between-19_00_07-and-20_39_07.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">여기서는 모델이 시간 형식의 숫자를 비교할 때 의미적 유사성을 파악할 수 있는지 테스트하고자 합니다. 즉, </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>hh:mm:ss</span></code><span style=\"white-space: pre-wrap;\">. </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>now = datetime.now(); documents = [(now + timedelta(minutes=i)).strftime('%H:%M:%S') for i in range(100)]</span></code><span style=\"white-space: pre-wrap;\"> 각 델타에 대한 평균과 분산이 있는 산점도. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"observations\">관찰 결과</h2><p>위 그래프에서 관찰된 내용은 다음과 같습니다:</p><h3 id=\"reranker-models\"><strong>리랭커 모델</strong></h3><ul><li>리랭커 모델은 숫자 비교에 어려움을 겪습니다. [1, 100] 사이의 숫자를 비교하는 가장 단순한 경우에도 성능이 좋지 않습니다.</li><li>리랭커 사용 시 쿼리에 사용된 특별한 프롬프트 구성(<code>what is the closest item to x</code>)이 결과에 영향을 미칠 수 있다는 점에 주목해야 합니다.</li></ul><h3 id=\"embedding-models\"><strong>임베딩 모델</strong></h3><ul><li>임베딩 모델은 [1, 100] 범위 내의 작은 정수나 [-100, 1] 범위 내의 음수를 비교할 때 비교적 잘 수행됩니다. 하지만 이 범위를 다른 값으로 이동하거나, 더 많은 구간을 추가하거나, 더 크거나 작은 부동소수점을 다룰 때는 성능이 크게 저하됩니다.</li><li>일반적으로 10단계마다 주기적인 스파이크가 관찰됩니다. 이는 토크나이저가 문자열을 \"10\" 또는 \"1\"과 \"0\"으로 토큰화하는 방식과 관련이 있을 수 있습니다.</li></ul><h3 id=\"date-and-time-understanding\"><strong>날짜와 시간 이해</strong></h3><ul><li>흥미롭게도 임베딩 모델은 대부분의 경우 날짜와 시간을 올바르게 비교하며 잘 이해하는 것으로 보입니다. 날짜 그래프에서는 30/31단계마다 스파이크가 나타나는데, 이는 한 달의 일수와 일치합니다. 시간 그래프에서는 60단계마다 스파이크가 나타나는데, 이는 한 시간의 분 단위와 일치합니다.</li><li>리랭커 모델도 어느 정도 이러한 이해를 보여줍니다.</li></ul><h3 id=\"visualizing-similarity-to-zero\">\"제로\"와의 유사성 시각화</h3><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-text\">2024년 7월 29일 업데이트</div></div><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/1S9qZQ0jjdKLNUT2GKqPbU4ogpDe6g9Qh?ref=jina-ai-gmbh.ghost.io#scrollTo=nvAX2GOpCiRt\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://ssl.gstatic.com/colaboratory-static/common/00df39d73993c0a4c5694ba86c20cc85/img/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://colab.research.google.com/img/colab_favicon_256px.png\" alt=\"\"></div></a></figure><p>또 다른 흥미로운 실험은 아마도 더 직관적일 수 있는데, 모든 숫자와 0(즉, 원점) 사이의 유사성 또는 관련성 점수를 직접 시각화하는 것입니다. 0의 임베딩을 기준점으로 고정하고, 숫자가 커질수록 의미적 유사성이 선형적으로 감소하는지 보고자 합니다. 리랭커의 경우, 쿼리를 <code>\"0\"</code> 또는 <code>\"What is the closest number to number zero?\"</code>로 고정하고 모든 숫자를 순위화하여 숫자가 증가할수록 관련성 점수가 감소하는지 확인할 수 있습니다. 결과는 아래와 같습니다:</p><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/e-Embedding-representation.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/r-Rerank-Documents.svg\" width=\"960\" height=\"960\" loading=\"lazy\" alt=\"\"></div></div></div><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">\"원점 임베딩\"을 \"제로\"의 임베딩으로 고정하고 모든 숫자와 제로 사이의 의미적 유사성이 숫자의 값에 비례하는지 확인합니다. 구체적으로 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>documents = [str(i) for i in range(2048)]</span></code><span style=\"white-space: pre-wrap;\">를 사용합니다. 각 델타에 대한 평균과 분산이 있는 산점도가 표시됩니다. 왼쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-base-en</span></code><span style=\"white-space: pre-wrap;\">; 오른쪽: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-reranker-v2-multilingual</span></code><span style=\"white-space: pre-wrap;\">.</span></p></figcaption></figure><h2 id=\"conclusion\">결론</h2><p>이 글은 현재 임베딩 및 리랭커 모델이 숫자 비교를 어떻게 처리하는지 보여줍니다. 비교적 단순한 실험 설정에도 불구하고, 현재 모델의 일부 근본적인 결함을 드러내며 다음 임베딩과 리랭커 개발에 귀중한 통찰을 제공합니다.</p><p>모델이 숫자를 정확하게 비교할 수 있는지 여부를 결정하는 두 가지 주요 요소가 있습니다: </p><p><strong>첫째, 토큰화:</strong> 어휘가 0-9 숫자만 포함하는 경우, 11은 개별 토큰 1과 1로 토큰화되거나 단일 토큰 11로 토큰화될 수 있습니다. 이러한 선택은 모델의 수치 값 이해에 영향을 미칩니다.</p><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-10.jpg\" width=\"1520\" height=\"1430\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/07/Untitled-10.jpg 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/07/Untitled-10.jpg 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-10.jpg 1520w\" sizes=\"(min-width: 720px) 720px\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-1234.jpg\" width=\"1502\" height=\"1420\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/07/Untitled-1234.jpg 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/07/Untitled-1234.jpg 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/07/Untitled-1234.jpg 1502w\" sizes=\"(min-width: 720px) 720px\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">서로 다른 토크나이저는 9.11을 다르게 해석합니다. 이는 문맥적 학습에 영향을 미칠 수 있습니다. 출처: </span><a href=\"https://huggingface.co/spaces/Xenova/the-tokenizer-playground?ref=jina-ai-gmbh.ghost.io\"><span style=\"white-space: pre-wrap;\">The Tokenizer Playground on HuggingFace.</span></a></p></figcaption></figure><p><strong>둘째, 학습 데이터:</strong> 학습 코퍼스는 모델의 수치 추론 능력에 큰 영향을 미칩니다. 예를 들어, 학습 데이터가 주로 시맨틱 버저닝이 일반적인 소프트웨어 문서나 GitHub 저장소를 포함하는 경우, 모델은 9.9 다음에 마이너 버전인 9.11이 오므로 9.11이 9.9보다 크다고 해석할 수 있습니다.</p><p>임베딩과 리랭커와 같은 밀집 검색 모델의 산술 능력은 RAG와 고급 검색 및 추론 작업에 중요합니다. 강력한 수치 추론 능력은 특히 JSON과 같은 구조화된 데이터를 다룰 때 검색 품질을 크게 향상시킬 수 있습니다.</p>",
  "comment_id": "66a15523ac62ce0001aa02c8",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/07/number-heading.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-07-24T21:25:23.000+02:00",
  "updated_at": "2024-07-29T18:47:03.000+02:00",
  "published_at": "2024-07-25T00:42:49.000+02:00",
  "custom_excerpt": "A lot of LLMs can't figure out that 9.11 is actually smaller than 9.9. Can our embedding and reranker models do any better?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/can-embedding-reranker-models-compare-numbers/",
  "excerpt": "많은 LLM은 9.11이 실제로 9.9보다 작다는 것을 알아내지 못합니다. 우리의 임베딩과 리랭커 모델은 이것을 더 잘 처리할 수 있을까요?",
  "reading_time": 10,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Rows of numbered wooden pieces on a white background, ranging from single digits to high numbers.",
  "feature_image_caption": null
}