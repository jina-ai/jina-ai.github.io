{
  "slug": "what-is-colbert-and-late-interaction-and-why-they-matter-in-search",
  "id": "65d3a2134a32310001f5b71b",
  "uuid": "726c942b-f6a7-4c89-a0ad-39aaad98d02f",
  "title": "ColBERT와 Late Interaction이란 무엇이며 검색에서 왜 중요한가?",
  "html": "{{{input start}}}\n<figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/news/jina-colbert-v2-multilingual-late-interaction-retriever-for-embedding-and-reranking?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Jina ColBERT v2: 임베딩과 재순위화를 위한 다국어 후기 상호작용 검색기</div><div class=\"kg-bookmark-description\">Jina ColBERT v2는 89개 언어를 지원하며 우수한 검색 성능, 사용자 지정 출력 차원, 8192 토큰 길이를 제공합니다.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/08/colbert-banner.jpg\" alt=\"\"></div></a><figcaption><p dir=\"ltr\"><span style=\"white-space: pre-wrap;\">업데이트: 2024년 8월 31일, 향상된 성능, 89개 언어에 대한 다국어 지원 및 유연한 출력 차원을 갖춘 Jina-ColBERT의 2번째 버전을 출시했습니다. 자세한 내용은 출시 게시물을 확인하세요.</span></p></figcaption></figure><p>지난 금요일, <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">Hugging Face에서 Jina AI의 ColBERT 모델</a> 출시는 특히 Twitter/X에서 AI 커뮤니티 전반에 걸쳐 상당한 관심을 불러일으켰습니다. 많은 사람들이 혁신적인 BERT 모델에 익숙하지만, ColBERT에 대한 관심은 일부 사람들에게 의문을 남겼습니다: 정보 검색 기술 분야에서 ColBERT가 두드러지는 점은 무엇일까요? AI 커뮤니티가 8192 길이의 ColBERT에 대해 왜 흥분하고 있을까요? 이 글에서는 ColBERT와 ColBERTv2의 세부사항을 살펴보고, 그들의 설계, 개선사항, 그리고 ColBERT의 후기 상호작용의 놀라운 효과성을 조명합니다.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://jina.ai/reranker?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Reranker API</div><div class=\"kg-bookmark-description\">검색 관련성과 RAG 정확도를 쉽게 극대화하세요</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina.ai/icons/favicon-128x128.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina.ai/banner-reranker-api.png\" alt=\"\"></div></a></figure><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Introducing jina-colbert-v1-en. It takes late interactions &amp; token-level embeddings of ColBERTv2 and has better zero-shot performance on many tasks (in and out-of-domain). Now on <a href=\"https://twitter.com/huggingface?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">@huggingface</a> under Apache 2.0 licence<a href=\"https://t.co/snVGgI753H?ref=jina-ai-gmbh.ghost.io\">https://t.co/snVGgI753H</a></p>— Jina AI (@JinaAI_) <a href=\"https://twitter.com/JinaAI_/status/1758503072999907825?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">February 16, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><h2 id=\"what-is-colbert\">ColBERT란 무엇인가?</h2><p>\"ColBERT\"는 <strong>Co</strong>ntextualized <strong>L</strong>ate Interaction over <strong>BERT</strong>의 약자로, 스탠포드 대학교에서 시작된 모델로, BERT의 깊은 언어 이해력을 활용하면서 새로운 상호작용 메커니즘을 도입했습니다. \"후기 상호작용\"으로 알려진 이 메커니즘은 검색 프로세스의 최종 단계까지 쿼리와 문서를 별도로 처리함으로써 효율적이고 정확한 검색을 가능하게 합니다. 구체적으로 두 가지 버전의 모델이 있습니다:</p><ul><li><strong>ColBERT</strong>: 초기 모델은 <a href=\"https://x.com/lateinteraction?s=20&ref=jina-ai-gmbh.ghost.io\"><strong>Omar Khattab</strong></a><strong>와 Matei Zaharia</strong>의 작품으로, \"ColBERT: Efficient and Effective Passage Search via Contextualized Late Interaction over BERT\" 논문을 통해 정보 검색에 대한 새로운 접근 방식을 제시했습니다. 이 연구는 SIGIR 2020에서 발표되었습니다.</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2004.12832?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERT: Efficient and Effective Passage Search via Contextualized Late Interaction over BERT</div><div class=\"kg-bookmark-description\">Recent progress in Natural Language Understanding (NLU) is driving fast-paced advances in Information Retrieval (IR), largely owed to fine-tuning deep language models (LMs) for document ranking. While remarkably effective, the ranking models based on these LMs increase computational cost by orders of magnitude over prior approaches, particularly as they must feed each query-document pair through a massive neural network to compute a single relevance score. To tackle this, we present ColBERT, a novel ranking model that adapts deep LMs (in particular, BERT) for efficient retrieval. ColBERT introduces a late interaction architecture that independently encodes the query and the document using BERT and then employs a cheap yet powerful interaction step that models their fine-grained similarity. By delaying and yet retaining this fine-granular interaction, ColBERT can leverage the expressiveness of deep LMs while simultaneously gaining the ability to pre-compute document representations offline, considerably speeding up query processing. Beyond reducing the cost of re-ranking the documents retrieved by a traditional model, ColBERT's pruning-friendly interaction mechanism enables leveraging vector-similarity indexes for end-to-end retrieval directly from a large document collection. We extensively evaluate ColBERT using two recent passage search datasets. Results show that ColBERT's effectiveness is competitive with existing BERT-based models (and outperforms every non-BERT baseline), while executing two orders-of-magnitude faster and requiring four orders-of-magnitude fewer FLOPs per query.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Omar Khattab</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">\"후기 상호작용\"을 소개하는 원본 ColBERT 논문.</span></p></figcaption></figure><ul><li><strong>ColBERTv2</strong>: 기초 작업을 바탕으로, <strong>Omar Khattab</strong>는 <strong>Barlas Oguz, Matei Zaharia, Michael S. Bernstein</strong>과 협력하여 SIGIR 2021에서 \"ColBERTv2: Effective and Efficient Retrieval via Lightweight Late Interaction\"을 발표했습니다. ColBERT의 이 다음 반복 버전은 이전의 한계를 해결하고 <strong>노이즈 제거 감독</strong>과 <strong>잔차 압축</strong>과 같은 주요 개선사항을 도입하여 모델의 검색 효과성과 저장 효율성을 향상시켰습니다.</li></ul><figure class=\"kg-card kg-bookmark-card kg-card-hascaption\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2112.01488?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">ColBERTv2: Effective and Efficient Retrieval via Lightweight Late Interaction</div><div class=\"kg-bookmark-description\">Neural information retrieval (IR) has greatly advanced search and other knowledge-intensive language tasks. While many neural IR methods encode queries and documents into single-vector representations, late interaction models produce multi-vector representations at the granularity of each token and decompose relevance modeling into scalable token-level computations. This decomposition has been shown to make late interaction more effective, but it inflates the space footprint of these models by an order of magnitude. In this work, we introduce ColBERTv2, a retriever that couples an aggressive residual compression mechanism with a denoised supervision strategy to simultaneously improve the quality and space footprint of late interaction. We evaluate ColBERTv2 across a wide range of benchmarks, establishing state-of-the-art quality within and outside the training domain while reducing the space footprint of late interaction models by 6--10$\\times$.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://arxiv.org/static/browse/0.3.4/images/icons/apple-touch-icon.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Keshav Santhanam</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png\" alt=\"\"></div></a><figcaption><p><span style=\"white-space: pre-wrap;\">ColBERTv2는 훈련 데이터의 품질을 개선하고 공간 점유율을 줄이기 위해 노이즈 제거 감독과 잔차 압축을 추가했습니다.</span></p></figcaption></figure><h2 id=\"understand-colberts-design\">ColBERT의 설계 이해하기</h2><p>ColBERTv2의 아키텍처가 원래 ColBERT와 매우 유사하고, 주요 혁신이 훈련 기법과 압축 메커니즘을 중심으로 이루어졌기 때문에, 먼저 원래 ColBERT의 기초적인 측면을 살펴보겠습니다.</p><h3 id=\"what-is-late-interaction-in-colbert\">ColBERT의 후기 상호작용이란 무엇인가?</h3><p>\"상호작용\"은 쿼리와 문서의 표현을 비교하여 관련성을 평가하는 프로세스를 의미합니다.</p><p>\"<em>후기 상호작용</em>\"은 ColBERT의 핵심입니다. 이 용어는 쿼리와 문서 표현 간의 상호작용이 둘 다 독립적으로 인코딩된 후, 프로세스의 후반부에서 발생하는 모델의 아키텍처와 처리 전략에서 유래했습니다. 이는 쿼리와 문서 임베딩이 더 이른 단계, 일반적으로 모델에 의한 인코딩 전이나 도중에 상호작용하는 \"<em>조기 상호작용</em>\" 모델과 대조됩니다.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Interaction Type</th>\n<th>Models</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Early Interaction</td>\n<td>BERT, ANCE, DPR, Sentence-BERT, DRMM, KNRM, Conv-KNRM, etc.</td>\n</tr>\n<tr>\n<td>Late Interaction</td>\n<td>ColBERT, ColBERTv2</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>조기 상호작용은 모든 가능한 쿼리-문서 쌍을 고려해야 하므로 계산 복잡성을 증가시킬 수 있어 대규모 애플리케이션에는 덜 효율적입니다.</p><p>ColBERT와 같은 후기 상호작용 모델은 문서 표현의 사전 계산을 허용하고 마지막에 더 가벼운 상호작용 단계를 사용함으로써 효율성과 확장성을 최적화합니다. 이 설계 선택은 더 빠른 검색 시간과 감소된 계산 요구사항을 가능하게 하여 대규모 문서 컬렉션 처리에 더 적합하게 만듭니다.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/colbert-blog-interaction.svg\" class=\"kg-image\" alt=\"Diagram illustrating query-document similarity with models for no, partial, and late interaction, including language mode rep\" loading=\"lazy\" width=\"300\" height=\"143\"><figcaption><span style=\"white-space: pre-wrap;\">뉴럴 IR에서 질의-문서 상호작용 패러다임을 보여주는 도식도, 왼쪽에는 ColBERT의 후기 상호작용이 있음.</span></figcaption></figure><h3 id=\"no-interaction-cosine-similarity-of-document-and-query-embeddings\">상호작용 없음: 문서와 질의 임베딩의 코사인 유사도</h3><p>많은 실용적인 벡터 데이터베이스와 뉴럴 검색 솔루션들은 문서와 질의 임베딩 간의 빠른 코사인 유사도 매칭에 의존합니다. 단순성과 계산 효율성 측면에서 매력적이지만, \"상호작용 없음\" 또는 \"상호작용 기반이 아님\"이라고 불리는 이 방법은 질의와 문서 간의 일종의 상호작용을 포함하는 모델들과 비교했을 때 성능이 떨어지는 것으로 나타났습니다.</p><p>\"상호작용 없음\" 접근 방식의 핵심적인 한계는 질의와 문서 용어 사이의 복잡한 뉘앙스와 관계를 포착하지 못한다는 점입니다. 정보 검색은 본질적으로 질의 뒤의 의도와 문서 내의 내용을 이해하고 매칭하는 것입니다. 이 과정은 종종 관련된 용어들의 깊은 문맥적 이해를 필요로 하는데, 이는 문서와 질의에 대한 단일의 집계된 임베딩으로는 제공하기 어려운 것입니다.</p><h2 id=\"query-and-document-encoders-in-colbert\">ColBERT의 질의 및 문서 인코더</h2><p>ColBERT의 인코딩 전략은 언어의 깊은 문맥적 이해로 알려진 BERT 모델에 기반을 두고 있습니다. 이 모델은 질의나 문서의 각 토큰에 대해 밀집 벡터 표현을 생성하여, <strong>질의에 대한 문맥화된 임베딩 집합과 문서에 대한 임베딩 집합을 각각 생성합니다.</strong> 이는 후기 상호작용 단계에서 임베딩들의 세밀한 비교를 가능하게 합니다.</p><h3 id=\"query-encoder-of-colbert\">ColBERT의 질의 인코더</h3><p>토큰 ${q_1, q_2, ..., q_l}$를 가진 질의 $Q$에 대해, 과정은 $Q$를 BERT 기반 WordPiece 토큰으로 토큰화하고 특수 <code>[Q]</code> 토큰을 앞에 붙이는 것으로 시작됩니다. BERT의 <code>[CLS]</code> 토큰 바로 뒤에 위치하는 이 <code>[Q]</code> 토큰은 질의의 시작을 알립니다.</p><p>질의가 미리 정의된 토큰 수 $N_q$보다 짧으면 <code>[mask]</code> 토큰으로 $N_q$까지 패딩되고, 그렇지 않으면 처음 $N_q$ 토큰으로 잘립니다. 패딩된 시퀀스는 BERT를 통과한 후 CNN(합성곱 신경망)과 정규화를 거칩니다. 출력은 아래와 같이 $\\mathbf{E}_q$로 표시되는 임베딩 벡터 집합입니다:<br>$$\\mathbf{E}_q := \\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[Q]},q_0,q_1,\\ldots,q_l\\mathtt{[mask]},\\mathtt{[mask]},\\ldots,\\mathtt{[mask]}\\right)\\right)$$</p><h3 id=\"document-encoder-of-colbert\">ColBERT의 문서 인코더</h3><p>마찬가지로, 토큰 ${d_1, d_2, ..., d_n}$을 가진 문서 $D$에 대해, 문서의 시작을 나타내는 <code>[D]</code> 토큰이 앞에 붙습니다. 패딩이 필요 없는 이 시퀀스는 동일한 과정을 거쳐 아래와 같이 $\\mathbf{E}_d$로 표시되는 임베딩 벡터 집합이 됩니다:<br>$$\\mathbf{E}_d := \\mathrm{Filter}\\left(\\mathrm{Normalize}\\left(\\mathrm{BERT}\\left(\\mathtt{[D]},d_0,d_1,...,d_n\\right)\\right)\\right)$$</p><p>질의 패딩에 <code>[mask]</code> 토큰을 사용하는 것(논문에서 <strong>질의 증강</strong>이라고 명명됨)은 모든 질의에 대해 균일한 길이를 보장하여 배치 처리를 용이하게 합니다. <code>[Q]</code>와 <code>[D]</code> 토큰은 각각 질의와 문서의 시작을 명시적으로 표시하여 모델이 두 종류의 입력을 구분하는 데 도움을 줍니다.</p><h3 id=\"comparing-colbert-to-cross-encoders\">ColBERT와 교차 인코더 비교</h3><p>교차 인코더는 질의와 문서 쌍을 함께 처리하여 매우 정확하지만, 가능한 모든 쌍을 평가하는 데 필요한 계산 비용으로 인해 대규모 작업에는 덜 효율적입니다. 그들은 의미적 유사도 작업이나 상세한 내용 비교와 같이 문장 쌍의 정확한 점수 매기기가 필요한 특정 시나리오에서 뛰어납니다. 하지만 이 설계는 사전 계산된 임베딩과 효율적인 유사도 계산이 중요한 대규모 데이터셋에서의 빠른 검색이 필요한 상황에서는 적용 가능성이 제한됩니다.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/02/ce-vs-colbert.svg\" class=\"kg-image\" alt=\"Diagrams comparing &quot;Cross Encoder: Early all-to-all interaction&quot; and &quot;ColBERT: Late interaction&quot; with labeled Query and Docum\" loading=\"lazy\" width=\"210\" height=\"150\"></figure><p>반면에 ColBERT의 후기 상호작용 모델은 문서 임베딩의 사전 계산을 허용하여 의미 분석의 깊이를 손상시키지 않으면서 검색 과정을 크게 가속화합니다. 교차 인코더의 직접적인 접근 방식과 비교했을 때 직관적이지 않아 보일 수 있지만, 이 방법은 실시간 및 대규모 정보 검색 작업을 위한 확장 가능한 솔루션을 제공합니다. 이는 계산 효율성과 상호작용 모델링의 품질 사이의 전략적 타협을 나타냅니다.</p><h2 id=\"finding-the-top-k-documents-using-colbert\">ColBERT를 사용한 상위 K개 문서 찾기</h2><p>질의와 문서에 대한 임베딩이 있으면 가장 관련성 높은 상위 K개 문서를 찾는 것은 간단해집니다(하지만 두 벡터의 코사인을 계산하는 것만큼 간단하지는 않습니다).</p><p>주요 작업에는 용어별 유사도를 계산하기 위한 배치 내적 연산, 질의 용어별 최고 유사도를 찾기 위한 문서 용어에 대한 최대 풀링, 총 문서 점수를 도출하기 위한 질의 용어에 대한 합산, 그리고 이러한 점수를 기반으로 문서를 정렬하는 것이 포함됩니다. PyTorch 의사 코드는 아래와 같습니다:</p><pre><code class=\"language-python\">import torch\n\ndef compute_relevance_scores(query_embeddings, document_embeddings, k):\n    \"\"\"\n    Compute relevance scores for top-k documents given a query.\n    \n    :param query_embeddings: Tensor representing the query embeddings, shape: [num_query_terms, embedding_dim]\n    :param document_embeddings: Tensor representing embeddings for k documents, shape: [k, max_doc_length, embedding_dim]\n    :param k: Number of top documents to re-rank\n    :return: Sorted document indices based on their relevance scores\n    \"\"\"\n    \n    # Ensure document_embeddings is a 3D tensor: [k, max_doc_length, embedding_dim]\n    # Pad the k documents to their maximum length for batch operations\n    # Note: Assuming document_embeddings is already padded and moved to GPU\n    \n    # Compute batch dot-product of Eq (query embeddings) and D (document embeddings)\n    # Resulting shape: [k, num_query_terms, max_doc_length]\n    scores = torch.matmul(query_embeddings.unsqueeze(0), document_embeddings.transpose(1, 2))\n    \n    # Apply max-pooling across document terms (dim=2) to find the max similarity per query term\n    # Shape after max-pool: [k, num_query_terms]\n    max_scores_per_query_term = scores.max(dim=2).values\n    \n    # Sum the scores across query terms to get the total score for each document\n    # Shape after sum: [k]\n    total_scores = max_scores_per_query_term.sum(dim=1)\n    \n    # Sort the documents based on their total scores\n    sorted_indices = total_scores.argsort(descending=True)\n    \n    return sorted_indices\n</code></pre><p>이 절차는 훈련과 추론 시의 재순위화 모두에서 사용됩니다. ColBERT 모델은 쌍별 랭킹 손실을 사용하여 훈련되며, 훈련 데이터는 질의를 나타내는 $q$, 질의와 관련된(긍정) 문서 $d^+$, 관련 없는(부정) 문서 $d^-$로 구성된 삼중항 $(q, d^+, d^-)$으로 구성됩니다. 모델은 $q$와 $d^+$ 사이의 유사도 점수가 $q$와 $d^-$ 사이의 점수보다 높도록 표현을 학습하는 것을 목표로 합니다.</p><p>훈련 목적 함수는 수학적으로 다음과 같은 손실 함수를 최소화하는 것으로 표현할 수 있습니다: $$\\mathrm{Loss} = \\max(0, 1 - S(q, d^+) + S(q, d^-))$$</p><p>, 여기서 $S(q, d)$는 질의 $q$와 문서 $d$ 사이에 ColBERT가 계산한 유사도 점수를 나타냅니다. 이 점수는 모델 아키텍처에서 설명한 후기 상호작용 패턴에 따라 질의와 문서 사이의 가장 잘 매칭되는 임베딩의 최대 유사도 점수를 집계하여 얻습니다. 이 접근 방식은 모델이 주어진 질의에 대해 관련 있는 문서와 관련 없는 문서를 구분하도록 훈련되어, 긍정 및 부정 문서 쌍의 유사도 점수에서 더 큰 마진을 장려합니다.</p><h3 id=\"denoised-supervision-in-colbertv2\">ColBERTv2의 잡음 제거 감독</h3><p>ColBERTv2의 잡음 제거 감독은 도전적인 부정 예제를 선택하고 교차 인코더를 활용하여 지식 증류를 수행함으로써 원래의 훈련 과정을 개선합니다. 훈련 데이터 품질을 향상시키는 이 정교한 방법은 다음과 같은 여러 단계를 포함합니다:</p><ol><li><strong>초기 훈련</strong>: 질의, 관련 문서, 관련 없는 문서로 구성된 MS MARCO 데이터셋의 공식 삼중항을 활용합니다.</li><li><strong>인덱싱 및 검색</strong>: ColBERTv2의 압축을 사용하여 훈련 패시지를 인덱싱하고, 각 질의에 대해 상위 k개 패시지를 검색합니다.</li><li><strong>교차 인코더 재순위화</strong>: MiniLM 교차 인코더를 통한 재순위화로 패시지 선택을 향상시키고, 그 점수를 ColBERTv2로 증류합니다.</li><li><strong>훈련 튜플 형성</strong>: 도전적인 예제를 만들기 위해 높은 순위와 낮은 순위의 패시지를 모두 포함하는 w-way 튜플을 생성합니다.</li><li><strong>반복적 개선</strong>: 어려운 부정 예제의 선택을 지속적으로 개선하여 모델 성능을 향상시키는 과정을 반복합니다.</li></ol><p>이 과정은 ColBERT 아키텍처의 근본적인 변화가 아닌 훈련 체계의 정교한 개선을 나타냅니다.</p><h3 id=\"hyperparameters-of-colbert\">ColBERT의 하이퍼파라미터</h3><p>ColBERT의 하이퍼파라미터는 다음과 같이 요약됩니다:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>하이퍼파라미터</th>\n<th>최적 선택</th>\n<th>이유</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Learning Rate</td>\n<td>3 x 10^{-6}</td>\n<td>안정적이고 효과적인 모델 업데이트를 위해 미세조정용으로 선택.</td>\n</tr>\n<tr>\n<td>Batch Size</td>\n<td>32</td>\n<td>연산 효율성과 업데이트당 충분한 정보 캡처 능력의 균형을 맞춤.</td>\n</tr>\n<tr>\n<td>Number of Embeddings per Query (Nq)</td>\n<td>32</td>\n<td>쿼리 간 일관된 표현 크기를 보장하여 효율적인 처리를 지원하도록 고정됨.</td>\n</tr>\n<tr>\n<td>Embedding Dimension (m)</td>\n<td>128</td>\n<td>표현력과 연산 효율성 사이의 좋은 균형을 제공하는 것으로 입증됨.</td>\n</tr>\n<tr>\n<td>Training Iterations</td>\n<td>200k (MS MARCO), 125k (TREC CAR)</td>\n<td>과적합을 피하면서 충분한 학습을 보장하기 위해 선택되었으며, 데이터셋 특성에 따라 조정됨.</td>\n</tr>\n<tr>\n<td>Bytes per Dimension in Embeddings</td>\n<td>4 (re-ranking), 2 (end-to-end ranking)</td>\n<td>적용 맥락(re-ranking vs. end-to-end)을 고려한 정밀도와 공간 효율성 간의 절충안.</td>\n</tr>\n<tr>\n<td>Vector-Similarity Function</td>\n<td>Cosine (re-ranking), (Squared) L2 (end-to-end)</td>\n<td>각각의 검색 맥락에서의 성능과 효율성을 기반으로 선택됨.</td>\n</tr>\n<tr>\n<td>FAISS Index Partitions (P)</td>\n<td>2000</td>\n<td>검색 공간 분할의 세분성을 결정하여 검색 효율성에 영향을 미침.</td>\n</tr>\n<tr>\n<td>Nearest Partitions Searched (p)</td>\n<td>10</td>\n<td>검색의 범위와 연산 효율성 간의 균형을 맞춤.</td>\n</tr>\n<tr>\n<td>Sub-vectors per Embedding (s)</td>\n<td>16</td>\n<td>양자화의 세분성에 영향을 미치며, 검색 속도와 메모리 사용량에 영향을 줌.</td>\n</tr>\n<tr>\n<td>Index Representation per Dimension</td>\n<td>16-bit values</td>\n<td>end-to-end 검색의 두 번째 단계에서 정확도와 공간의 절충을 위해 선택됨.</td>\n</tr>\n<tr>\n<td>Number of Layers in Encoders</td>\n<td>12-layer BERT</td>\n<td>맥락 이해의 깊이와 연산 효율성 사이의 최적 균형.</td>\n</tr>\n<tr>\n<td>Max Query Length</td>\n<td>128</td>\n<td>쿼리 인코더가 처리하는 최대 토큰 수. <b>Jina-ColBERT 모델에서는 확장됨.</b></td>\n</tr>\n<tr>\n<td>Max Document Length</td>\n<td>512</td>\n<td>문서 인코더가 처리하는 최대 토큰 수. <b>Jina-ColBERT 모델에서는 8192로 확장됨.</b></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"the-indexing-strategy-of-colbert\">ColBERT의 인덱싱 전략</h2><p>각 문서를 하나의 임베딩 벡터로 인코딩하는 표현 기반 접근 방식과 달리, <strong>ColBERT는 문서(및 쿼리)를 임베딩 집합으로 인코딩하며, 문서의 각 토큰마다 고유한 임베딩을 가집니다.</strong> 이 접근 방식은 본질적으로 더 긴 문서의 경우 더 많은 임베딩이 저장됨을 의미하며, <strong>이는 원래 ColBERT의 문제점이었고, 후에 ColBERTv2에서 해결되었습니다.</strong></p><p>이를 효율적으로 관리하는 핵심은 ColBERT가 인덱싱과 검색을 위해 벡터 데이터베이스(예: <a href=\"https://github.com/facebookresearch/faiss?ref=jina-ai-gmbh.ghost.io\">FAISS</a>)를 사용하는 것과 대량의 데이터를 효율적으로 처리하도록 설계된 상세한 인덱싱 프로세스에 있습니다. 원래 ColBERT 논문은 인덱싱과 검색의 효율성을 높이기 위한 여러 전략을 언급합니다:</p><ul><li><strong>오프라인 인덱싱</strong>: 문서 표현은 오프라인에서 계산되어 문서 임베딩의 사전 계산과 저장이 가능합니다. 이 프로세스는 배치 처리와 GPU 가속을 활용하여 대규모 문서 컬렉션을 효율적으로 처리합니다.</li><li><strong>임베딩 저장</strong>: 문서 임베딩은 각 차원에 대해 32비트 또는 16비트 값을 사용하여 저장될 수 있으며, 정밀도와 저장 요구사항 사이의 절충안을 제공합니다. 이러한 유연성은 ColBERT가 효과성(검색 성능 측면)과 효율성(저장 및 계산 비용 측면) 사이의 균형을 유지할 수 있게 합니다.</li></ul><p>원래 ColBERT에는 없었던 ColBERTv2의 <strong>residual compression</strong> 도입은 품질을 유지하면서 모델의 공간 점유율을 6-10배 줄이는 데 핵심적인 역할을 합니다. 이 기술은 고정된 참조 중심점들로부터의 차이만을 효과적으로 캡처하고 저장함으로써 임베딩을 더욱 압축합니다.</p><h2 id=\"effectiveness-and-efficiency-of-colbert\">ColBERT의 효과성과 효율성</h2><p>처음에는 검색에 BERT의 심층 맥락 이해를 통합하는 것이 본질적으로 상당한 컴퓨팅 리소스를 필요로 하여, 높은 지연 시간과 계산 비용으로 인해 실시간 애플리케이션에 적합하지 않을 것이라고 가정할 수 있습니다. 하지만 ColBERT는 후기 상호작용 메커니즘의 혁신적인 사용을 통해 이러한 가정에 도전하고 이를 뒤집습니다. 주목할 만한 점은 다음과 같습니다:</p><ol><li><strong>큰 폭의 효율성 향상</strong>: ColBERT는 전통적인 BERT 기반 랭킹 모델에 비해 계산 비용(FLOPs)과 지연 시간을 대폭 감소시킵니다. 특히, 주어진 모델 크기(예: 12-layer \"base\" transformer encoder)에서 ColBERT는 BERT 기반 모델의 성능을 매칭하거나 일부 경우에는 훨씬 적은 계산 요구사항으로 초과합니다. 예를 들어, 재랭킹 깊이 <em>k</em>=10에서 BERT는 ColBERT보다 거의 180배 더 많은 FLOPs를 필요로 합니다; 이 차이는 <em>k</em>가 증가함에 따라 더 벌어져서 <em>k</em>=1000에서는 13900배, <em>k</em>=2000에서는 23000배에 이릅니다.</li><li><strong>End-to-End 검색에서의 향상된 Recall과 MRR@10</strong>: 쿼리와 문서 표현 간의 더 깊은 상호작용(초기 상호작용 모델에서 볼 수 있는)이 높은 검색 성능에 필요할 것이라는 초기 직관과는 달리, ColBERT의 end-to-end 검색 설정은 우수한 효과성을 보여줍니다. 예를 들어, Recall@50은 공식 BM25의 Recall@1000과 거의 모든 다른 모델의 Recall@200을 초과하여, 각 쿼리-문서 쌍의 직접 비교 없이도 방대한 컬렉션에서 관련 문서를 검색하는 모델의 주목할 만한 능력을 강조합니다.</li><li><strong>실제 애플리케이션에 대한 실용성</strong>: 실험 결과는 ColBERT의 실제 시나리오 적용 가능성을 강조합니다. 인덱싱 처리량과 메모리 효율성으로 인해 MS MARCO와 같은 대규모 문서 컬렉션을 몇 시간 내에 인덱싱할 수 있으며, 관리 가능한 공간 점유율로 높은 효과성을 유지합니다. 이러한 특성은 성능과 계산 효율성이 모두 중요한 프로덕션 환경에서 ColBERT의 적합성을 강조합니다.</li><li><strong>문서 컬렉션 크기에 대한 확장성</strong>: 아마도 가장 놀라운 결론은 ColBERT의 대규모 문서 컬렉션 처리에 대한 확장성과 효율성일 것입니다. 이 아키텍처는 문서 임베딩의 사전 계산을 허용하고 쿼리-문서 상호작용을 위한 효율적인 배치 처리를 활용하여 시스템이 문서 컬렉션의 크기에 따라 효과적으로 확장될 수 있게 합니다. 이러한 확장성은 효과적인 문서 검색에 필요한 복잡성과 이해의 깊이를 고려할 때 직관적이지 않으며, 계산 효율성과 검색 효과성의 균형을 맞추는 ColBERT의 혁신적인 접근 방식을 보여줍니다.</li></ol><h2 id=\"using-jina-colbert-v1-en-a-8192-length-colbertv2-model\"><code>jina-colbert-v1-en</code> 사용하기: 8192 길이의 ColBERTv2 모델</h2><p>Jina-ColBERT는 빠르고 정확한 검색을 위해 설계되었으며, 아키텍처 개선으로 더 긴 시퀀스 처리가 가능한 JinaBERT의 발전을 활용하여 <a href=\"https://jina.ai/news/jina-ai-launches-worlds-first-open-source-8k-text-embedding-rivaling-openai/?ref=jina-ai-gmbh.ghost.io\">최대 8192의 더 긴 컨텍스트 길이를 지원합니다</a>.</p><div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">엄밀히 말하면 Jina-ColBERT는 8190 토큰 길이를 지원합니다. ColBERT 문서 인코더에서 각 문서는 시작 부분에 <code spellcheck=\"false\" style=\"white-space: pre-wrap;\">[D],[CLS]</code>로 패딩됨을 기억하세요.</div></div><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/jina-colbert-v1-en · Hugging Face</div><div class=\"kg-bookmark-description\">We're on a journey to advance and democratize artificial intelligence through open source and open science.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://huggingface.co/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://cdn-thumbnails.huggingface.co/social-thumbnails/models/jinaai/jina-colbert-v1-en.png\" alt=\"\"></div></a></figure><h3 id=\"jinas-improvement-over-original-colbert\">원래 ColBERT에 대한 Jina의 개선사항</h3><p>Jina-ColBERT의 주요 발전은 그 백본인 <code>jina-bert-v2-base-en</code>으로, <code>bert-base-uncased</code>를 사용하는 원래 ColBERT와 비교하여 훨씬 더 긴 컨텍스트(최대 8192 토큰)를 처리할 수 있습니다. 이 기능은 광범위한 콘텐츠를 가진 문서를 처리하는 데 중요하며, 더 자세하고 맥락적인 검색 결과를 제공합니다.</p><h3 id=\"jina-colbert-v1-en-performance-comparison-vs-colbertv2\"><code>jina-colbert-v1-en</code>의 ColBERTv2 대비 성능 비교</h3><p>우리는 BEIR 데이터셋과 긴 컨텍스트를 선호하는 새로운 LoCo 벤치마크에서 <code>jina-colbert-v1-en</code>을 평가하여 원래 ColBERTv2 구현과 비상호작용 기반<code>jina-embeddings-v2-base-en</code> 모델.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>ColBERTv2</th>\n<th>jina-colbert-v1-en</th>\n<th>jina-embeddings-v2-base-en</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arguana</td>\n<td>46.5</td>\n<td><strong>49.4</strong></td>\n<td>44.0</td>\n</tr>\n<tr>\n<td>Climate-Fever</td>\n<td>18.1</td>\n<td>19.6</td>\n<td><strong>23.5</strong></td>\n</tr>\n<tr>\n<td>DBPedia</td>\n<td><strong>45.2</strong></td>\n<td>41.3</td>\n<td>35.1</td>\n</tr>\n<tr>\n<td>FEVER</td>\n<td>78.8</td>\n<td><strong>79.5</strong></td>\n<td>72.3</td>\n</tr>\n<tr>\n<td>FiQA</td>\n<td>35.4</td>\n<td>36.8</td>\n<td><strong>41.6</strong></td>\n</tr>\n<tr>\n<td>HotpotQA</td>\n<td><strong>67.5</strong></td>\n<td>65.9</td>\n<td>61.4</td>\n</tr>\n<tr>\n<td>NFCorpus</td>\n<td>33.7</td>\n<td><strong>33.8</strong></td>\n<td>32.5</td>\n</tr>\n<tr>\n<td>NQ</td>\n<td>56.1</td>\n<td>54.9</td>\n<td><strong>60.4</strong></td>\n</tr>\n<tr>\n<td>Quora</td>\n<td>85.5</td>\n<td>82.3</td>\n<td><strong>88.2</strong></td>\n</tr>\n<tr>\n<td>SCIDOCS</td>\n<td>15.4</td>\n<td>16.9</td>\n<td><strong>19.9</strong></td>\n</tr>\n<tr>\n<td>SciFact</td>\n<td>68.9</td>\n<td><strong>70.1</strong></td>\n<td>66.7</td>\n</tr>\n<tr>\n<td>TREC-COVID</td>\n<td>72.6</td>\n<td><strong>75.0</strong></td>\n<td>65.9</td>\n</tr>\n<tr>\n<td>Webis-touch2020</td>\n<td>26.0</td>\n<td><strong>27.0</strong></td>\n<td>26.2</td>\n</tr>\n<tr>\n<td>LoCo</td>\n<td>74.3</td>\n<td>83.7</td>\n<td><strong>85.4</strong></td>\n</tr>\n<tr>\n<td>Average</td>\n<td>51.7</td>\n<td><strong>52.6</strong></td>\n<td>51.6</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>이 표는 <code>jina-colbert-v1-en</code>의 우수한 성능을 보여주며, 특히 기존 ColBERTv2와 비교하여 긴 컨텍스트 길이가 필요한 시나리오에서 더욱 두드러집니다. <code>jina-embeddings-v2-base-en</code>은 <a href=\"https://arxiv.org/abs/2310.19923?ref=jina-ai-gmbh.ghost.io\">더 많은 학습 데이터를 사용</a>하는 반면, <code>jina-colbert-v1-en</code>은 MSMARCO만 사용하는데, 이는 일부 작업에서 <code>jina-embeddings-v2-base-en</code>의 좋은 성능을 설명할 수 있습니다.</p><h3 id=\"example-usage-of-jina-colbert-v1-en\"><code>jina-colbert-v1-en</code> 사용 예시</h3><p>이 코드 스니펫은 Jina-ColBERT의 인덱싱 프로세스를 보여주며, 긴 문서에 대한 지원을 보여줍니다.</p><pre><code class=\"language-python\">from colbert import Indexer\nfrom colbert.infra import Run, RunConfig, ColBERTConfig\n\nn_gpu: int = 1  # Set your number of available GPUs\nexperiment: str = \"\"  # Name of the folder where the logs and created indices will be stored\nindex_name: str = \"\"  # The name of your index, i.e. the name of your vector database\n\nif __name__ == \"__main__\":\n    with Run().context(RunConfig(nranks=n_gpu, experiment=experiment)):\n        config = ColBERTConfig(\n          doc_maxlen=8192  # Our model supports 8k context length for indexing long documents\n        )\n        indexer = Indexer(\n          checkpoint=\"jinaai/jina-colbert-v1-en\",\n          config=config,\n        )\n        documents = [\n          \"ColBERT is an efficient and effective passage retrieval model.\",\n          \"Jina-ColBERT is a ColBERT-style model but based on JinaBERT so it can support both 8k context length.\",\n          \"JinaBERT is a BERT architecture that supports the symmetric bidirectional variant of ALiBi to allow longer sequence length.\",\n          \"Jina-ColBERT model is trained on MSMARCO passage ranking dataset, following a very similar training procedure with ColBERTv2.\",\n          \"Jina-ColBERT achieves the competitive retrieval performance with ColBERTv2.\",\n          \"Jina is an easier way to build neural search systems.\",\n          \"You can use Jina-ColBERT to build neural search systems with ease.\",\n          # Add more documents here to ensure the clustering work correctly\n        ]\n        indexer.index(name=index_name, collection=documents)\n</code></pre><h3 id=\"use-jina-colbert-v1-en-in-ragatouille\">RAGatouille에서 <code>jina-colbert-v1-en</code> 사용하기</h3><p>RAGatouille는 RAG 파이프라인 내에서 고급 검색 방법의 사용을 용이하게 하는 새로운 Python 라이브러리입니다. 모듈성과 쉬운 통합을 위해 설계되었으며, 사용자가 최신 연구 결과를 원활하게 활용할 수 있게 해줍니다. RAGatouille의 주요 목표는 ColBERT와 같은 복잡한 모델을 RAG 파이프라인에 적용하는 것을 단순화하여, 개발자들이 기본 연구에 대한 깊은 전문 지식 없이도 이러한 방법을 활용할 수 있게 하는 것입니다. <a href=\"https://twitter.com/bclavie?ref=jina-ai-gmbh.ghost.io\">Benjamin Clavié</a> 덕분에 이제 <code>jina-colbert-v1-en</code>을 쉽게 사용할 수 있습니다:</p><pre><code class=\"language-python\">from ragatouille import RAGPretrainedModel\n\n# Get your model & collection of big documents ready\nRAG = RAGPretrainedModel.from_pretrained(\"jinaai/jina-colbert-v1-en\")\nmy_documents = [\n    \"very long document1\",\n    \"very long document2\",\n    # ... more documents\n]\n\n# And create an index with them at full length!\nRAG.index(collection=my_documents,\n          index_name=\"the_biggest_index\",\n          max_document_length=8190,)\n\n# or encode them in-memory with no truncation, up to your model's max length\nRAG.encode(my_documents)\n</code></pre><p>Jina-ColBERT에 대한 더 자세한 정보와 추가 탐색을 위해 <a href=\"https://huggingface.co/jinaai/jina-colbert-v1-en?ref=jina-ai-gmbh.ghost.io\">Hugging Face 페이지</a>를 방문할 수 있습니다.</p><h2 id=\"conclusion\">결론</h2><p>ColBERT는 정보 검색 분야에서 중요한 진전을 나타냅니다. Jina-ColBERT로 더 긴 컨텍스트 길이를 가능하게 하고 후기 상호작용에 대한 ColBERT 접근 방식과의 호환성을 유지함으로써, 최첨단 검색 기능을 구현하고자 하는 개발자들에게 강력한 대안을 제공합니다.</p><p>복잡한 검색 모델을 RAG 파이프라인에 통합하는 것을 단순화하는 RAGatouille 라이브러리와 결합하여, 개발자들은 이제 고급 검색 기능을 쉽게 활용할 수 있으며, 워크플로우를 간소화하고 애플리케이션을 향상시킬 수 있습니다. Jina-ColBERT와 RAGatouille의 시너지는 고급 AI 검색 모델을 실용적인 사용을 위해 접근 가능하고 효율적으로 만드는 데 있어 주목할 만한 진전을 보여줍니다.</p>",
  "comment_id": "65d3a2134a32310001f5b71b",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/02/Untitled-design--28-.png",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-02-19T19:46:43.000+01:00",
  "updated_at": "2024-08-30T23:11:22.000+02:00",
  "published_at": "2024-02-20T02:19:04.000+01:00",
  "custom_excerpt": "Jina AI's ColBERT on Hugging Face has set Twitter abuzz, bringing a fresh perspective to search with its 8192-token capability. This article unpacks the nuances of ColBERT and ColBERTv2, showcasing their innovative designs and why their late interaction feature is a game-changer for search.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/what-is-colbert-and-late-interaction-and-why-they-matter-in-search/",
  "excerpt": "Jina AI의 Hugging Face 상의 ColBERT가 8192 토큰 처리 능력으로 Twitter를 뜨겁게 달구며 검색 분야에 새로운 시각을 제시했습니다. 이 글에서는 ColBERT와 ColBERTv2의 미묘한 차이점을 살펴보고, 혁신적인 설계와 후기 상호작용(late interaction) 기능이 검색을 혁신적으로 바꾸는 이유를 소개합니다.",
  "reading_time": 16,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Neon theater or concert hall marquee letters lit up at night with city lights and faint \"Adobe Sto\" visible.",
  "feature_image_caption": null
}