{
  "slug": "what-late-chunking-really-is-and-what-its-not-part-ii",
  "id": "66fe70236ca44300014cabe4",
  "uuid": "a27b0f3c-a533-422c-9d37-3ed3e2130539",
  "title": "Late Chunking이 실제로 무엇이고 무엇이 아닌가: 파트 II",
  "html": "<div class=\"kg-card kg-callout-card kg-callout-card-blue\"><div class=\"kg-callout-emoji\">💡</div><div class=\"kg-callout-text\">이 글은 좀 더 심도 있는 관점을 제공하고 일반적인 오해와 비교를 중점적으로 다루므로 <a href=\"https://jina.ai/news/late-chunking-in-long-context-embedding-models?ref=jina-ai-gmbh.ghost.io\">Part I을 먼저 읽을 것을</a> 강력히 권장합니다. <b><strong style=\"white-space: pre-wrap;\">권장 읽기 순서: </strong></b><a href=\"https://jina.ai/news/late-chunking-in-long-context-embedding-models/?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">part I</strong></b></a><b><strong style=\"white-space: pre-wrap;\">, part II, </strong></b><a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\"><b><strong style=\"white-space: pre-wrap;\">research paper</strong></b></a><b><strong style=\"white-space: pre-wrap;\">.</strong></b></div></div><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Late Chunking: 장문 문맥 임베딩 모델을 사용한 문맥적 청크 임베딩</div><div class=\"kg-bookmark-description\">많은 사용 사례에서는 더 작은 텍스트 부분을 검색해야 하며, 밀집 벡터 기반 검색 시스템은 일반적으로 더 짧은 텍스트 세그먼트에서 더 나은 성능을 보입니다. 이는 임베딩에서 의미가 과도하게 압축될 가능성이 낮기 때문입니다. 따라서 실무자들은 종종 텍스트 문서를 더 작은 청크로 분할하여 각각 별도로 인코딩합니다. 하지만 이렇게 생성된 청크 임베딩은 주변 청크의 문맥 정보를 잃을 수 있어 최적이 아닌 표현이 될 수 있습니다. 본 논문에서는 late chunking이라는 새로운 방법을 소개합니다. 이 방법은 장문 문맥 임베딩 모델을 활용하여 먼저 긴 텍스트의 모든 토큰을 임베딩하고, transformer 모델 이후와 mean pooling 직전에 청킹을 적용합니다 - 따라서 이름에 'late'가 붙었습니다. 결과적으로 생성되는 청크 임베딩은 전체 문맥 정보를 포착하여 다양한 검색 작업에서 우수한 결과를 보여줍니다. 이 방법은 다양한 장문 문맥 임베딩 모델에 적용될 수 있을 만큼 일반적이며 추가 학습 없이도 작동합니다. late chunking의 효과를 더욱 높이기 위해, 우리는 임베딩 모델을 위한 전용 파인튜닝 접근 방식을 제안합니다.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/apple-touch-icon-1.png\" alt=\"\"><span class=\"kg-bookmark-author\">arXiv.org</span><span class=\"kg-bookmark-publisher\">Michael Günther</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/arxiv-logo-fb.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>긴 문서를 청킹할 때는 두 가지 문제가 있습니다. 첫 번째는 <strong>분기점 결정</strong>—즉, 문서를 어떻게 분할할 것인가 입니다. 고정된 토큰 길이, 고정된 문장 수, 또는 <a href=\"https://jina.ai/segmenter?ref=jina-ai-gmbh.ghost.io\">정규식이나 의미적 분할 모델</a>과 같은 더 고급 기술을 고려할 수 있습니다. 정확한 청크 경계는 검색 결과의 가독성을 향상시킬 뿐만 아니라, RAG 시스템에서 LLM에 공급되는 청크가 정확하고 충분하도록—더도 말고 덜도 말고—보장합니다.</p><p>두 번째 문제는 각 청크 내의 <strong>문맥 손실</strong>입니다. 문서가 분할되면 대부분의 사람들이 다음 논리적 단계로 각 청크를 일괄 처리 방식으로 별도로 임베딩합니다. 하지만 이는 원래 문서의 전체적인 문맥 손실로 이어집니다. 많은 이전 연구들은 더 나은 경계 탐지가 의미적 표현을 개선한다고 주장하며 첫 번째 문제를 먼저 다루었습니다. 예를 들어, \"의미적 청킹\"은 임베딩 공간에서 코사인 유사도가 높은 문장들을 그룹화하여 의미 단위의 중단을 최소화합니다.</p><p>우리의 관점에서 보면, 이 두 가지 문제는 <em>거의</em> 직교하며 별도로 해결될 수 있습니다. 우선순위를 정해야 한다면, <strong>두 번째 문제가 더 중요하다고 말할 수 있습니다.</strong></p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th style=\"text-align:center\">문제 2: <b>문맥 정보</b></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td style=\"text-align:center\">보존됨</td>\n<td>손실됨</td>\n</tr>\n<tr>\n<td><b>문제 1: 분기점</b></td>\n<td>좋음</td>\n<td style=\"text-align:center\">이상적인 시나리오</td>\n<td>나쁜 검색 결과</td>\n</tr>\n<tr>\n<td></td>\n<td>나쁨</td>\n<td style=\"text-align:center\">좋은 검색 결과, 하지만 결과가 사람이 읽기 어렵거나 LLM 추론에 부적합할 수 있음</td>\n<td>최악의 시나리오</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"late-chunking-for-context-loss\">문맥 손실을 위한 Late Chunking</h2><p><strong>Late chunking</strong>은 두 번째 문제부터 해결하기 시작합니다: <strong>문맥의 손실</strong>. 이는 이상적인 분기점이나 의미적 경계를 찾는 것에 관한 것이 <em>아닙니다</em>. 여전히 정규식, 휴리스틱, 또는 다른 기술을 사용하여 긴 문서를 작은 청크로 나눠야 합니다. 하지만 분할된 각 청크를 바로 임베딩하는 대신, late chunking은 먼저 전체 문서를 하나의 문맥 윈도우에서 인코딩합니다(<code>jina-embeddings-v3</code>의 경우 8192-토큰). 그런 다음 경계 신호를 따라 각 청크에 대해 mean pooling을 적용합니다—이것이 late chunking에서 \"late\"라는 용어가 붙은 이유입니다.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/Diagram--Blog-images--6-.svg\" class=\"kg-image\" alt=\"Diagram comparing &quot;Naive Chunking&quot; and &quot;Late Chunking&quot; methods for processing long documents with labeled steps.\" loading=\"lazy\" width=\"1200\" height=\"865\"><figcaption><span style=\"white-space: pre-wrap;\">Late chunking은 여전히 경계 신호가 필요하지만, 핵심적인 차이는 이러한 신호가 사용되는 시점입니다. Late chunking에서는 전체 문서가 임베딩된 후에만 신호가 적용되며, 이는 pooling 범위를 결정하는 데 사용됩니다.</span></figcaption></figure><h2 id=\"late-chunking-is-resilient-to-poor-boundary-cues\">Late Chunking은 부적절한 경계 신호에도 견고합니다</h2><p>흥미로운 점은 실험에 따르면 late chunking이 완벽한 의미적 경계의 필요성을 제거한다는 것인데, 이는 위에서 언급한 첫 번째 문제를 부분적으로 해결합니다. 실제로 고정 토큰 경계에 적용된 late chunking은 의미적 경계 신호를 사용한 naive chunking보다 더 나은 성능을 보여줍니다. Late chunking과 함께 사용될 때 고정 길이 경계를 사용하는 것과 같은 단순한 분할 모델이 고급 경계 탐지 알고리즘과 비슷한 성능을 보입니다. 우리는 세 가지 다른 크기의 임베딩 모델을 테스트했고, 결과는 모든 테스트 데이터셋에서 이들 모두가 일관되게 late chunking의 혜택을 받는다는 것을 보여줍니다. 다만, 임베딩 모델 자체가 여전히 성능에 가장 중요한 요소입니다—<strong>late chunking을 사용하는 더 약한 모델이 그것을 사용하지 않는 더 강한 모델을 능가하는 경우는 단 한 번도 없었습니다.</strong></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/plot--7-.svg\" class=\"kg-image\" alt=\"Scatter plot chart showing the percentage of relative improvements across various models against a baseline, with a vertical \" loading=\"lazy\" width=\"950\" height=\"756\"><figcaption><span style=\"white-space: pre-wrap;\">기준선(즉, 고정 토큰 길이 경계 신호와 naive chunking을 사용한 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-small</span></code><span style=\"white-space: pre-wrap;\">)에 대한 상대적 검색 개선도. 제거 연구의 일환으로, 우리는 서로 다른 경계 신호(고정 토큰 길이, 문장 경계, 의미적 경계)와 다른 모델들(</span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-small</span></code><span style=\"white-space: pre-wrap;\">, </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>nomic-v1</span></code><span style=\"white-space: pre-wrap;\">, 그리고 </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\">)로 late chunking을 테스트했습니다. MTEB에서의 성능을 기반으로, 이 세 임베딩 모델의 순위는: </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v2-small</span></code><span style=\"white-space: pre-wrap;\"> &lt; </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>nomic-v1</span></code><span style=\"white-space: pre-wrap;\"> &lt; </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code>입니다. 하지만 이 실험의 초점은 임베딩 모델 자체의 성능을 평가하는 것이 아니라, 더 나은 임베딩 모델이 후기 청킹 및 경계 큐와 어떻게 상호작용하는지를 이해하는 것입니다. 실험의 자세한 내용은 우리의 연구 논문을 참고해 주시기 바랍니다.</figcaption></figure>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th>Combo</th>\n<th>SciFact</th>\n<th>NFCorpus</th>\n<th>FiQA</th>\n<th>TRECCOVID</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Baseline</td>\n<td>64.2</td>\n<td>23.5</td>\n<td>33.3</td>\n<td>63.4</td>\n</tr>\n<tr>\n<td>Late</td>\n<td>66.1</td>\n<td>30.0</td>\n<td>33.8</td>\n<td>64.7</td>\n</tr>\n<tr>\n<td>Nomic</td>\n<td>70.7</td>\n<td>35.3</td>\n<td>37.0</td>\n<td>72.9</td>\n</tr>\n<tr>\n<td>Jv3</td>\n<td>71.8</td>\n<td>35.6</td>\n<td>46.3</td>\n<td>73.0</td>\n</tr>\n<tr>\n<td>Late + Nomic</td>\n<td>70.6</td>\n<td>35.3</td>\n<td>38.3</td>\n<td>75.0</td>\n</tr>\n<tr>\n<td>Late + Jv3</td>\n<td><strong>73.2</strong></td>\n<td><strong>36.7</strong></td>\n<td><strong>47.6</strong></td>\n<td><strong>77.2</strong></td>\n</tr>\n<tr>\n<td>SentBound</td>\n<td>64.7</td>\n<td>28.3</td>\n<td>30.4</td>\n<td>66.5</td>\n</tr>\n<tr>\n<td>Late + SentBound</td>\n<td>65.2</td>\n<td>30.0</td>\n<td>33.9</td>\n<td>66.6</td>\n</tr>\n<tr>\n<td>Nomic + SentBound</td>\n<td>70.4</td>\n<td>35.3</td>\n<td>34.8</td>\n<td>74.3</td>\n</tr>\n<tr>\n<td>Jv3 + SentBound</td>\n<td>71.4</td>\n<td>35.8</td>\n<td>43.7</td>\n<td>72.4</td>\n</tr>\n<tr>\n<td>Late + Nomic + SentBound</td>\n<td>70.5</td>\n<td>35.3</td>\n<td>36.9</td>\n<td>76.1</td>\n</tr>\n<tr>\n<td>Late + Jv3 + SentBound</td>\n<td>72.4</td>\n<td>36.6</td>\n<td>47.6</td>\n<td>76.2</td>\n</tr>\n<tr>\n<td>SemanticBound</td>\n<td>64.3</td>\n<td>27.4</td>\n<td>30.3</td>\n<td>66.2</td>\n</tr>\n<tr>\n<td>Late + SemanticBound</td>\n<td>65.0</td>\n<td>29.3</td>\n<td>33.7</td>\n<td>66.3</td>\n</tr>\n<tr>\n<td>Nomic + SemanticBound</td>\n<td>70.4</td>\n<td>35.3</td>\n<td>34.8</td>\n<td>74.3</td>\n</tr>\n<tr>\n<td>Jv3 + SemanticBound</td>\n<td>71.2</td>\n<td>36.1</td>\n<td>44.0</td>\n<td>74.7</td>\n</tr>\n<tr>\n<td>Late + Nomic + SemanticBound</td>\n<td>70.5</td>\n<td>36.9</td>\n<td>36.9</td>\n<td>76.1</td>\n</tr>\n<tr>\n<td>Late + Jv3 + SemanticBound</td>\n<td>72.4</td>\n<td>36.6</td>\n<td>47.6</td>\n<td>76.2</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>잘못된 경계에 대한 복원력이 있다고 해서 경계를 무시할 수 있다는 의미는 아닙니다—경계는 여전히 인간과 LLM의 가독성 모두에 중요합니다. 우리의 관점은 다음과 같습니다: 세그멘테이션을 최적화할 때, 즉 앞서 언급한 첫 번째 문제를 해결할 때, 의미/컨텍스트 손실에 대한 걱정 없이 가독성에만 집중할 수 있습니다. Late Chunking은 좋은 또는 나쁜 브레이크포인트에 모두 대응할 수 있으므로, 가독성만 신경 쓰면 됩니다.</p><h2 id=\"late-chunking-is-bidirectional\">Late Chunking은 양방향입니다</h2><p>Late Chunking에 대한 또 다른 일반적인 오해는 조건부 청크 임베딩이 \"앞을 보지 않고\" 이전 청크에만 의존한다는 것입니다. 이는 잘못된 것입니다. <strong>Late Chunking의 조건부 의존성은 실제로 단방향이 아닌 양방향</strong>입니다. 이는 임베딩 모델—인코더 전용 트랜스포머—의 어텐션 행렬이 자기회귀 모델에서 사용되는 마스킹된 삼각 행렬과 달리 완전히 연결되어 있기 때문입니다. 공식적으로, 청크 $k$의 임베딩은 $v_k \\sim Q(c_k | c_1, c_2, \\cdots, c_{k-1})$가 아닌 $v_k \\sim Q(c_k|D)$입니다. 여기서 $Q$는 언어 모델의 인수분해를 나타냅니다. 이는 또한 Late Chunking이 정확한 경계 배치에 의존하지 않는 이유를 설명합니다.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/10/Heading--27-.svg\" class=\"kg-image\" alt=\"Diagrams of a transformer model with detailed encoder on the left and decoder on the right, labeled with tokens, embeddings, \" loading=\"lazy\" width=\"1033\" height=\"560\"><figcaption><span style=\"white-space: pre-wrap;\">마스킹된 셀프 어텐션이 있는 디코더 전용 모델과 달리, 임베딩 모델은 일반적으로 전체 어텐션 행렬을 가진 인코더 전용입니다. 이는 각 토큰 임베딩이 동일한 컨텍스트 윈도우 내의 모든 다른 토큰에 의해 조건화된다는 것을 의미하며, </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>jina-embeddings-v3</span></code><span style=\"white-space: pre-wrap;\">의 경우 최대 8191개의 다른 토큰을 포함합니다. 결과적으로 청크 임베딩은 양방향으로 전역 컨텍스트 정보를 포함합니다.</span></figcaption></figure><h2 id=\"late-chunking-can-be-trained\">Late Chunking은 학습이 가능합니다</h2><p>Late Chunking은 임베딩 모델에 대한 추가 학습을 <em>필요로 하지 않습니다</em>. 평균 풀링을 사용하는 모든 긴 컨텍스트 임베딩 모델에 적용될 수 있어 실무자들에게 매우 매력적입니다. 그러나 질의응답이나 쿼리-문서 검색과 같은 작업을 하고 있다면, 일부 미세조정을 통해 성능을 더욱 향상시킬 수 있습니다. 구체적으로, 학습 데이터는 다음을 포함하는 튜플로 구성됩니다:</p><ul><li><strong>쿼리</strong> (예: 질문 또는 검색어)</li><li>쿼리에 대한 관련 정보를 포함하는 <strong>문서</strong></li><li>문서 내에서 쿼리에 직접적으로 답하는 특정 텍스트 청크인 <strong>관련 구간</strong></li></ul><p>모델은 InfoNCE와 같은 대조 손실 함수를 사용하여 쿼리를 관련 구간과 쌍을 이루어 학습됩니다. 이를 통해 관련 구간이 임베딩 공간에서 쿼리와 긴밀하게 정렬되는 반면, 관련 없는 구간은 더 멀리 밀려납니다. 결과적으로 모델은 청크 임베딩을 생성할 때 문서의 가장 관련성 높은 부분에 집중하는 방법을 학습합니다. <a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\">자세한 내용은 우리의 연구 논문을 참조하시기 바랍니다.</a></p><h2 id=\"late-chunking-vs-contextual-retrieval\">Late Chunking vs. Contextual Retrieval</h2><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://www.anthropic.com/news/contextual-retrieval?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Introducing Contextual Retrieval</div><div class=\"kg-bookmark-description\">Anthropic is an AI safety and research company that's working to build reliable, interpretable, and steerable AI systems.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/apple-touch-icon-2.png\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/519f63e0ea393f33e56c2e812713d65dcf27a79a-2880x1620.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Late Chunking이 소개된 직후, Anthropic은 <strong>Contextual Retrieval</strong>이라는 별도의 전략을 소개했습니다. Anthropic의 방법은 컨텍스트 손실 문제를 해결하기 위한 브루트포스 접근 방식이며, 다음과 같이 작동합니다:</p><ol><li>각 청크는 전체 문서와 함께 LLM에 전송됩니다.</li><li>LLM은 각 청크에 관련 컨텍스트를 추가합니다.</li><li>이는 더 풍부하고 정보가 많은 임베딩을 생성합니다.</li></ol><p>우리의 관점에서 이는 본질적으로 <strong>컨텍스트 보강</strong>으로, LLM을 사용하여 전역 컨텍스트를 각 청크에 명시적으로 하드코딩하는 것이며, <strong>비용</strong>, <strong>시간</strong>, <strong>저장공간</strong> 측면에서 비용이 많이 듭니다. 또한 LLM이 컨텍스트를 효과적으로 풍부하게 하기 위해 정확하고 읽기 쉬운 청크에 의존하기 때문에, 이 접근 방식이 청크 경계에 대해 복원력이 있는지는 불분명합니다. 반면에 Late Chunking은 위에서 입증된 것처럼 경계 큐에 대해 매우 강한 복원력을 가집니다. 임베딩 크기는 동일하게 유지되므로 추가 저장공간이 필요하지 않습니다. 임베딩 모델의 전체 컨텍스트 길이를 활용하지만, <a href=\"https://jina.ai/news/jina-embeddings-v3-a-frontier-multilingual-embedding-model/?ref=jina-ai-gmbh.ghost.io#parameter-latechunking\">보강을 생성하기 위해 LLM을 사용하는 것보다 여전히 훨씬 빠릅니다</a>. 우리 연구 논문의 정성적 연구에서, <a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\">Anthropic의 컨텍스트 검색이 Late Chunking과 유사한 성능을 보인다는 것을 보여줍니다.</a> 하지만 Late Chunking은 인코더 전용 트랜스포머의 고유한 메커니즘을 활용하여 더 저수준의, 일반적이고 자연스러운 해결책을 제공합니다.</p><h2 id=\"which-embedding-models-support-late-chunking\">어떤 임베딩 모델이 Late Chunking을 지원하나요?</h2><p>Late Chunking은 <code>jina-embeddings-v3</code>나 <code>v2</code>에만 국한되지 않습니다. 평균 풀링을 사용하는 모든 긴 컨텍스트 임베딩 모델에 적용할 수 있는 꽤 일반적인 접근 방식입니다. 예를 들어, 이 포스트에서는 <code>nomic-v1</code>도 이를 지원한다는 것을 보여줍니다. 모든 임베딩 제공자가 자신들의 솔루션에서 Late Chunking 지원을 구현하는 것을 환영합니다.</p><p>모델 사용자로서, 새로운 임베딩 모델이나 API를 평가할 때 Late Chunking을 지원할 수 있는지 확인하기 위해 다음 단계를 따를 수 있습니다:</p><ol><li><strong>단일 출력</strong>: 모델/API가 토큰 수준의 임베딩이 아닌 문장당 하나의 최종 임베딩만 제공합니까? 만약 그렇다면, 후기 청킹을 지원할 수 없을 가능성이 높습니다(특히 웹 API의 경우).</li><li><strong>긴 컨텍스트 지원</strong>: 모델/API가 최소 8192 토큰의 컨텍스트를 처리할 수 있습니까? 그렇지 않다면, 후기 청킹은 적용할 수 없습니다—더 정확히 말하면, 짧은 컨텍스트 모델에 후기 청킹을 적용하는 것은 의미가 없습니다. 만약 지원한다면, 단순히 지원한다고 주장하는 것이 아니라 실제로 긴 컨텍스트에서 잘 작동하는지 확인하세요. 이러한 정보는 일반적으로 LongMTEB나 다른 긴 컨텍스트 벤치마크에 대한 평가와 같이 모델의 기술 보고서에서 찾을 수 있습니다.</li><li><strong>평균 풀링</strong>: 풀링 전에 토큰 수준 임베딩을 제공하는 자체 호스팅 모델이나 API의 경우, 기본 풀링 방법이 평균 풀링인지 확인하세요. CLS나 최대 풀링을 사용하는 모델은 후기 청킹과 호환되지 않습니다.</li></ol><p>요약하자면, 임베딩 모델이 긴 컨텍스트를 지원하고 기본적으로 평균 풀링을 사용한다면 후기 청킹을 쉽게 지원할 수 있습니다. 구현 세부사항과 추가 논의를 위해 우리의 <a href=\"https://github.com/jina-ai/late-chunking/issues/?ref=jina-ai-gmbh.ghost.io\">GitHub 저장소를 확인</a>하세요.</p><h2 id=\"conclusion\">결론</h2><p>그렇다면, 후기 청킹이란 무엇일까요? 후기 청킹은 긴 컨텍스트 임베딩 모델을 사용하여 청크 임베딩을 생성하는 간단한 방법입니다. 이는 빠르고, 경계 신호에 강하며, 매우 효과적입니다. 이는 단순한 휴리스틱이나 과도한 엔지니어링이 아닌, 트랜스포머 메커니즘에 대한 깊은 이해를 바탕으로 한 신중한 설계입니다.</p><p>오늘날 LLM을 둘러싼 과대 선전은 부인할 수 없습니다. 많은 경우, BERT와 같은 작은 모델로 효율적으로 해결할 수 있는 문제들이 더 크고 복잡한 솔루션의 매력으로 인해 LLM에 맡겨지고 있습니다. 대형 LLM 제공업체들이 자신들의 모델 채택을 추진하고, 임베딩 제공업체들이 임베딩을 옹호하는 것은 놀라운 일이 아닙니다 — 둘 다 자신들의 상업적 강점을 활용하고 있는 것입니다. 하지만 결국에는 과대 선전이 아닌, 실제로 무엇이 작동하는지가 중요합니다. 커뮤니티, 업계, 그리고 가장 중요하게는 시간이 어떤 접근 방식이 진정으로 더 간단하고, 효율적이며, 지속 가능한지 보여줄 것입니다.</p><p><a href=\"https://arxiv.org/abs/2409.04701?ref=jina-ai-gmbh.ghost.io\">우리의 연구 논문</a>을 꼭 읽어보시고, 다양한 시나리오에서 후기 청킹을 벤치마크하고 여러분의 피드백을 공유해 주시기 바랍니다.</p>",
  "comment_id": "66fe70236ca44300014cabe4",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/10/lc2.png",
  "featured": false,
  "visibility": "public",
  "created_at": "2024-10-03T12:21:23.000+02:00",
  "updated_at": "2024-10-07T15:29:00.000+02:00",
  "published_at": "2024-10-03T19:19:16.000+02:00",
  "custom_excerpt": "Part 2 of our exploration of Late Chunking, a deep dive into why it is the best method for chunk embeddings and improving search/RAG performance.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/what-late-chunking-really-is-and-what-its-not-part-ii/",
  "excerpt": "청크 임베딩과 검색/RAG 성능을 향상시키는 최상의 방법인 Late Chunking에 대한 심층 탐구의 파트 2입니다.",
  "reading_time": 9,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Slide depicting the \"Late Chunking\" process, with flow charts and a model highlighting the transition from a \"Long Document\" ",
  "feature_image_caption": null
}