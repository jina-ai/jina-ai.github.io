{
  "slug": "reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown",
  "id": "66dff7eba241f5000155d851",
  "uuid": "49dc11d4-e792-49d6-b778-512add9024bc",
  "title": "Reader-LM: малые языковые модели для очистки и конвертации HTML в Markdown",
  "html": "<figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-0.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-0.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Мы находимся в пути к развитию и демократизации искусственного интеллекта через открытый исходный код и открытую науку.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-0.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://huggingface.co/jinaai/reader-lm-1.5b?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">jinaai/reader-lm-1.5b · Hugging Face</div><div class=\"kg-bookmark-description\">Мы находимся в пути к развитию и демократизации искусственного интеллекта через открытый исходный код и открытую науку.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/reader-lm-1.5b.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>В апреле 2024 года мы выпустили <a href=\"https://jina.ai/reader?ref=jina-ai-gmbh.ghost.io\">Jina Reader</a> — простой API, который преобразует любой URL в дружественный для LLM markdown с помощью простого префикса: <code>r.jina.ai</code>. Несмотря на сложное сетевое программирование за кулисами, основная часть \"чтения\" довольно проста. Сначала мы используем безголовый браузер Chrome для получения исходного кода веб-страницы. Затем мы используем пакет Mozilla <a href=\"https://github.com/mozilla/readability?ref=jina-ai-gmbh.ghost.io\">Readability</a> для извлечения основного содержимого, удаляя такие элементы, как заголовки, нижние колонтитулы, панели навигации и боковые панели. Наконец, мы преобразуем очищенный HTML в markdown с помощью <a href=\"https://x.com/JinaAI_/status/1823756993108304135?ref=jina-ai-gmbh.ghost.io\">regex</a> и библиотеки <a href=\"https://github.com/mixmark-io/turndown?ref=jina-ai-gmbh.ghost.io\">Turndown</a>. Результатом является хорошо структурированный markdown-файл, готовый к использованию LLM для обоснования, обобщения и рассуждения.</p><p>В первые несколько недель после выпуска Jina Reader мы получили много отзывов, особенно касательно качества контента. Некоторые пользователи находили его слишком подробным, в то время как другие считали его недостаточно детальным. Также были сообщения о том, что фильтр Readability удалял неправильный контент или что Turndown испытывал трудности с преобразованием определенных частей HTML в markdown. К счастью, многие из этих проблем были успешно решены путем исправления существующего конвейера новыми регулярными выражениями или эвристиками.</p><p>С тех пор мы задаемся одним вопросом: вместо того, чтобы исправлять это большим количеством эвристик и регулярных выражений (что становится все сложнее поддерживать и не является мультиязычным), можем ли мы решить эту проблему <em>end-to-end</em> с помощью языковой модели?</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png\" class=\"kg-image\" alt=\"Блок-схема, иллюстрирующая преобразование сырого HTML в формат Markdown с использованием библиотек readability и turndown, плюс regex/heu\" loading=\"lazy\" width=\"1800\" height=\"945\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/Heading--48-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/Heading--48-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/Heading--48-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png 1800w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Иллюстрация </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>reader-lm</span></code><span style=\"white-space: pre-wrap;\">, заменяющая конвейер readability+turndown+regex эвристики с помощью маленькой языковой модели.</span></figcaption></figure><p>На первый взгляд, использование LLM для очистки данных может показаться избыточным из-за их низкой экономической эффективности и меньшей скорости. Но что, если мы рассмотрим <strong>маленькую языковую модель (SLM)</strong> — с менее чем 1 миллиардом параметров, которая может эффективно работать на периферии? Это звучит гораздо привлекательнее, верно? Но действительно ли это осуществимо или это просто мечты? Согласно закону масштабирования, меньшее количество параметров обычно приводит к снижению способностей рассуждения и обобщения. Поэтому SLM может даже испытывать трудности с генерацией какого-либо осмысленного содержания, если размер её параметров слишком мал. Давайте подробнее рассмотрим задачу преобразования HTML в Markdown:</p><ul><li>Во-первых, рассматриваемая задача <strong>не такая творческая или сложная, как типичные задачи LLM</strong>. В случае преобразования HTML в markdown модели в основном нужно <strong>выборочно копировать</strong> из входных данных в выходные (т.е. пропускать HTML-разметку, боковые панели, заголовки, нижние колонтитулы), с минимальными усилиями на генерацию нового содержания (в основном вставка markdown-синтаксиса). Это резко контрастирует с более широкими задачами, которые решают LLM, такими как генерация стихов или написание кода, где выходные данные требуют гораздо больше творчества и не являются прямым копированием из входных данных. Это наблюдение предполагает, что SLM может работать, так как задача <em>кажется</em> проще, чем более общая генерация текста.</li><li>Во-вторых, нам нужно <strong>приоритизировать поддержку длинного контекста</strong>. Современный HTML часто содержит гораздо больше шума, чем простая разметка <code>&lt;div&gt;</code>. Встроенный CSS и скрипты могут легко раздуть код до сотен тысяч токенов. Чтобы SLM была практичной в этом сценарии, длина контекста должна быть достаточно большой. Длина токенов в 8K или 16K <em>совсем</em> не полезна.</li></ul><p>Похоже, что нам нужна <strong><em>неглубокая, но широкая</em></strong> SLM. \"Неглубокая\" в том смысле, что задача в основном простое \"копирование-вставка\", поэтому требуется меньше transformer-блоков; и \"широкая\" в том смысле, что требуется поддержка длинного контекста, чтобы быть практичной, поэтому механизм внимания требует особого ухода. Предыдущие исследования показали, что длина контекста и способность к рассуждению тесно связаны. Для SLM крайне сложно оптимизировать оба измерения, сохраняя при этом малый размер параметров.</p><p>Сегодня мы рады анонсировать первую версию этого решения с выпуском <code>reader-lm-0.5b</code> и <code>reader-lm-1.5b</code>, двух SLM, специально обученных <strong>генерировать чистый markdown непосредственно из шумного исходного HTML</strong>. Обе модели являются многоязычными и поддерживают длину контекста до <strong>256K токенов</strong>. Несмотря на компактный размер, эти модели достигают передовой производительности в этой задаче, превосходя более крупные LLM-аналоги, будучи при этом только 1/50 их размера.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Reader-LM-vs-LLMs-on-the-HTML2Markdown-task--1-.svg\" class=\"kg-image\" alt=\"Столбчатая диаграмма, показывающая превосходную производительность Reader-LM в задаче HTML2Markdown с наивысшим показателем 0.72 против различных LLM.\" loading=\"lazy\" width=\"805\" height=\"514\"></figure><p>Ниже приведены спецификации двух моделей:</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">reader-lm-0.5b</th>\n<th style=\"text-align:center\">reader-lm-1.5b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td># Parameters</td>\n<td style=\"text-align:center\">494M</td>\n<td style=\"text-align:center\">1.54B</td>\n</tr>\n<tr>\n<td>Context length</td>\n<td style=\"text-align:center\">256K</td>\n<td style=\"text-align:center\">256K</td>\n</tr>\n<tr>\n<td>Hidden Size</td>\n<td style=\"text-align:center\">896</td>\n<td style=\"text-align:center\">1536</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">28</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">128</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td style=\"text-align:center\">4864</td>\n<td style=\"text-align:center\">8960</td>\n</tr>\n<tr>\n<td>Multilingual</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:center\">Yes</td>\n</tr>\n<tr>\n<td>HuggingFace Repo</td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-0.5b/?ref=jina-ai-gmbh.ghost.io\">Link</a></td>\n<td style=\"text-align:center\"><a href=\"https://huggingface.co/jinaai/reader-lm-1.5b/?ref=jina-ai-gmbh.ghost.io\">Link</a></td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"get-started-with-reader-lm\">Начало работы с Reader-LM</h2><h3 id=\"on-google-colab\">В Google Colab</h3><p>Самый простой способ попробовать <code>reader-lm</code> — запустить наш блокнот Colab, где мы демонстрируем, как использовать <code>reader-lm-1.5b</code> для преобразования веб-сайта Hacker News в markdown. Блокнот оптимизирован для плавной работы на бесплатном уровне GPU T4 Google Colab. Вы также можете загрузить <code>reader-lm-0.5b</code> или изменить URL на любой веб-сайт и изучить результат. Обратите внимание, что входными данными (т.е. промптом) для модели является исходный HTML — никаких инструкций-префиксов не требуется.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://colab.research.google.com/drive/1wXWyj5hOxEHY6WeHbOwEzYAC0WB1I5uA?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Google Colab</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/thumbnail/colab_favicon_256px.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><p>Обратите внимание, что бесплатный GPU T4 имеет ограничения, которые могут препятствовать использованию продвинутых оптимизаций при выполнении модели. Функции, такие как bfloat16 и flash attention, недоступны на T4, что может привести к повышенному использованию VRAM и более медленной производительности для длинных входных данных. <strong>Для производственных сред мы рекомендуем использовать GPU высокого класса, такой как RTX 3090/4090, для значительно лучшей производительности.</strong></p><h3 id=\"in-production-available-on-azure-aws-soon\">В производстве: Скоро доступно на Azure и AWS</h3><p>Reader-LM доступен на Azure Marketplace и AWS SageMaker. Если вам нужно использовать эти модели за пределами этих платформ или локально в вашей компании, обратите внимание, что обе модели лицензированы под CC BY-NC 4.0. <a href=\"https://jina.ai/contact-sales/?ref=jina-ai-gmbh.ghost.io\" rel=\"noreferrer\">По вопросам коммерческого использования, пожалуйста, свяжитесь с нами.</a></p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-nli7b6dueo424?sr=0-1&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 0.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://aws.amazon.com/marketplace/pp/prodview-ms27ixcwq3wjk?sr=0-2&ref_=beagle&applicationId=AWSMPContessa&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">AWS Marketplace: Reader-LM 1.5b</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/favicon.ico\" alt=\"\"></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://d32gc0xr2ho6pa.cloudfront.net/img/general/v2/socialPreview.png\" alt=\"\" onerror=\"this.style.display = 'none'\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-500m?tab=Overview&ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://azuremarketplace.microsoft.com/en-us/marketplace/apps/jinaai.reader-lm-1500m?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Microsoft Azure Marketplace</div><div class=\"kg-bookmark-description\"></div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://azuremarketplace.microsoft.com/favicon.ico\" alt=\"\"></div></div></a></figure><h2 id=\"benchmark\">Тестирование производительности</h2><p>Для количественной оценки производительности Reader-LM мы сравнили его с несколькими большими языковыми моделями, включая: GPT-4o, Gemini-1.5-Flash, Gemini-1.5-Pro, LLaMA-3.1-70B, Qwen2-7B-Instruct.</p><p>Модели оценивались по следующим метрикам:</p><ul><li><strong>ROUGE-L (чем выше, тем лучше)</strong>: Эта метрика, широко используемая для задач суммаризации и ответов на вопросы, измеряет перекрытие между предсказанным выводом и эталоном на уровне n-грамм.</li><li><strong>Token Error Rate (TER, чем ниже, тем лучше)</strong>: Эта метрика вычисляет долю сгенерированных markdown-токенов, которые не встречаются в исходном HTML-контенте. Мы разработали эту метрику для оценки уровня галлюцинаций модели, помогая нам выявлять случаи, когда модель производит контент, не обоснованный в HTML. Дальнейшие улучшения будут внесены на основе анализа конкретных случаев.</li><li><strong>Word Error Rate (WER, чем ниже, тем лучше)</strong>: Обычно используемый в задачах OCR и ASR, WER учитывает последовательность слов и подсчитывает ошибки, такие как вставки (ADD), замены (SUB) и удаления (DEL). Эта метрика обеспечивает детальную оценку несоответствий между сгенерированным markdown и ожидаемым выводом.</li></ul><p>Для использования LLM для этой задачи мы использовали следующую единообразную инструкцию в качестве префикса промпта:</p><pre><code>Your task is to convert the content of the provided HTML file into the corresponding markdown file. You need to convert the structure, elements, and attributes of the HTML into equivalent representations in markdown format, ensuring that no important information is lost. The output should strictly be in markdown format, without any additional explanations.</code></pre><p>Результаты можно найти в таблице ниже.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ROUGE-L</th>\n<th>WER</th>\n<th>TER</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reader-lm-0.5b</td>\n<td>0.56</td>\n<td>3.28</td>\n<td>0.34</td>\n</tr>\n<tr>\n<td>reader-lm-1.5b</td>\n<td><strong>0.72</strong></td>\n<td><strong>1.87</strong></td>\n<td><strong>0.19</strong></td>\n</tr>\n<tr>\n<td>gpt-4o</td>\n<td>0.43</td>\n<td>5.88</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>gemini-1.5-flash</td>\n<td>0.40</td>\n<td>21.70</td>\n<td>0.55</td>\n</tr>\n<tr>\n<td>gemini-1.5-pro</td>\n<td>0.42</td>\n<td>3.16</td>\n<td>0.48</td>\n</tr>\n<tr>\n<td>llama-3.1-70b</td>\n<td>0.40</td>\n<td>9.87</td>\n<td>0.50</td>\n</tr>\n<tr>\n<td>Qwen2-7B-Instruct</td>\n<td>0.23</td>\n<td>2.45</td>\n<td>0.70</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<h2 id=\"qualitative-study\">Качественное исследование</h2><p>Мы провели качественное исследование путем визуальной проверки выходного markdown. <a href=\"https://docs.google.com/spreadsheets/d/1Wb2sMdiEoToPaXohcrEznFKStt_4alVOnJD3WKkiM7o/edit?gid=1576339853&ref=jina-ai-gmbh.ghost.io#gid=1576339853\">Мы отобрали 22 HTML-источника</a>, включая новостные статьи, блог-посты, целевые страницы, страницы электронной коммерции и форумные посты на нескольких языках: английском, немецком, японском и китайском. Мы также включили Jina Reader API в качестве базового уровня, который опирается на регулярные выражения, эвристику и предопределенные правила.</p><p>Оценка фокусировалась на четырех ключевых аспектах вывода, каждая модель оценивалась по шкале от 1 (низший) до 5 (высший):</p><ol><li><strong>Извлечение заголовков</strong>: Оценка того, насколько хорошо каждая модель идентифицирует и форматирует заголовки документа h1,h2,..., h6, используя правильный синтаксис markdown.</li><li><strong>Извлечение основного содержания</strong>: Оценка способности моделей точно конвертировать основной текст, сохраняя параграфы, форматирование списков и поддерживая согласованность представления.</li><li><strong>Сохранение богатой структуры</strong>: Анализ того, насколько эффективно каждая модель сохраняет общую структуру документа, включая заголовки, подзаголовки, маркированные списки и нумерованные списки.</li><li><strong>Использование синтаксиса Markdown</strong>: Оценка способности каждой модели правильно конвертировать HTML-элементы, такие как <code>&lt;a&gt;</code> (ссылки), <code>&lt;strong&gt;</code> (жирный текст) и <code>&lt;em&gt;</code> (курсив) в их соответствующие эквиваленты markdown.</li></ol><p>Результаты можно найти ниже.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/Qualitative-Evaluation-of-Reader-LM-vs-LLMs-and-Jina-Reader-API--1-.svg\" class=\"kg-image\" alt=\"Bar chart comparing Reader-LM, LLMs, and Jina Reader API on metrics like header extraction and content preservation.\" loading=\"lazy\" width=\"863\" height=\"533\"></figure><p>Reader-LM-1.5B стабильно показывает хорошие результаты по всем параметрам, особенно выделяясь в сохранении структуры и использовании синтаксиса markdown. Хотя он не всегда превосходит Jina Reader API, его производительность конкурентоспособна с более крупными моделями, такими как Gemini 1.5 Pro, что делает его высокоэффективной альтернативой более крупным LLM. Reader-LM-0.5B, хотя и меньше, все еще обеспечивает солидную производительность, особенно в сохранении структуры.</p><h2 id=\"how-we-trained-reader-lm\">Как мы обучали Reader-LM</h2><h3 id=\"data-preparation\">Подготовка данных</h3><p>Мы использовали Jina Reader API для генерации обучающих пар исходного HTML и соответствующего markdown. В ходе эксперимента мы обнаружили, что SLM особенно чувствительны к качеству обучающих данных. Поэтому мы создали конвейер данных, который обеспечивает включение в обучающий набор только высококачественных markdown-записей.</p><p>Кроме того, мы добавили некоторые синтетические HTML и их markdown-аналоги, сгенерированные с помощью <code>GPT-4o</code>. По сравнению с реальным HTML, синтетические данные, как правило, намного короче, с более простыми и предсказуемыми структурами, и значительно более низким уровнем шума.</p><p>Наконец, мы объединили HTML и markdown, используя шаблон чата. Окончательные обучающие данные форматированы следующим образом:</p><pre><code>&lt;|im_start|&gt;system\nYou are a helpful assistant.&lt;|im_end|&gt;\n&lt;|im_start|&gt;user\n{{RAW_HTML}}&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n{{MARKDOWN}}&lt;|im_end|&gt;\n</code></pre><p>Полный объем обучающих данных составляет 2,5 миллиарда токенов.</p><h3 id=\"two-stage-training\">Двухэтапное обучение</h3><p>Мы провели эксперименты с моделями различных размеров, начиная от 65M и 135M параметров и до 3B параметров. Спецификации для каждой модели можно найти в таблице ниже.</p>\n<!--kg-card-begin: html-->\n<table>\n<thead>\n<tr>\n<th></th>\n<th>reader-lm-65m</th>\n<th>reader-lm-135m</th>\n<th>reader-lm-360m</th>\n<th>reader-lm-0.5b</th>\n<th>reader-lm-1.5b</th>\n<th>reader-lm-1.7b</th>\n<th>reader-lm-3b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hidden Size</td>\n<td>512</td>\n<td>576</td>\n<td>960</td>\n<td>896</td>\n<td>1536</td>\n<td>2048</td>\n<td>3072</td>\n</tr>\n<tr>\n<td># Layers</td>\n<td>8</td>\n<td>30</td>\n<td>32</td>\n<td>24</td>\n<td>28</td>\n<td>24</td>\n<td>32</td>\n</tr>\n<tr>\n<td># Query Heads</td>\n<td>16</td>\n<td>9</td>\n<td>15</td>\n<td>14</td>\n<td>12</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td># KV Heads</td>\n<td>8</td>\n<td>3</td>\n<td>5</td>\n<td>2</td>\n<td>2</td>\n<td>32</td>\n<td>32</td>\n</tr>\n<tr>\n<td>Head Size</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n<td>128</td>\n<td>64</td>\n<td>96</td>\n</tr>\n<tr>\n<td>Intermediate Size</td>\n<td>2048</td>\n<td>1536</td>\n<td>2560</td>\n<td>4864</td>\n<td>8960</td>\n<td>8192</td>\n<td>8192</td>\n</tr>\n<tr>\n<td>Attention Bias</td>\n<td>False</td>\n<td>False</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Embedding Tying</td>\n<td>False</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>True</td>\n<td>False</td>\n</tr>\n<tr>\n<td>Vocabulary Size</td>\n<td>32768</td>\n<td>49152</td>\n<td>49152</td>\n<td>151646</td>\n<td>151646</td>\n<td>49152</td>\n<td>32064</td>\n</tr>\n<tr>\n<td>Base Model</td>\n<td>Lite-Oute-1-65M-Instruct</td>\n<td>SmolLM-135M</td>\n<td>SmolLM-360M-Instruct</td>\n<td>Qwen2-0.5B-Instruct</td>\n<td>Qwen2-1.5B-Instruct</td>\n<td>SmolLM-1.7B</td>\n<td>Phi-3-mini-128k-instruct</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: html-->\n<p>Обучение модели проводилось в два этапа:</p><ol><li><strong>Короткий и простой HTML: </strong>На этом этапе максимальная длина последовательности (HTML + markdown) была установлена на 32K токенов, с общим количеством 1,5 миллиарда обучающих токенов.</li><li><strong>Длинный и сложный HTML</strong>: длина последовательности была увеличена до 128K токенов, с 1,2 миллиардами обучающих токенов. Для этого этапа мы реализовали механизм zigzag-ring-attention из работы <a href=\"https://github.com/zhuzilin/ring-flash-attention?ref=jina-ai-gmbh.ghost.io\">Zilin Zhu \"Ring Flash Attention\" (2024)</a>.</li></ol><p>Поскольку обучающие данные включали последовательности длиной до 128K токенов, мы полагаем, что модель может без проблем поддерживать до 256K токенов. Однако обработка 512K токенов может быть проблематичной, так как расширение позиционных вложений RoPE в четыре раза относительно длины обучающей последовательности может привести к ухудшению производительности.</p><p>Для моделей с 65M и 135M параметров мы наблюдали, что они могли достичь разумного поведения \"копирования\", но только с короткими последовательностями (менее 1K токенов). С увеличением длины входных данных эти модели испытывали трудности с генерацией разумного вывода. Учитывая, что современный исходный код HTML легко может превышать 100K токенов, лимит в 1K токенов далеко не достаточен.</p><h3 id=\"degeneration-and-dull-loops\">Дегенерация и монотонные циклы</h3><p>Одной из основных проблем, с которыми мы столкнулись, была дегенерация, особенно в форме повторений и зацикливания. После генерации некоторых токенов модель начинала многократно генерировать один и тот же токен или застревала в цикле, непрерывно повторяя короткую последовательность токенов до достижения максимально допустимой длины вывода.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png\" class=\"kg-image\" alt=\"Dark themed coding script with repeated structural programming comments about data types, functions, and mathematical operati\" loading=\"lazy\" width=\"2000\" height=\"1278\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/image-1.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png 2040w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Пример дегенерации возникает, когда модель начинает с нормальной генерации markdown, но внезапно застревает в \"монотонных циклах\", как показано красными стрелками.</span></figcaption></figure><p>Для решения этой проблемы:</p><ul><li>Мы применили <a href=\"https://github.com/yxuansu/SimCTG?ref=jina-ai-gmbh.ghost.io\">контрастный поиск</a> как метод декодирования и включили контрастные потери во время обучения. По нашим экспериментам, этот метод эффективно снизил повторяющуюся генерацию на практике.</li><li>Мы реализовали простой критерий остановки повторений в конвейере transformer. Этот критерий автоматически определяет, когда модель начинает повторять токены, и останавливает декодирование на раннем этапе, чтобы избежать монотонных циклов. Эта идея была вдохновлена этим <a href=\"https://github.com/huggingface/transformers/issues/32902?ref=jina-ai-gmbh.ghost.io\" rel=\"noopener\">обсуждением</a>.</li></ul><h3 id=\"training-efficiency-on-long-inputs\">Эффективность обучения на длинных входных данных</h3><p>Чтобы снизить риск ошибок нехватки памяти (OOM) при обработке длинных входных данных, мы реализовали поблочную передачу модели. Этот подход кодирует длинный ввод меньшими фрагментами, уменьшая использование VRAM.</p><p>Мы улучшили реализацию упаковки данных в нашей обучающей структуре, которая основана на Transformers Trainer. Для оптимизации эффективности обучения несколько коротких текстов (например, 2K токенов) объединяются в одну длинную последовательность (например, 30K токенов), что позволяет проводить обучение без заполнения. Однако в исходной реализации некоторые короткие примеры разделялись на два подтекста и включались в разные длинные обучающие последовательности. В таких случаях второй подтекст терял свой контекст (например, исходное содержание HTML в нашем случае), что приводило к искажению обучающих данных. Это заставляет модель полагаться на свои параметры, а не на входной контекст, что, по нашему мнению, является основным источником галлюцинаций.</p><p>В итоге мы выбрали модели 0.5B и 1.5B для публикации. <strong>Модель 0.5B является наименьшей моделью, способной достичь желаемого поведения \"выборочного копирования\" на входных данных с длинным контекстом</strong>, в то время как модель 1.5B является наименьшей более крупной моделью, которая значительно улучшает производительность без достижения уменьшения отдачи по отношению к размеру параметров.</p><h3 id=\"alternative-architecture-encoder-only-model\">Альтернативная архитектура: модель только с энкодером</h3><p>На ранних этапах этого проекта мы также исследовали использование архитектуры только с энкодером для решения этой задачи. Как упоминалось ранее, задача конвертации HTML в Markdown представляется в основном задачей \"выборочного копирования\". Учитывая обучающую пару (исходный HTML и markdown), мы можем пометить токены, существующие как во входных, так и в выходных данных, как <code>1</code>, а остальные как <code>0</code>. Это преобразует проблему в задачу классификации токенов, аналогичную той, что используется в распознавании именованных сущностей (NER).</p><p>Хотя этот подход казался логичным, он представлял значительные трудности на практике. Во-первых, исходный HTML из реальных источников крайне зашумлен и длинен, что делает метки <code>1</code> крайне разреженными и, следовательно, трудными для обучения модели. Во-вторых, кодирование специального синтаксиса markdown в схеме <code>0-1</code> оказалось проблематичным, поскольку символы вроде <code>## title</code>, <code>*bold*</code> и <code>| table |</code> не существуют во входных данных исходного HTML. В-третьих, выходные токены не всегда строго следуют порядку входных данных. Часто происходит небольшое изменение порядка, особенно с таблицами и ссылками, что затрудняет представление такого поведения переупорядочивания в простой схеме <code>0-1</code>. Переупорядочивание на короткие расстояния потенциально можно было бы обрабатывать с помощью динамического программирования или алгоритмов выравнивания-искажения, введя метки вроде <code>-1, -2, +1, +2</code> для представления смещений расстояния, преобразуя задачу бинарной классификации в задачу многоклассовой классификации токенов.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png\" class=\"kg-image\" alt=\"Chart titled &quot;Token-Level DP Alignment (Horizontal)&quot; with tokens on the x-axis and alignment on the y-axis, highlighting best\" loading=\"lazy\" width=\"2000\" height=\"1436\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/output--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/output--2-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/output--2-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png 2179w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">Использование динамического программирования для выравнивания исходного HTML (ось X) и markdown (ось Y) для создания обучающих меток на уровне токенов.</span></figcaption></figure><p>Подводя итог, решение проблемы с архитектурой только с энкодером и рассмотрение её как задачи классификации токенов имеет свою привлекательность, особенно поскольку обучающие последовательности намного короче по сравнению с моделью только с декодером, что делает её более дружественной к VRAM. Однако <strong>основная проблема заключается в подготовке качественных обучающих данных.</strong> Когда мы осознали, что время и усилия, затраченные на предварительную обработку данных — использование динамического программирования и эвристик для создания идеальных последовательностей меток на уровне токенов — были чрезмерными, мы решили прекратить этот подход.</p><h2 id=\"conclusion\">Заключение</h2><p>Reader-LM - это новая малая языковая модель (SLM), разработанная для извлечения и очистки данных в открытом интернете. Вдохновленные Jina Reader, мы стремились создать комплексное решение на основе языковой модели, способное преобразовывать необработанный, зашумленный HTML в чистый markdown. При этом мы сосредоточились на экономической эффективности, сохраняя небольшой размер модели, чтобы Reader-LM оставалась практичной и удобной в использовании. <strong>Это также первая декодер-only модель с длинным контекстом, обученная в Jina AI.</strong></p><p>Хотя изначально задача может показаться простой проблемой \"выборочного копирования\", преобразование и очистка HTML в markdown далеко не просты. В частности, модель должна отлично справляться с позиционно-зависимыми рассуждениями на основе контекста, что требует большего размера параметров, особенно в скрытых слоях. Для сравнения, изучение синтаксиса markdown относительно просто.</p><p>В ходе наших экспериментов мы также обнаружили, что обучение SLM с нуля особенно сложно. Начало с предварительно обученной модели и продолжение обучения для конкретной задачи значительно повысило эффективность обучения. Все еще остается много возможностей для улучшения как эффективности, так и качества: расширение длины контекста, ускорение декодирования и добавление поддержки инструкций во входных данных, что позволило бы Reader-LM извлекать определенные части веб-страницы в markdown.</p>",
  "comment_id": "66dff7eba241f5000155d851",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/09/reader-lm-banner.jpg",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-09-10T09:40:27.000+02:00",
  "updated_at": "2024-09-20T14:09:30.000+02:00",
  "published_at": "2024-09-11T12:25:03.000+02:00",
  "custom_excerpt": "Reader-LM-0.5B and Reader-LM-1.5B are two novel small language models inspired by Jina Reader, designed to convert raw, noisy HTML from the open web into clean markdown.",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "62e3d0ef9cd5ce003d5e49e2",
      "name": "Jina AI",
      "slug": "company",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
      "cover_image": null,
      "bio": "Creator of neural search, contributor to open source.",
      "website": "https://www.jina.ai",
      "location": "Berlin",
      "facebook": null,
      "twitter": "@JinaAI_",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/company/"
    }
  ],
  "tags": [
    {
      "id": "655b2782bb728c000101bed7",
      "name": "Press",
      "slug": "press",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
    }
  ],
  "primary_author": {
    "id": "62e3d0ef9cd5ce003d5e49e2",
    "name": "Jina AI",
    "slug": "company",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/08/Jjqb-JeY_400x400.jpg",
    "cover_image": null,
    "bio": "Creator of neural search, contributor to open source.",
    "website": "https://www.jina.ai",
    "location": "Berlin",
    "facebook": null,
    "twitter": "@JinaAI_",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/company/"
  },
  "primary_tag": {
    "id": "655b2782bb728c000101bed7",
    "name": "Press",
    "slug": "press",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/press/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown/",
  "excerpt": "Reader-LM-0.5B и Reader-LM-1.5B — это два новых компактных языковых модели, вдохновленных Jina Reader, предназначенные для преобразования необработанного, зашумленного HTML из открытого интернета в чистый markdown.",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Technical screenshot displaying \"REAPER-LM-0.5B/1.5B\" with HTML source code for Jina's search grounding feature.",
  "feature_image_caption": null
}