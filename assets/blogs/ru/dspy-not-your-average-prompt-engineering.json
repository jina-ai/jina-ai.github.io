{
  "slug": "dspy-not-your-average-prompt-engineering",
  "id": "66077bf0a5c39b0001044181",
  "uuid": "e242c77c-f712-462c-9745-3e9269eb8a8b",
  "title": "DSPy: Нечто большее, чем обычная инженерия промптов",
  "html": "<div class=\"kg-card kg-file-card\"><a class=\"kg-file-card-container\" href=\"https://jina-ai-gmbh.ghost.io/content/files/2024/04/DSPy-Not-Your-Average-Prompt-Engineering--1-.pdf\" title=\"Download\" download=\"\"><div class=\"kg-file-card-contents\"><div class=\"kg-file-card-title\">[Слайды] DSPy: Не обычный промпт-инжиниринг</div><div class=\"kg-file-card-caption\">Презентация, которую Хан провел 15 апреля 2024 года в Маунтин-Вью.</div><div class=\"kg-file-card-metadata\"><div class=\"kg-file-card-filename\">DSPy Not Your Average Prompt Engineering (1).pdf</div><div class=\"kg-file-card-filesize\">7 MB</div></div></div><div class=\"kg-file-card-icon\"><svg viewBox=\"0 0 24 24\"><defs><style>.a{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;}</style></defs><title>download-circle</title><polyline class=\"a\" points=\"8.25 14.25 12 18 15.75 14.25\"></polyline><line class=\"a\" x1=\"12\" y1=\"6.75\" x2=\"12\" y2=\"18\"></line><circle class=\"a\" cx=\"12\" cy=\"12\" r=\"11.25\"></circle></svg></div></a></div><p>Недавно я изучил DSPy — передовой фреймворк, разработанный группой Stanford NLP, направленный на алгоритмическую оптимизацию промптов языковых моделей (LM). За последние три дня я собрал некоторые первоначальные впечатления и ценные наблюдения о DSPy. Отмечу, что мои наблюдения не призваны заменить официальную документацию DSPy. Фактически, я настоятельно рекомендую ознакомиться с <a href=\"https://dspy-docs.vercel.app/?ref=jina-ai-gmbh.ghost.io\">их документацией</a> и <a href=\"https://github.com/stanfordnlp/dspy/blob/main/README.md?ref=jina-ai-gmbh.ghost.io\">README</a> хотя бы раз перед погружением в этот пост. Моё обсуждение здесь отражает предварительное понимание DSPy после нескольких дней изучения его возможностей. Существует несколько продвинутых функций, таких как DSPy Assertions, Typed Predictor и настройка весов LM, которые я еще не успел тщательно изучить.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/stanfordnlp/dspy?ref=jina-ai-gmbh.ghost.io\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub - stanfordnlp/dspy: DSPy: The framework for programming—not prompting—foundation models</div><div class=\"kg-bookmark-description\">DSPy: The framework for programming—not prompting—foundation models - stanfordnlp/dspy</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">stanfordnlp</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://opengraph.githubassets.com/b8c1b2b4b3ff9c22d486f5c69dbda5fee6cc8dda8a42aaf1c2e154c17b7dc159/stanfordnlp/dspy\" alt=\"\"></div></a></figure><p>Несмотря на мой опыт работы в Jina AI, которая в основном фокусируется на поисковых основах, мой интерес к DSPy не был напрямую обусловлен его потенциалом в Retrieval-Augmented Generation (RAG). Вместо этого меня заинтересовала возможность использования DSPy для автоматической настройки промптов для решения некоторых задач генерации.</p><p>Если вы новичок в DSPy и ищете доступную отправную точку, или если вы знакомы с фреймворком, но считаете официальную документацию запутанной или сложной, эта статья предназначена для вас. Я также решил <em>не</em> придерживаться строго идиом DSPy, которые могут показаться пугающими для новичков. Итак, давайте углубимся.</p><h2 id=\"what-i-like-about-dspy\">Что мне нравится в DSPy</h2><h3 id=\"dspy-closing-the-loop-of-prompt-engineering\">DSPy замыкает цикл промпт-инжиниринга</h3><p>Больше всего меня воодушевляет подход DSPy к замыканию цикла промпт-инжиниринга, превращая то, что обычно является <em>ручным</em>, <em>кустарным</em> процессом, в <em>структурированный</em>, <em>четко определенный</em> рабочий процесс машинного обучения: подготовка наборов данных, определение модели, обучение, оценка и тестирование. <strong>По моему мнению, это самый революционный аспект DSPy.</strong></p><p>Путешествуя по Bay Area и общаясь со многими основателями стартапов, сосредоточенных на оценке LLM, я часто слышал обсуждения метрик, галлюцинаций, наблюдаемости и соответствия требованиям. Однако эти разговоры часто не переходят к критически важным следующим шагам: <strong>Имея все эти метрики, что делать дальше?</strong> Можно ли считать стратегическим подходом корректировку формулировок в наших промптах в надежде, что определенные волшебные слова (например, \"моя бабушка умирает\") могут улучшить наши метрики? Этот вопрос оставался без ответа у многих стартапов по оценке LLM, и я тоже не мог с ним справиться — пока не открыл для себя DSPy. DSPy представляет четкий, программный метод оптимизации промптов на основе конкретных метрик или даже оптимизации всего конвейера LLM, включая как промпты, так и веса LLM.</p><p>Харрисон, CEO LangChain, и Логан, бывший глава Developer Relations в OpenAI, оба заявили в подкасте <a href=\"https://podcasts.apple.com/us/podcast/unsupervised-learning/id1672188924?ref=jina-ai-gmbh.ghost.io\">Unsupervised Learning</a>, что 2024 год должен стать поворотным годом для оценки LLM. Именно поэтому я считаю, что DSPy заслуживает больше внимания, чем получает сейчас, поскольку DSPy предоставляет критически важный недостающий элемент головоломки.</p><h3 id=\"dspy-separating-logic-from-textual-representation\">DSPy разделяет логику и текстовое представление</h3><p>Другой аспект DSPy, который впечатляет меня, заключается в том, что он формулирует промпт-инжиниринг в воспроизводимый и LLM-агностический модуль. Для достижения этого <strong>он извлекает логику из промпта, создавая четкое разделение между <em>логикой</em> и <em>текстовым представлением</em></strong>, как показано ниже.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--5-.png\" class=\"kg-image\" alt=\"Flowchart depicting sentiment analysis process with steps such as Prompt, Logic, and Textual Representation on a black backgr\" loading=\"lazy\" width=\"1200\" height=\"630\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Heading--5-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/Heading--5-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--5-.png 1200w\" sizes=\"(min-width: 720px) 720px\"><figcaption><span style=\"white-space: pre-wrap;\">В DSPy промпт состоит из внутренней логики (то есть </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>dspy.Module</span></code><span style=\"white-space: pre-wrap;\">) и её текстового представления. Логика неизменна, воспроизводима, тестируема и LLM-агностична. Текстовое представление — это просто следствие логики.</span></figcaption></figure><p><strong>Концепция DSPy о логике как неизменной, тестируемой и LLM-агностичной \"причине\", где текстовое представление является лишь её \"следствием\"</strong>, может изначально показаться озадачивающей. Это особенно верно в свете широко распространенного убеждения, что \"будущее языков программирования — это естественный язык\". Принимая идею, что \"промпт-инжиниринг — это будущее\", можно испытать момент замешательства при столкновении с философией дизайна DSPy. Вопреки ожиданиям упрощения, DSPy вводит массив модулей и синтаксис сигнатур, казалось бы, возвращая естественно-языковые промпты к сложности программирования на C!</p><p>Но почему выбран такой подход? По моему пониманию, <strong>в основе программирования промптов лежит базовая логика, а коммуникация служит усилителем</strong>, потенциально улучшая или ухудшая её эффективность. Директива <code>\"Do sentiment classification\"</code> представляет базовую логику, тогда как фраза вроде <code>\"Follow these demonstrations or I will fire you\"</code> — это один из способов её коммуникации. Аналогично реальным взаимодействиям, трудности в выполнении задач часто возникают не из-за неправильной логики, а из-за проблем в коммуникации. Это объясняет, почему многие, особенно не носители языка, находят промпт-инжиниринг сложным. Я наблюдал, как высококвалифицированные программисты в моей компании испытывают трудности с промпт-инжинирингом не из-за отсутствия логики, а потому что они не \"говорят на нужной волне\". Разделяя логику и промпт, <a href=\"https://dspy-docs.vercel.app/docs/building-blocks/modules?ref=jina-ai-gmbh.ghost.io\">DSPy позволяет детерминированно программировать логику через <code>dspy.Module</code></a>, позволяя разработчикам сосредоточиться на логике так же, как они делали бы это в традиционной разработке, независимо от используемой LLM.</p><p>Итак, если разработчики фокусируются на логике, то кто управляет текстовым представлением? <strong>DSPy берет на себя эту роль, используя ваши данные и метрики оценки для улучшения текстового представления</strong> — всё от определения нарративного фокуса до оптимизации подсказок и выбора хороших демонстраций. Примечательно, что DSPy может даже использовать метрики оценки для тонкой настройки весов LLM!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--6-.png\" class=\"kg-image\" alt=\"Flowchart illustrating a language model with branches for training data, logic, textual representation, and final results.\" loading=\"lazy\" width=\"1200\" height=\"630\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Heading--6-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/03/Heading--6-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--6-.png 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Для меня ключевые вклады DSPy — замыкание цикла обучения и оценки в промпт-инжиниринге и разделение логики от текстового представления — подчеркивают его потенциальную значимость для систем LLM/Agent. Безусловно амбициозное видение, но определенно необходимое!</p><h2 id=\"what-i-think-dspy-can-improve\">Что, по моему мнению, можно улучшить в DSPy</h2><p>Во-первых, DSPy представляет крутую кривую обучения для новичков из-за своих идиом. Термины вроде <code>signature</code>, <code>module</code>, <code>program</code>, <code>teleprompter</code>, <code>optimization</code> и <code>compile</code> могут быть ошеломляющими. Даже для тех, кто хорошо разбирается в промпт-инжиниринге, навигация по этим концепциям внутри DSPy может быть сложным лабиринтом.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Yeah, DSPy really needs someone to come in and explain everything without suitcase words. <a href=\"https://twitter.com/CShorten30?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">@CShorten30</a> does a great job, but we need more.</p>— Jonathan Mugan (@jmugan) <a href=\"https://twitter.com/jmugan/status/1773036172723236895?ref_src=twsrc%5Etfw&ref=jina-ai-gmbh.ghost.io\">March 27, 2024</a></blockquote>\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></figure><p>Эта сложность напоминает мой опыт работы с <a href=\"https://github.com/jina-ai/jina?ref=jina-ai-gmbh.ghost.io\">Jina 1.0</a>, где мы ввели множество идиом, таких как <code>chunk</code>, <code>document</code>, <code>driver</code>, <code>executor</code>, <code>pea</code>, <code>pod</code>, <code>querylang</code> и <code>flow</code> (мы даже разработали милые стикеры, чтобы помочь пользователям запомнить!).</p><figure class=\"kg-card kg-gallery-card kg-width-wide kg-card-hascaption\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Document-FLAT--3-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Document-FLAT--3-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Document-FLAT--3-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pea-FLAT--1-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Pea-FLAT--1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pea-FLAT--1-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/QueryLang--FLAT.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/QueryLang--FLAT.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/QueryLang--FLAT.png 700w\"></div></div><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--3-FLAT--1-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/ILLUST--3-FLAT--1-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--3-FLAT--1-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pod-FLAT--2-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/Pod-FLAT--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/Pod-FLAT--2-.png 700w\"></div><div class=\"kg-gallery-image\"><img src=\"https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--5-FLAT--2-.png\" width=\"700\" height=\"700\" loading=\"lazy\" alt=\"\" srcset=\"https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/03/ILLUST--5-FLAT--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/2024/03/ILLUST--5-FLAT--2-.png 700w\"></div></div></div><figcaption><p><span style=\"white-space: pre-wrap;\">Большинство этих ранних концепций были удалены в последующих рефакторингах Jina. Сегодня только </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Executor</span></code><span style=\"white-space: pre-wrap;\">, </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Document</span></code><span style=\"white-space: pre-wrap;\"> и </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Flow</span></code><span style=\"white-space: pre-wrap;\"> пережили \"великую чистку\". Мы добавили новую концепцию, </span><code spellcheck=\"false\" style=\"white-space: pre-wrap;\"><span>Deployment</span></code><span style=\"white-space: pre-wrap;\">, в Jina 3.0, так что всё уравновесилось. 🤷</span></p></figcaption></figure><p>Эта проблема не уникальна для DSPy или Jina; вспомните множество концепций и абстракций, представленных TensorFlow между версиями 0.x и 1.x. Я считаю, что эта проблема часто возникает на ранних стадиях программных фреймворков, когда есть стремление <strong>отразить академические обозначения непосредственно в кодовой базе для обеспечения максимальной точности и воспроизводимости</strong>. Однако не все пользователи ценят такие детальные абстракции, предпочтения варьируются от желания простых однострочных решений до требований большей гибкости. Я подробно обсуждал эту тему абстракций в программных фреймворках в блог-посте 2020 года, который может быть интересен читателям.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://hanxiao.io/2020/08/02/Layer-of-Abstraction-when-Building-Tensorflow-for-Search/?ref=jina-ai-gmbh.ghost.io#layer-of-abstraction\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Layer of Abstraction When Building \"Tensorflow\" for Search · Han Xiao Tech Blog - Neural Search &amp; AI Engineering</div><div class=\"kg-bookmark-description\">Since Feb. 2020, I started a new venture called Jina AI. Our mission is to build an open-source neural search ecosystem for businesses and developers, ... · Han Xiao</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://hanxiao.io/wechaticon.png\" alt=\"\"><span class=\"kg-bookmark-author\">logo</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://hanxiao.io/2020/08/02/Layer-of-Abstraction-when-Building-Tensorflow-for-Search/blog-abstraction-banner.jpg\" alt=\"\"></div></a></figure><p>Во-вторых, документация DSPy иногда страдает от недостатка согласованности. Термины вроде <code>module</code> и <code>program</code>, <code>teleprompter</code> и <code>optimizer</code>, или <code>optimize</code> и <code>compile</code> (иногда называемые <code>training</code> или <code>bootstrapping</code>) используются взаимозаменяемо, что добавляет путаницы. Следовательно, я потратил свои первые часы с DSPy, пытаясь понять, что именно он <code>optimizes</code> и что включает в себя процесс <code>bootstrapping</code>.</p><p>Несмотря на эти препятствия, по мере более глубокого погружения в DSPy и повторного обращения к документации, вы, вероятно, испытаете моменты прозрения, когда всё начнёт складываться, раскрывая связи между его уникальной терминологией и знакомыми конструкциями, встречающимися во фреймворках вроде PyTorch. Однако у DSPy, несомненно, есть потенциал для улучшения в будущих версиях, особенно в плане повышения доступности фреймворка для промпт-инженеров <em>без</em> опыта работы с PyTorch.</p><h2 id=\"common-stumbling-blocks-for-dspy-newbies\">Распространённые проблемы для новичков в DSPy</h2><p>В разделах ниже я собрал список вопросов, которые изначально тормозили мой прогресс с DSPy. Моя цель - поделиться этими знаниями в надежде, что они могут прояснить похожие проблемы для других учащихся.</p><h3 id=\"what-are-teleprompter-optimization-and-compile-whats-exactly-being-optimized-in-dspy\">Что такое <code>teleprompter</code>, <code>optimization</code> и <code>compile</code>? Что именно оптимизируется в DSPy?</h3><p>В DSPy \"Teleprompters\" - это оптимизатор (и похоже, что <a href=\"https://twitter.com/lateinteraction?ref=jina-ai-gmbh.ghost.io\">@lateinteraction</a> обновляет документацию и код для большей ясности). Функция <code>compile</code> действует в сердце этого оптимизатора, аналогично вызову <code>optimizer.optimize()</code>. Думайте об этом как об эквиваленте тренировки в DSPy. Процесс <code>compile()</code> нацелен на настройку: </p><ul><li>few-shot демонстраций,</li><li>инструкций, </li><li>весов LLM </li></ul><p>Однако большинство начальных руководств по DSPy не углубляются в настройку весов и инструкций, что приводит к следующему вопросу.</p><h3 id=\"whats-bootstrap-in-dspy-all-about\">Что такое <code>bootstrap</code> в DSPy?</h3><p>Bootstrap относится к созданию самогенерируемых демонстраций для few-shot обучения в контексте, что является важной частью процесса <code>compile()</code> (т.е. оптимизации/тренировки, как я упоминал выше). Эти few-shot демонстрации генерируются из предоставленных пользователем размеченных данных; и одна демонстрация часто состоит из входных данных, выходных данных, обоснования (например, в Chains of Thought) и промежуточных входных и выходных данных (для многоэтапных промптов). Конечно, качественные few-shot демонстрации являются ключом к превосходному результату. Для этого DSPy позволяет определять пользовательские метрические функции, чтобы обеспечить выбор только тех демонстраций, которые соответствуют определённым критериям, что приводит к следующему вопросу.</p><h3 id=\"whats-dspy-metric-function\">Что такое метрическая функция DSPy?</h3><p>После практического опыта работы с DSPy я пришёл к выводу, что метрической функции нужно уделять гораздо больше внимания, чем это делается в текущей документации. Метрическая функция в DSPy играет ключевую роль как в фазах оценки, так и в тренировке, действуя также как функция \"потерь\" благодаря своей неявной природе (контролируется через <code>trace=None</code>):</p><pre><code class=\"language-python\">def keywords_match_jaccard_metric(example, pred, trace=None):  \n    # Jaccard similarity between example keywords and predicted keywords  \n    A = set(normalize_text(example.keywords).split())  \n    B = set(normalize_text(pred.keywords).split())  \n    j = len(A &amp; B) / len(A | B)\n    if trace is not None:\n        # act as a \"loss\" function\n        return j  \n    return j > 0.8  # act as evaluation</code></pre><p>Этот подход существенно отличается от традиционного машинного обучения, где функция потерь обычно непрерывна и дифференцируема (например, hinge/MSE), в то время как метрика оценки может быть совершенно другой и дискретной (например, NDCG). В DSPy функции оценки и потерь объединены в метрической функции, которая может быть дискретной и чаще всего возвращает логическое значение. Метрическая функция также может интегрировать LLM! В примере ниже я реализовал нечёткое сравнение с использованием LLM, чтобы определить, схожи ли предсказанное значение и эталонный ответ по порядку величины, например, \"1 миллион долларов\" и \"$1M\" вернут true.</p><pre><code class=\"language-python\">class Assess(dspy.Signature):  \n    \"\"\"Assess the if the prediction is in the same magnitude to the gold answer.\"\"\"  \n  \n    gold_answer = dspy.InputField(desc='number, could be in natural language')  \n    prediction = dspy.InputField(desc='number, could be in natural language')  \n    assessment = dspy.OutputField(desc='yes or no, focus on the number magnitude, not the unit or exact value or wording')  \n  \ndef same_magnitude_correct(example, pred, trace=None):  \n    return dspy.Predict(Assess)(gold_answer=example.answer, prediction=pred.answer).assessment.lower() == 'yes'</code></pre><p>Метрическая функция, при всей своей мощи, оказывает значительное влияние на пользовательский опыт DSPy, определяя не только финальную оценку качества, но и влияя на результаты оптимизации. Хорошо разработанная метрическая функция может привести к оптимизированным промптам, в то время как плохо составленная может привести к провалу оптимизации. При решении новой задачи с помощью DSPy вы можете обнаружить, что тратите столько же времени на разработку логики (т.е. <code>DSPy.Module</code>), сколько и на метрическую функцию. Такой двойной фокус на логике и метриках может быть пугающим для новичков.</p>\n\n<h3 id=\"bootstrapped-0-full-traces-after-20-examples-in-round-0-what-does-this-mean\"><code>\"Bootstrapped 0 full traces after 20 examples in round 0\"</code> что это значит?</h3>\n\n<p>Это сообщение, тихо появляющееся во время <code>compile()</code>, заслуживает вашего пристального внимания, поскольку по сути означает, что оптимизация/компиляция не удалась, и полученный промпт не лучше простого few-shot. Что идет не так? Я обобщил некоторые советы, которые помогут вам отладить программу DSPy при появлении такого сообщения:</p>\n\n<h4 id=\"your-metric-function-is-incorrect\">Ваша метрическая функция некорректна</h4>\n\n<p>Правильно ли реализована функция <code>your_metric</code>, используемая в <code>BootstrapFewShot(metric=your_metric)</code>? Проведите модульное тестирование. Возвращает ли <code>your_metric</code> когда-либо <code>True</code>, или она всегда возвращает <code>False</code>? Обратите внимание, что возврат <code>True</code> критически важен, поскольку это критерий, по которому DSPy считает пример \"успешным\" при бутстрапе. Если вы возвращаете <code>True</code> для каждой оценки, то каждый пример считается \"успешным\" при бутстрапе! Это, конечно, не идеально, но именно так вы можете настроить строгость метрической функции, чтобы изменить результат <code>\"Bootstrapped 0 full traces\"</code>. Хотя в документации DSPy указано, что метрики также могут возвращать скалярные значения, изучив базовый код, я бы не рекомендовал это новичкам.</p>\n\n<h4 id=\"your-logic-dspymodule-is-incorrect\">Ваша логика (<code>DSPy.Module</code>) некорректна</h4>\n\n<p>Если метрическая функция корректна, тогда нужно проверить, правильно ли реализована ваша логика <code>dspy.Module</code>. Во-первых, убедитесь, что <a href=\"https://dspy-docs.vercel.app/docs/building-blocks/signatures?ref=jina-ai-gmbh.ghost.io\">сигнатура DSPy</a> правильно назначена для каждого шага. Встроенные сигнатуры, такие как <code>dspy.Predict('question->answer')</code>, просты в использовании, но для качества я настоятельно рекомендую реализацию с использованием <a href=\"https://dspy-docs.vercel.app/docs/building-blocks/signatures?ref=jina-ai-gmbh.ghost.io#class-based-dspy-signatures\">сигнатур на основе классов</a>. В частности, добавьте описательные докстринги к классу, заполните поля desc для <code>InputField</code> и <code>OutputField</code> — все это дает языковой модели подсказки о каждом поле. Ниже я реализовал два многоступенчатых <code>DSPy.Module</code> для решения <a href=\"https://en.wikipedia.org/wiki/Fermi_problem?ref=jina-ai-gmbh.ghost.io\">задач Ферми</a>, один со встроенной сигнатурой, другой с сигнатурой на основе классов.</p>\n\n<figure class=\"kg-card kg-code-card\"><pre><code class=\"language-python\">class FermiSolver(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.step1 = dspy.Predict('question -> initial_guess')\n        self.step2 = dspy.Predict('question, initial_guess -> calculated_estimation')\n        self.step3 = dspy.Predict('question, initial_guess, calculated_estimation -> variables_and_formulae')\n        self.step4 = dspy.ReAct('question, initial_guess, calculated_estimation, variables_and_formulae -> gathering_data')\n        self.step5 = dspy.Predict('question, initial_guess, calculated_estimation, variables_and_formulae, gathering_data -> answer')\n\n    def forward(self, q):\n        step1 = self.step1(question=q)\n        step2 = self.step2(question=q, initial_guess=step1.initial_guess)\n        step3 = self.step3(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation)\n        step4 = self.step4(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae)\n        step5 = self.step5(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae, gathering_data=step4.gathering_data)\n        return step5</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">Решатель задач Ферми, использующий только встроенные сигнатуры</span></p></figcaption></figure>\n\n<figure class=\"kg-card kg-code-card\"><pre><code class=\"language-python\">class FermiStep1(dspy.Signature):\n    question = dspy.InputField(desc='Fermi problems involve the use of estimation and reasoning')\n    initial_guess = dspy.OutputField(desc='Have a guess – don't do any calculations yet')\n\nclass FermiStep2(FermiStep1):\n    initial_guess = dspy.InputField(desc='Have a guess – don't do any calculations yet')\n    calculated_estimation = dspy.OutputField(desc='List the information you'll need to solve the problem and make some estimations of the values')\n\nclass FermiStep3(FermiStep2):\n    calculated_estimation = dspy.InputField(desc='List the information you'll need to solve the problem and make some estimations of the values')\n    variables_and_formulae = dspy.OutputField(desc='Write a formula or procedure to solve your problem')\n\nclass FermiStep4(FermiStep3):\n    variables_and_formulae = dspy.InputField(desc='Write a formula or procedure to solve your problem')\n    gathering_data = dspy.OutputField(desc='Research, measure, collect data and use your formula. Find the smallest and greatest values possible')\n\nclass FermiStep5(FermiStep4):\n    gathering_data = dspy.InputField(desc='Research, measure, collect data and use your formula. Find the smallest and greatest values possible')\n    answer = dspy.OutputField(desc='the final answer, must be a numerical value')\n\nclass FermiSolver2(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.step1 = dspy.Predict(FermiStep1)\n        self.step2 = dspy.Predict(FermiStep2)\n        self.step3 = dspy.Predict(FermiStep3)\n        self.step4 = dspy.Predict(FermiStep4)\n        self.step5 = dspy.Predict(FermiStep5)\n\n    def forward(self, q):\n        step1 = self.step1(question=q)\n        step2 = self.step2(question=q, initial_guess=step1.initial_guess)\n        step3 = self.step3(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation)\n        step4 = self.step4(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae)\n        step5 = self.step5(question=q, initial_guess=step1.initial_guess, calculated_estimation=step2.calculated_estimation, variables_and_formulae=step3.variables_and_formulae, gathering_data=step4.gathering_data)\n        return step5</code></pre><figcaption><p><span style=\"white-space: pre-wrap;\">Решатель задач Ферми, использующий сигнатуры на основе классов с более подробным описанием каждого поля.</span></p></figcaption></figure>\n\n<p>Также проверьте часть <code>def forward(self, )</code>. Для многоступенчатых модулей убедитесь, что выход (или <em>все</em> выходы, как в <code>FermiSolver</code>) с последнего шага подается как вход на следующий шаг.</p>\n\n<h4 id=\"your-problem-is-just-too-hard\">Ваша задача просто слишком сложна</h4>\n\n<p>Если и метрика, и модуль кажутся правильными, возможно, ваша задача просто слишком сложна, и реализованной логики недостаточно для её решения. Следовательно, DSPy находит невозможным создать бутстрап-примеры с вашей логикой и метрической функцией. В этом случае есть несколько вариантов:</p>\n\n<ul>\n<li><strong>Использовать более мощную ЯМ.</strong> Например, заменить <code>gpt-35-turbo-instruct</code> на <code>gpt-4-turbo</code> в качестве ЯМ-ученика, использовать более сильную ЯМ в качестве учителя. Это часто бывает довольно эффективно. В конце концов, более сильная модель означает лучшее понимание промптов.</li>\n<li><strong>Улучшить вашу логику.</strong> Добавить или заменить некоторые шаги в вашем <code>dspy.Module</code> на более сложные. Например, заменить <code>Predict</code> на <code>ChainOfThought</code> <code>ProgramOfThought</code>, добавить шаг <code>Retrieval</code>.</li>\n<li><strong>Добавить больше обучающих примеров.</strong> Если 20 примеров недостаточно, стремитесь к 100! Тогда можно надеяться, что один пример пройдет проверку метрикой и будет выбран <code>BootstrapFewShot</code>.</li>\n<li><strong>Переформулировать задачу.</strong> Часто задача становится нерешаемой, когда формулировка неверна. Но если посмотреть на неё под другим углом, всё может стать гораздо проще и очевиднее.</li>\n</ul>\n\n<p>На практике процесс включает в себя сочетание проб и ошибок. Например, я столкнулся с особенно сложной задачей: генерацией SVG-иконки, похожей на иконки Google Material Design, на основе двух-трех ключевых слов. Моя начальная стратегия заключалась в использовании простого <code>DSPy.Module</code>, который использует <code>dspy.ChainOfThought('keywords -> svg')</code>, в сочетании с метрической функцией, оценивающей визуальное сходство между сгенерированным SVG и эталонным SVG Material Design, аналогично алгоритму pHash. Я начал с 20 обучающих примеров, но после первого раунда получил <code>\"Bootstrapped 0 full traces after 20 examples in round 0\"</code>, что указывало на неудачу оптимизации. Увеличив набор данных до 100 примеров, пересмотрев модуль для включения нескольких этапов и настроив порог метрической функции, я в итоге получил 2 бутстрап-демонстрации и смог получить некоторые оптимизированные промпты.</p>",
  "comment_id": "66077bf0a5c39b0001044181",
  "feature_image": "https://jina-ai-gmbh.ghost.io/content/images/2024/03/Heading--7-.png",
  "featured": true,
  "visibility": "public",
  "created_at": "2024-03-30T03:41:52.000+01:00",
  "updated_at": "2024-04-23T10:46:48.000+02:00",
  "published_at": "2024-03-30T06:22:42.000+01:00",
  "custom_excerpt": "Heads up, Bay Area guys ditched their AVP already and buzz about DSPy now. Could DSPy be the new go-to framework for prompt engineering after LangChain and LlamaIndex?",
  "codeinjection_head": null,
  "codeinjection_foot": null,
  "custom_template": null,
  "canonical_url": null,
  "authors": [
    {
      "id": "633ffc6b393501004d1c8659",
      "name": "Han Xiao",
      "slug": "han",
      "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
      "cover_image": null,
      "bio": "Founder & CEO of Jina AI",
      "website": null,
      "location": null,
      "facebook": null,
      "twitter": "@hxiao",
      "meta_title": null,
      "meta_description": null,
      "url": "https://jina-ai-gmbh.ghost.io/author/han/"
    }
  ],
  "tags": [
    {
      "id": "634a1a8ccebfc1003d8ab706",
      "name": "Tech Blog",
      "slug": "tech-blog",
      "description": null,
      "feature_image": null,
      "visibility": "public",
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "canonical_url": null,
      "accent_color": null,
      "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
    }
  ],
  "primary_author": {
    "id": "633ffc6b393501004d1c8659",
    "name": "Han Xiao",
    "slug": "han",
    "profile_image": "https://jina-ai-gmbh.ghost.io/content/images/2022/10/Untitled-2.png",
    "cover_image": null,
    "bio": "Founder & CEO of Jina AI",
    "website": null,
    "location": null,
    "facebook": null,
    "twitter": "@hxiao",
    "meta_title": null,
    "meta_description": null,
    "url": "https://jina-ai-gmbh.ghost.io/author/han/"
  },
  "primary_tag": {
    "id": "634a1a8ccebfc1003d8ab706",
    "name": "Tech Blog",
    "slug": "tech-blog",
    "description": null,
    "feature_image": null,
    "visibility": "public",
    "og_image": null,
    "og_title": null,
    "og_description": null,
    "twitter_image": null,
    "twitter_title": null,
    "twitter_description": null,
    "meta_title": null,
    "meta_description": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "canonical_url": null,
    "accent_color": null,
    "url": "https://jina-ai-gmbh.ghost.io/tag/tech-blog/"
  },
  "url": "https://jina-ai-gmbh.ghost.io/podcast/dspy-not-your-average-prompt-engineering/",
  "excerpt": "Внимание: ребята из Bay Area уже отказались от AVP и теперь обсуждают DSPy. Может ли DSPy стать новым стандартным фреймворком для промпт-инжиниринга после LangChain и LlamaIndex?",
  "reading_time": 13,
  "access": true,
  "comments": false,
  "og_image": null,
  "og_title": null,
  "og_description": null,
  "twitter_image": null,
  "twitter_title": null,
  "twitter_description": null,
  "meta_title": null,
  "meta_description": null,
  "email_subject": null,
  "frontmatter": null,
  "feature_image_alt": "Screenshot of a Tetris-like game with \"Score: 40\" and \"Press Start 2P\" text on display.",
  "feature_image_caption": null
}