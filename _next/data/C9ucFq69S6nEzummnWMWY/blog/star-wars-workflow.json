{"pageProps":{"post":{"title":"May the Source Be With You: Understanding Jina through Star Wars","date":"2020-12-16T14:00:39.923Z","slug":"star-wars-workflow","author":"Alex C-G","content":"<h3>Introduction</h3>\n<p>You've read <a href=\"https://github.com/jina-ai/jina/tree/master/docs/chapters/101\">Jina 101</a> and got an overview of all the Jina components. Let's take a look at how they work together in a simple Jina workflow to search text. Actually, let's go one better, and throw in some Star Wars. Because if there's ever been a year where as need a New Hope it's 2020...</p>\n<p><img src=\"https://media.giphy.com/media/9gISqB3tncMmY/giphy.gif\" alt=\"\"></p>\n<p>Bear in mind there are lots of ways to wire up a Jina workflow; we're just looking at a relatively simple use case for now, and an oversimplification at that. In future posts we'll look at searching different forms of media, see how we can scale up speed and reliability, run Jina remotely, etc.</p>\n<div class=\"alert alert-warning\" role=\"alert\">\n  The code in this post may not actually work in the real world, both because this is a simplified overview but also because Jina is constantly evolving. However, the general concepts should remain the same.\n</div>\n<h3>Prerequisites</h3>\n<p>Some useful reading before you begin:</p>\n<ul>\n<li><a href=\"https://jina.ai/2020/07/06/What-is-Neural-Search-and-Why-Should-I-Care.html\">What is Neural Search, and Why Should I Care?</a></li>\n<li><a href=\"https://github.com/jina-ai/jina/tree/master/docs/chapters/101\">Jina 101</a></li>\n<li><a href=\"https://github.com/jina-ai/examples/tree/master/my-first-jina-app\">Build My First Jina App</a></li>\n</ul>\n<h3>Lies! Evil Wicked Lies!</h3>\n<p>In this post we're doing what Terry Pratchett calls \"<a href=\"https://en.wikipedia.org/wiki/Lie-to-children\">lies to children</a>\", meaning we're skipping a lot of implementation details and simplifying things to make it easier to get a high-level overview without getting bogged down in messy details. We'll dig into some of these details as we go along, but if you yearn to learn about <a href=\"https://github.com/jina-ai/jinad\">Jina's daemon</a> or other low-level things, you should probably check our <a href=\"http://docs.jina.ai\">docs</a>.</p>\n<p>We won't include commands to run the Flows because this is just an over-simplified explanation. The fictional example here lacks a few bits and bobs needed to run in the real world, and aims only to give you an idea of how things are hooked together.</p>\n<div class=\"alert alert-secondary\" role=\"alert\">\n<small>\n<ul>\n<li>Notes about lower-level implementation details will be in little boxes like this.</li>\n<li>Yes, I use the terms <i>indexes</i> not <i>indices</i> in this post. I'm afraid you'll have to live with it</li>\n</ul>\n</small>\n</div>\n<h3>Search as a Black Box</h3>\n<p>Let's start by looking at a simple \"black box\" overview of a search. It has several top-level \"components\":</p>\n<p><img src=\"/assets/images/blog/star_wars/blackbox.svg\" alt=\"\"></p>\n<p>| Component                       | Star Wars example                                                          |\n| ---                             | ---                                                                        |\n| Data you want to search         | All the text of the Star Wars movie scripts                                |\n| Search query                    | A single line like <code>Give me a hand Mr Space Wizard</code>                        |\n| Jina core                       | The magical box that finds the closest match to your query in all the data |\n| Ranked results                  | A list of closest matches (for example, <code>Help me Obi Wan-Kenobi</code>)          |</p>\n<p><img src=\"https://media.giphy.com/media/DrL54YGfFb5Bu/giphy.gif\" alt=\"\"></p>\n<p>In this example we're using CSV files (all the Star Wars scripts) as our dataset, but if we wanted we could also use Jina to search through the movies themselves for soundbites or scenes, based on audio, video, and subtitle data.</p>\n<p>First up we'll focus on <strong>indexing</strong>, so don't worry about the querying bit for now. After all you have to <strong>process</strong> the plans for the Death Star before you can <strong>search out</strong> it's vulnerability, right?</p>\n<h3>Indexing</h3>\n<h4>Flows</h4>\n<p>The first step is to build a Flow and feed in our CSV files. As you've read from Jina 101, the <a href=\"https://github.com/jina-ai/jina/tree/master/docs/chapters/101#flow\">Flow</a> is the high-level abstraction Jina uses for any search. Data is fed in, processed, and results spat out the other end. These Flows act as pipelines for indexing and querying:</p>\n<p><img src=\"/assets/images/blog/star_wars/flow-index.svg\" alt=\"\"></p>\n<p>Note: Since we're only interested in <strong>indexing</strong> for now, we've left out the results. They'll come when querying.</p>\n<p>You can build a Flow in Python, YAML, or <a href=\"https://github.com/jina-ai/dashboard\">Jina Dashboard</a>. In our case we'll use <strike>an elegant weapon for a more civilized age</strike> <a href=\"https://github.com/jina-ai/jina/tree/master/docs/chapters/101#yaml-config\">YAML</a> to create an empty Flow:</p>\n<pre><code class=\"language-yaml\">!Flow\n  # We'll fill this in soon, don't worry!\n</code></pre>\n<p>Let's save that as <code>flows/index.yml</code>. Don't worry if it looks as useful as Jar Jar Binks. We'll flesh it out in the next section.</p>\n<p><img src=\"https://media.giphy.com/media/3owzWfuEMmNX4rquJ2/giphy.gif\" alt=\"\"></p>\n<p>While we're at it, let's add our (currently useless) Flow to <code>app.py</code> and set it to index:</p>\n<pre><code class=\"language-python\">from jina.flow import Flow\n\ndef input_fn():\n  # see above\n\nf = Flow().load_config(\"flows/index.yml\")\n\nwith f:\n  f.index(filepath=\"scripts/*\") # Note this isn't the exact method you'd use. It's a bit simplified\n</code></pre>\n<h4>Pods</h4>\n<p>Each task in the Flow is performed by a different <a href=\"https://github.com/jina-ai/jina/tree/master/docs/chapters/101#pods\">Pod</a> which can be written in YAML or Python. Our Star Wars example indexing Flow looks like:</p>\n<p><img src=\"/assets/images/blog/star_wars/pods.svg\" alt=\"\"></p>\n<p>Earlier we created a Flow using <code>flows/index.yml</code>. Let's expand that file with a list of Pods:</p>\n<pre><code class=\"language-yaml\">!Flow\nversion: '1'\npods:\n  - name: crafter:\n      uses: pods/craft.yml\n  - name: encoder:\n      uses: pods/encode.yml\n  - name: chunk_indexer:\n      uses: pods/chunk_index.yml\n  - name: doc_indexer:\n      uses: pods/doc_index.yml\n</code></pre>\n<p>Pods are configured in their own YAML files (like <code>pods/chunk_idx.yml</code>) and may behave differently depending on which Flow they're in:</p>\n<p>| Pod             | Indexing Flow                                   | Querying Flow                                                         |\n| ---             | ---                                             | ---                                                                   |\n| <code>crafter</code>       | Break dataset into sub-documents                | N/A (user query is already same format as output i.e a sentence)      |\n| <code>encoder</code>       | Encode sub-documents into vectors               | Encode user query into vectors                                        |\n| <code>chunk_indexer</code> | <strong>Create</strong> vector and sub-document indexes      | <strong>Search</strong> vector and sub-document indexes for matches                |\n| <code>doc_indexer</code>   | <strong>Create</strong> index of Documents and sub-documents | <strong>Search</strong> Doc indexes for matching sub-documents            |\n| <code>ranker</code>        | N/A                                             | Rank results by relevance                                             |</p>\n<p>We'll dig more into Pod YAML files in the Executor section below.</p>\n<div class=\"alert alert-secondary\" role=\"alert\">\n<small>\nTechnically each Pod contains at least one Pea as well. However, this is lower-level and we'll discuss that in another post.\n</small>\n</div>\n<h5>What Does Each Pod Do?</h5>\n<p><strong>Crafter</strong></p>\n<p>A Crafter takes our CSV file as input and breaks it down into sub-documents:</p>\n<p><img src=\"/assets/images/blog/star_wars/pod-craft.svg\" alt=\"\"></p>\n<p>To keep things simple, in our example the Crafter is just splitting each line from the input CSVs into individual sentences. But if we wanted to do a more advanced text search, we could split the document (script) into any level of granularity (like line, sentence, word, etc, a.k.a sub-documents). Each sub-document comes with its own metadata (like <code>doc_id</code>, <code>parent_id</code>, <code>granularity</code>, etc).</p>\n<div class=\"alert alert-secondary\" role=\"alert\">\n<small>\nSometimes we call these sub-documents \"Chunks\". A sub-document and a Chunk are exactly the same thing.\n</small>\n</div>\n<p><strong>Encoder</strong></p>\n<p>An encoder takes a sub-document and converts it to a <a href=\"https://www.youtube.com/watch?v=gQddtTdmG_8&#x26;t=193s\">vector embedding</a>:</p>\n<p><img src=\"/assets/images/blog/star_wars/pod-encode.svg\" alt=\"\"></p>\n<p>Closely related sub-documents have similar embeddings, for example <code>jedi</code> and <code>space_wizard</code> would have similar embeddings, while <code>death_star</code> and <code>princess</code> would be very different from each other.</p>\n<p><strong>Chunk Indexer</strong></p>\n<p>The Chunk indexer takes all of the sub-documents and their embeddings as input and creates two indexes as output:</p>\n<ul>\n<li><strong>Vector index</strong>: Stores <code>doc_id</code> and vector embedding of each sub-document</li>\n<li><strong>Key-value index</strong>: Stores <code>doc_id</code>, <code>parent_id</code> and any metadata associated with each sub-document</li>\n</ul>\n<p><img src=\"/assets/images/blog/star_wars/pod-chunk_idx.svg\" alt=\"\"></p>\n<p><strong>Document Indexer</strong></p>\n<p>Creates an index of Documents and their associated <code>doc_id</code>s for each level of granularity specified:</p>\n<p><img src=\"/assets/images/blog/star_wars/pod-doc_idx.svg\" alt=\"\"></p>\n<p>And that's the last step of the Flow for indexing! But wait, there's more to learn before we jump into querying!</p>\n<h4>Executors</h4>\n<p>Now we've processed all that data - but we haven't even dived into the deep learning behind Jina.</p>\n<p>That's where our <a href=\"https://github.com/jina-ai/jina/tree/master/docs/chapters/101#executors\">Executors</a> come in. Like droids, some of them are \"smart\" (i.e. like an executor in the <code>encoder</code> Pod which uses artificial intelligence), while some are just more-or-less mindless automatons (like the indexers). Either way, they're the ones who do all the real work. Everything else is just higher-level wrappers to make them easier to work with.</p>\n<p><img src=\"/assets/images/blog/star_wars/executors.svg\" alt=\"\"></p>\n<p>We'll use the analogy of Luke flying his X-wing to blow up the Death Star:</p>\n<p>| X-wing | Pod (the container and \"interface\" that lets R2 fly)\n| R2D2 | Executor (the one who actually does all the work)\n| Luke | Useless bag of flesh who doesn't do much except \"trust the force\", pull the trigger and get the glory</p>\n<p><img src=\"https://media.giphy.com/media/EPPvrXLVm6Axy/giphy.gif\" alt=\"\"></p>\n<p>Since each Pod has a different task, each Pod uses a different executor. After all, you wouldn't ask C3PO to fly an X-wing, and you wouldn't ask R2D2 to <strike>wander around like a useless gold mannequin who gets lost in the desert</strike> translate languages. Let's look at our <code>encoder.yml</code> Pod as an example:</p>\n<pre><code class=\"language-yaml\">!TransformerTorchEncoder\nwith:\n  pooling_strategy: auto\n  pretrained_model_name_or_path: distilbert-base-cased\n  max_length: 96\n# More stuff here\n</code></pre>\n<p>We can see that it uses <code>TransformerTorchEncoder</code> to encode our sub-documents into vector embeddings using the <code>distilbert-base-cased</code> language model. For example:</p>\n<p>| Input | Output Vector           |\n| ---                      | ---                     |\n| <code>Help me Obi Wan-Kenobi</code> | <code>{1.2, 0.6, -3.1, ...}</code> |\n| <code>You're my only hope</code>    | <code>{-0.3, 1.5, 0.7, ...}</code> |</p>\n<p>In this way, <code>TransformerTorchEncoder</code> is like C3PO. It knows how to translate things to other things, like text to vector embeddings (admittedly, not over 6 million forms of translation, but we only have 3PO's word for that). However, it is probably equally useless at getting out of a desert.</p>\n<p><img src=\"https://media.giphy.com/media/TZFmvyDvr3WaQ/source.gif\" alt=\"\"></p>\n<h4>Storage</h4>\n<p>Phew, that's a lot of data! But where is it all stored? Jina uses a working directory, usually <code>workspace</code> to store all of the indexes created by the Pods above.</p>\n<p><img src=\"/assets/images/blog/star_wars/storage.svg\" alt=\"\"></p>\n<p>Note that many of the Pods write <em>nothing</em> to storage. They merely pass their output to the next Pod in the Flow. It's only when data needs to be available <em>between</em> Flows that data needs to be written to storage (in our case, the indexes created by <code>chunk_indexer</code> and <code>doc_indexer</code>).</p>\n<h3>Running the Indexing Flow</h3>\n<p>In the introduction we mentioned this was just meant as an overview and not a \"real\" Flow (though it could be built into a working example). In short, it won't run as is. However, if you <em>did</em> want to run it, it's as simple as:</p>\n<pre><code class=\"language-bash\">python app.py index\n</code></pre>\n<h3>Querying</h3>\n<p>At this point the index Flow is out of the picture, so we can safely ignore both the Flow and the original input documents:</p>\n<p><img src=\"/assets/images/blog/star_wars/flow-query.svg\" alt=\"\"></p>\n<p>The query Flow is very similar to the indexing Flow. It:</p>\n<ul>\n<li>Takes a user query as input (<code>Give me a hand Mr Space Wizard</code>)</li>\n<li>Processes it (get its vector)</li>\n<li>Pulls the indexes from storage</li>\n<li>Finds the closest vectors in the vector index (like the vector for <code>Help me Obi-Wan Kenobi</code>) and gets the <code>doc_id</code>s</li>\n<li>Ranks the closest matching Documents</li>\n<li>Returns the ranked list to the user via REST or gRPC</li>\n</ul>\n<p>A human readable version of this ranked list might look like:</p>\n<p>| Rank | Line                                                                     | Document ID | Parent Doc      | Metadata        |\n| ---  | ---                                                                      | ---         | ---             | ---             |\n| 1    | Help me Obi-Wan Kenobi                                                   | 4501        | 04              | speaker: LEIA   |\n| 2    | Yes, I was once a Jedi Knight the same as your father                    | 4702        | 04              | speaker: OBIWAN |\n| 3    | I'm looking for a Jedi Master                                            | 5304        | 05              | speaker: LUKE   |</p>\n<p>And so on...</p>\n<p>Like indexing, you'd run the Flow with:</p>\n<pre><code class=\"language-bash\">python app.py query\n</code></pre>\n<h3>Summary</h3>\n<p>In this post we've covered most of the components from <a href=\"https://github.com/jina-ai/jina/tree/master/docs/chapters/101\">Jina 101</a>, what they do, and how they're hooked together in the context of a simple text-based search.</p>\n<p>Hopefully by now you should understand:</p>\n<ul>\n<li>Jina searches require indexing and querying Flows</li>\n<li>Flows can be built in YAML, Python, or <a href=\"https://github.com/jina-ai/dashboard\">Jina Dashboard</a></li>\n<li>Flows are called from <code>app.py</code></li>\n<li>Documents go through a series of steps in each Flow, being passed through Pods which in turn use Executors to take input, process it, and pass it to the next Pod (and sometimes read from or write to storage)</li>\n<li>There may be different Pods in each Flow (in our example, the query Flow lacks <code>crafter</code> Pod, and the indexing Flow lacks <code>ranker</code>)</li>\n<li>Output is returned as a ranked list of matching Documents, based on similarity of embedding</li>\n</ul>\n<p>As we mentioned at the start, the above is over-simplified and certainly not exhaustive. There's always more to learn and deeper components to dive into.</p>\n<h3>Next Time</h3>\n<p>Of course, there's always more to learn, just as there's always yet another Death Star to take down. In future posts we'll cover running Pods and Flows remotely, speeding up performance, improving reliability, searching different kinds of things, and lots more. Let us know which you'd like to learn about via <a href=\"https://twitter.com/jinaAI_\">Twitter</a> or our <a href=\"https://slack.jina.ai\">Slack community</a>!</p>\n<p>Until then, may the Force be with you...</p>\n<p><img src=\"https://media.giphy.com/media/3o85xAojNshmzlySyc/giphy.gif\" alt=\"\"></p>\n","coverImage":"/assets/images/blog/star_wars/cover.svg","tags":["text search","nlp"]}},"__N_SSG":true}